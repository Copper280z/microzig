// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 62e33d0e2175e4c1621e1dbf9f6ac3ec18f6ba38
//
// vendor: ESPRESSIF SYSTEMS (SHANGHAI) CO., LTD.
// device: ESP32-C3
// cpu: RV32IMC

pub const registers = struct {
    /// AES (Advanced Encryption Standard) Accelerator
    pub const AES = struct {
        pub const base_address = 0x6003a000;

        /// address: 0x6003a000
        /// Key material key_0 configure register
        pub const KEY_0 = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x6003a004
        /// Key material key_1 configure register
        pub const KEY_1 = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x6003a008
        /// Key material key_2 configure register
        pub const KEY_2 = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x6003a00c
        /// Key material key_3 configure register
        pub const KEY_3 = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x6003a010
        /// Key material key_4 configure register
        pub const KEY_4 = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x6003a014
        /// Key material key_5 configure register
        pub const KEY_5 = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x6003a018
        /// Key material key_6 configure register
        pub const KEY_6 = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x6003a01c
        /// Key material key_7 configure register
        pub const KEY_7 = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x6003a020
        /// source text material text_in_0 configure register
        pub const TEXT_IN_0 = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x6003a024
        /// source text material text_in_1 configure register
        pub const TEXT_IN_1 = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x6003a028
        /// source text material text_in_2 configure register
        pub const TEXT_IN_2 = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x6003a02c
        /// source text material text_in_3 configure register
        pub const TEXT_IN_3 = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x6003a030
        /// result text material text_out_0 configure register
        pub const TEXT_OUT_0 = @intToPtr(*volatile u32, base_address + 0x30);

        /// address: 0x6003a034
        /// result text material text_out_1 configure register
        pub const TEXT_OUT_1 = @intToPtr(*volatile u32, base_address + 0x34);

        /// address: 0x6003a038
        /// result text material text_out_2 configure register
        pub const TEXT_OUT_2 = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0x6003a03c
        /// result text material text_out_3 configure register
        pub const TEXT_OUT_3 = @intToPtr(*volatile u32, base_address + 0x3c);

        /// address: 0x6003a040
        /// AES Mode register
        pub const MODE = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x40);

        /// address: 0x6003a044
        /// AES Endian configure register
        pub const ENDIAN = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x44);

        /// address: 0x6003a048
        /// AES trigger register
        pub const TRIGGER = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x48);

        /// address: 0x6003a04c
        /// AES state register
        pub const STATE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x4c);

        /// address: 0x6003a050
        /// The memory that stores initialization vector
        pub const IV_MEM = @intToPtr(*volatile [16]u8, base_address + 0x50);

        /// address: 0x6003a060
        /// The memory that stores GCM hash subkey
        pub const H_MEM = @intToPtr(*volatile [16]u8, base_address + 0x60);

        /// address: 0x6003a070
        /// The memory that stores J0
        pub const J0_MEM = @intToPtr(*volatile [16]u8, base_address + 0x70);

        /// address: 0x6003a080
        /// The memory that stores T0
        pub const T0_MEM = @intToPtr(*volatile [16]u8, base_address + 0x80);

        /// address: 0x6003a090
        /// DMA-AES working mode register
        pub const DMA_ENABLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x90);

        /// address: 0x6003a094
        /// AES cipher block mode register
        pub const BLOCK_MODE = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x94);

        /// address: 0x6003a098
        /// AES block number register
        pub const BLOCK_NUM = @intToPtr(*volatile u32, base_address + 0x98);

        /// address: 0x6003a09c
        /// Standard incrementing function configure register
        pub const INC_SEL = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x9c);

        /// address: 0x6003a0a0
        /// Additional Authential Data block number register
        pub const AAD_BLOCK_NUM = @intToPtr(*volatile u32, base_address + 0xa0);

        /// address: 0x6003a0a4
        /// AES remainder bit number register
        pub const REMAINDER_BIT_NUM = @intToPtr(*volatile MmioInt(32, u7), base_address + 0xa4);

        /// address: 0x6003a0a8
        /// AES continue register
        pub const CONTINUE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xa8);

        /// address: 0x6003a0ac
        /// AES Interrupt clear register
        pub const INT_CLEAR = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xac);

        /// address: 0x6003a0b0
        /// AES Interrupt enable register
        pub const INT_ENA = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xb0);

        /// address: 0x6003a0b4
        /// AES version control register
        pub const DATE = @intToPtr(*volatile MmioInt(32, u30), base_address + 0xb4);

        /// address: 0x6003a0b8
        /// AES-DMA exit config
        pub const DMA_EXIT = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xb8);
    };

    /// Advanced Peripheral Bus Controller
    pub const APB_CTRL = struct {
        pub const base_address = 0x60026000;

        /// address: 0x60026000
        /// APB_CTRL_SYSCLK_CONF_REG
        pub const SYSCLK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_pre_div_cnt
            PRE_DIV_CNT: u10,
            /// reg_clk_320m_en
            CLK_320M_EN: u1,
            /// reg_clk_en
            CLK_EN: u1,
            /// reg_rst_tick_cnt
            RST_TICK_CNT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x60026004
        /// APB_CTRL_TICK_CONF_REG
        pub const TICK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_xtal_tick_num
            XTAL_TICK_NUM: u8,
            /// reg_ck8m_tick_num
            CK8M_TICK_NUM: u8,
            /// reg_tick_enable
            TICK_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x4);

        /// address: 0x60026008
        /// APB_CTRL_CLK_OUT_EN_REG
        pub const CLK_OUT_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_clk20_oen
            CLK20_OEN: u1,
            /// reg_clk22_oen
            CLK22_OEN: u1,
            /// reg_clk44_oen
            CLK44_OEN: u1,
            /// reg_clk_bb_oen
            CLK_BB_OEN: u1,
            /// reg_clk80_oen
            CLK80_OEN: u1,
            /// reg_clk160_oen
            CLK160_OEN: u1,
            /// reg_clk_320m_oen
            CLK_320M_OEN: u1,
            /// reg_clk_adc_inf_oen
            CLK_ADC_INF_OEN: u1,
            /// reg_clk_dac_cpu_oen
            CLK_DAC_CPU_OEN: u1,
            /// reg_clk40x_bb_oen
            CLK40X_BB_OEN: u1,
            /// reg_clk_xtal_oen
            CLK_XTAL_OEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x8);

        /// address: 0x6002600c
        /// APB_CTRL_WIFI_BB_CFG_REG
        pub const WIFI_BB_CFG = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x60026010
        /// APB_CTRL_WIFI_BB_CFG_2_REG
        pub const WIFI_BB_CFG_2 = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x60026014
        /// APB_CTRL_WIFI_CLK_EN_REG
        pub const WIFI_CLK_EN = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x60026018
        /// APB_CTRL_WIFI_RST_EN_REG
        pub const WIFI_RST_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wifi_rst
            WIFI_RST: u32,
        }), base_address + 0x18);

        /// address: 0x6002601c
        /// APB_CTRL_HOST_INF_SEL_REG
        pub const HOST_INF_SEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_peri_io_swap
            PERI_IO_SWAP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x60026020
        /// APB_CTRL_EXT_MEM_PMS_LOCK_REG
        pub const EXT_MEM_PMS_LOCK = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x20);

        /// address: 0x60026028
        /// APB_CTRL_FLASH_ACE0_ATTR_REG
        pub const FLASH_ACE0_ATTR = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x28);

        /// address: 0x6002602c
        /// APB_CTRL_FLASH_ACE1_ATTR_REG
        pub const FLASH_ACE1_ATTR = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x2c);

        /// address: 0x60026030
        /// APB_CTRL_FLASH_ACE2_ATTR_REG
        pub const FLASH_ACE2_ATTR = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x30);

        /// address: 0x60026034
        /// APB_CTRL_FLASH_ACE3_ATTR_REG
        pub const FLASH_ACE3_ATTR = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x34);

        /// address: 0x60026038
        /// APB_CTRL_FLASH_ACE0_ADDR_REG
        pub const FLASH_ACE0_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_flash_ace0_addr_s
            S: u32,
        }), base_address + 0x38);

        /// address: 0x6002603c
        /// APB_CTRL_FLASH_ACE1_ADDR_REG
        pub const FLASH_ACE1_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_flash_ace1_addr_s
            S: u32,
        }), base_address + 0x3c);

        /// address: 0x60026040
        /// APB_CTRL_FLASH_ACE2_ADDR_REG
        pub const FLASH_ACE2_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_flash_ace2_addr_s
            S: u32,
        }), base_address + 0x40);

        /// address: 0x60026044
        /// APB_CTRL_FLASH_ACE3_ADDR_REG
        pub const FLASH_ACE3_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_flash_ace3_addr_s
            S: u32,
        }), base_address + 0x44);

        /// address: 0x60026048
        /// APB_CTRL_FLASH_ACE0_SIZE_REG
        pub const FLASH_ACE0_SIZE = @intToPtr(*volatile MmioInt(32, u13), base_address + 0x48);

        /// address: 0x6002604c
        /// APB_CTRL_FLASH_ACE1_SIZE_REG
        pub const FLASH_ACE1_SIZE = @intToPtr(*volatile MmioInt(32, u13), base_address + 0x4c);

        /// address: 0x60026050
        /// APB_CTRL_FLASH_ACE2_SIZE_REG
        pub const FLASH_ACE2_SIZE = @intToPtr(*volatile MmioInt(32, u13), base_address + 0x50);

        /// address: 0x60026054
        /// APB_CTRL_FLASH_ACE3_SIZE_REG
        pub const FLASH_ACE3_SIZE = @intToPtr(*volatile MmioInt(32, u13), base_address + 0x54);

        /// address: 0x60026088
        /// APB_CTRL_SPI_MEM_PMS_CTRL_REG
        pub const SPI_MEM_PMS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_spi_mem_reject_int
            SPI_MEM_REJECT_INT: u1,
            /// reg_spi_mem_reject_clr
            SPI_MEM_REJECT_CLR: u1,
            /// reg_spi_mem_reject_cde
            SPI_MEM_REJECT_CDE: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x88);

        /// address: 0x6002608c
        /// APB_CTRL_SPI_MEM_REJECT_ADDR_REG
        pub const SPI_MEM_REJECT_ADDR = @intToPtr(*volatile u32, base_address + 0x8c);

        /// address: 0x60026090
        /// APB_CTRL_SDIO_CTRL_REG
        pub const SDIO_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_sdio_win_access_en
            SDIO_WIN_ACCESS_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x90);

        /// address: 0x60026094
        /// APB_CTRL_REDCY_SIG0_REG
        pub const REDCY_SIG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_redcy_sig0
            REDCY_SIG0: u31,
            /// reg_redcy_andor
            REDCY_ANDOR: u1,
        }), base_address + 0x94);

        /// address: 0x60026098
        /// APB_CTRL_REDCY_SIG1_REG
        pub const REDCY_SIG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_redcy_sig1
            REDCY_SIG1: u31,
            /// reg_redcy_nandor
            REDCY_NANDOR: u1,
        }), base_address + 0x98);

        /// address: 0x6002609c
        /// APB_CTRL_FRONT_END_MEM_PD_REG
        pub const FRONT_END_MEM_PD = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_agc_mem_force_pu
            AGC_MEM_FORCE_PU: u1,
            /// reg_agc_mem_force_pd
            AGC_MEM_FORCE_PD: u1,
            /// reg_pbus_mem_force_pu
            PBUS_MEM_FORCE_PU: u1,
            /// reg_pbus_mem_force_pd
            PBUS_MEM_FORCE_PD: u1,
            /// reg_dc_mem_force_pu
            DC_MEM_FORCE_PU: u1,
            /// reg_dc_mem_force_pd
            DC_MEM_FORCE_PD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x9c);

        /// address: 0x600260a0
        /// APB_CTRL_RETENTION_CTRL_REG
        pub const RETENTION_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_retention_link_addr
            RETENTION_LINK_ADDR: u27,
            /// reg_nobypass_cpu_iso_rst
            NOBYPASS_CPU_ISO_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xa0);

        /// address: 0x600260a4
        /// APB_CTRL_CLKGATE_FORCE_ON_REG
        pub const CLKGATE_FORCE_ON = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rom_clkgate_force_on
            ROM_CLKGATE_FORCE_ON: u2,
            /// reg_sram_clkgate_force_on
            SRAM_CLKGATE_FORCE_ON: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xa4);

        /// address: 0x600260a8
        /// APB_CTRL_MEM_POWER_DOWN_REG
        pub const MEM_POWER_DOWN = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rom_power_down
            ROM_POWER_DOWN: u2,
            /// reg_sram_power_down
            SRAM_POWER_DOWN: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xa8);

        /// address: 0x600260ac
        /// APB_CTRL_MEM_POWER_UP_REG
        pub const MEM_POWER_UP = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rom_power_up
            ROM_POWER_UP: u2,
            /// reg_sram_power_up
            SRAM_POWER_UP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xac);

        /// address: 0x600260b0
        /// APB_CTRL_RND_DATA_REG
        pub const RND_DATA = @intToPtr(*volatile u32, base_address + 0xb0);

        /// address: 0x600260b4
        /// APB_CTRL_PERI_BACKUP_CONFIG_REG
        pub const PERI_BACKUP_CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// reg_peri_backup_flow_err
            PERI_BACKUP_FLOW_ERR: u2,
            reserved1: u1,
            /// reg_peri_backup_burst_limit
            PERI_BACKUP_BURST_LIMIT: u5,
            /// reg_peri_backup_tout_thres
            PERI_BACKUP_TOUT_THRES: u10,
            /// reg_peri_backup_size
            PERI_BACKUP_SIZE: u10,
            /// reg_peri_backup_start
            PERI_BACKUP_START: u1,
            /// reg_peri_backup_to_mem
            PERI_BACKUP_TO_MEM: u1,
            /// reg_peri_backup_ena
            PERI_BACKUP_ENA: u1,
        }), base_address + 0xb4);

        /// address: 0x600260b8
        /// APB_CTRL_PERI_BACKUP_APB_ADDR_REG
        pub const PERI_BACKUP_APB_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_backup_apb_start_addr
            BACKUP_APB_START_ADDR: u32,
        }), base_address + 0xb8);

        /// address: 0x600260bc
        /// APB_CTRL_PERI_BACKUP_MEM_ADDR_REG
        pub const PERI_BACKUP_MEM_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_backup_mem_start_addr
            BACKUP_MEM_START_ADDR: u32,
        }), base_address + 0xbc);

        /// address: 0x600260c0
        /// APB_CTRL_PERI_BACKUP_INT_RAW_REG
        pub const PERI_BACKUP_INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_peri_backup_done_int_raw
            PERI_BACKUP_DONE_INT_RAW: u1,
            /// reg_peri_backup_err_int_raw
            PERI_BACKUP_ERR_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc0);

        /// address: 0x600260c4
        /// APB_CTRL_PERI_BACKUP_INT_ST_REG
        pub const PERI_BACKUP_INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_peri_backup_done_int_st
            PERI_BACKUP_DONE_INT_ST: u1,
            /// reg_peri_backup_err_int_st
            PERI_BACKUP_ERR_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc4);

        /// address: 0x600260c8
        /// APB_CTRL_PERI_BACKUP_INT_ENA_REG
        pub const PERI_BACKUP_INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_peri_backup_done_int_ena
            PERI_BACKUP_DONE_INT_ENA: u1,
            /// reg_peri_backup_err_int_ena
            PERI_BACKUP_ERR_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc8);

        /// address: 0x600260d0
        /// APB_CTRL_PERI_BACKUP_INT_CLR_REG
        pub const PERI_BACKUP_INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_peri_backup_done_int_clr
            PERI_BACKUP_DONE_INT_CLR: u1,
            /// reg_peri_backup_err_int_clr
            PERI_BACKUP_ERR_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xd0);

        /// address: 0x600263fc
        /// APB_CTRL_DATE_REG
        pub const DATE = @intToPtr(*volatile u32, base_address + 0x3fc);
    };

    /// Successive Approximation Register Analog to Digital Converter
    pub const APB_SARADC = struct {
        pub const base_address = 0x60040000;

        /// address: 0x60040000
        /// digital saradc configure register
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// select software enable saradc sample
            SARADC_START_FORCE: u1,
            /// software enable saradc sample
            SARADC_START: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// SAR clock gated
            SARADC_SAR_CLK_GATED: u1,
            /// SAR clock divider
            SARADC_SAR_CLK_DIV: u8,
            /// 0 ~ 15 means length 1 ~ 16
            SARADC_SAR_PATT_LEN: u3,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// clear the pointer of pattern table for DIG ADC1 CTRL
            SARADC_SAR_PATT_P_CLEAR: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// force option to xpd sar blocks
            SARADC_XPD_SAR_FORCE: u2,
            reserved12: u1,
            /// wait arbit signal stable after sar_done
            SARADC_WAIT_ARB_CYCLE: u2,
        }), base_address + 0x0);

        /// address: 0x60040004
        /// digital saradc configure register
        pub const CTRL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// enable max meas num
            SARADC_MEAS_NUM_LIMIT: u1,
            /// max conversion number
            SARADC_MAX_MEAS_NUM: u8,
            /// 1: data to DIG ADC1 CTRL is inverted, otherwise not
            SARADC_SAR1_INV: u1,
            /// 1: data to DIG ADC2 CTRL is inverted, otherwise not
            SARADC_SAR2_INV: u1,
            reserved0: u1,
            /// to set saradc timer target
            SARADC_TIMER_TARGET: u12,
            /// to enable saradc timer trigger
            SARADC_TIMER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x4);

        /// address: 0x60040008
        /// digital saradc configure register
        pub const FILTER_CTRL1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// Factor of saradc filter1
            APB_SARADC_FILTER_FACTOR1: u3,
            /// Factor of saradc filter0
            APB_SARADC_FILTER_FACTOR0: u3,
        }), base_address + 0x8);

        /// address: 0x6004000c
        /// digital saradc configure register
        pub const FSM_WAIT = @intToPtr(*volatile Mmio(32, packed struct {
            /// saradc_xpd_wait
            SARADC_XPD_WAIT: u8,
            /// saradc_rstb_wait
            SARADC_RSTB_WAIT: u8,
            /// saradc_standby_wait
            SARADC_STANDBY_WAIT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc);

        /// address: 0x60040010
        /// digital saradc configure register
        pub const SAR1_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// saradc1 status about data and channel
            SARADC_SAR1_STATUS: u32,
        }), base_address + 0x10);

        /// address: 0x60040014
        /// digital saradc configure register
        pub const SAR2_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// saradc2 status about data and channel
            SARADC_SAR2_STATUS: u32,
        }), base_address + 0x14);

        /// address: 0x60040018
        /// digital saradc configure register
        pub const SAR_PATT_TAB1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// item 0 ~ 3 for pattern table 1 (each item one byte)
            SARADC_SAR_PATT_TAB1: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x6004001c
        /// digital saradc configure register
        pub const SAR_PATT_TAB2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Item 4 ~ 7 for pattern table 1 (each item one byte)
            SARADC_SAR_PATT_TAB2: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x1c);

        /// address: 0x60040020
        /// digital saradc configure register
        pub const ONETIME_SAMPLE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// configure onetime atten
            SARADC_ONETIME_ATTEN: u2,
            /// configure onetime channel
            SARADC_ONETIME_CHANNEL: u4,
            /// trigger adc onetime sample
            SARADC_ONETIME_START: u1,
            /// enable adc2 onetime sample
            SARADC2_ONETIME_SAMPLE: u1,
            /// enable adc1 onetime sample
            SARADC1_ONETIME_SAMPLE: u1,
        }), base_address + 0x20);

        /// address: 0x60040024
        /// digital saradc configure register
        pub const ARB_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// adc2 arbiter force to enableapb controller
            ADC_ARB_APB_FORCE: u1,
            /// adc2 arbiter force to enable rtc controller
            ADC_ARB_RTC_FORCE: u1,
            /// adc2 arbiter force to enable wifi controller
            ADC_ARB_WIFI_FORCE: u1,
            /// adc2 arbiter force grant
            ADC_ARB_GRANT_FORCE: u1,
            /// Set adc2 arbiterapb priority
            ADC_ARB_APB_PRIORITY: u2,
            /// Set adc2 arbiter rtc priority
            ADC_ARB_RTC_PRIORITY: u2,
            /// Set adc2 arbiter wifi priority
            ADC_ARB_WIFI_PRIORITY: u2,
            /// adc2 arbiter uses fixed priority
            ADC_ARB_FIX_PRIORITY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x24);

        /// address: 0x60040028
        /// digital saradc configure register
        pub const FILTER_CTRL0 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// configure filter1 to adc channel
            APB_SARADC_FILTER_CHANNEL1: u4,
            /// configure filter0 to adc channel
            APB_SARADC_FILTER_CHANNEL0: u4,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// enable apb_adc1_filter
            APB_SARADC_FILTER_RESET: u1,
        }), base_address + 0x28);

        /// address: 0x6004002c
        /// digital saradc configure register
        pub const SAR1DATA_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// saradc1 data
            APB_SARADC1_DATA: u17,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x2c);

        /// address: 0x60040030
        /// digital saradc configure register
        pub const SAR2DATA_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// saradc2 data
            APB_SARADC2_DATA: u17,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x30);

        /// address: 0x60040034
        /// digital saradc configure register
        pub const THRES0_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// configure thres0 to adc channel
            APB_SARADC_THRES0_CHANNEL: u4,
            reserved0: u1,
            /// saradc thres0 monitor thres
            APB_SARADC_THRES0_HIGH: u13,
            /// saradc thres0 monitor thres
            APB_SARADC_THRES0_LOW: u13,
            padding0: u1,
        }), base_address + 0x34);

        /// address: 0x60040038
        /// digital saradc configure register
        pub const THRES1_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// configure thres1 to adc channel
            APB_SARADC_THRES1_CHANNEL: u4,
            reserved0: u1,
            /// saradc thres1 monitor thres
            APB_SARADC_THRES1_HIGH: u13,
            /// saradc thres1 monitor thres
            APB_SARADC_THRES1_LOW: u13,
            padding0: u1,
        }), base_address + 0x38);

        /// address: 0x6004003c
        /// digital saradc configure register
        pub const THRES_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            /// enable thres to all channel
            APB_SARADC_THRES_ALL_EN: u1,
            reserved27: u1,
            reserved28: u1,
            /// enable thres1
            APB_SARADC_THRES1_EN: u1,
            /// enable thres0
            APB_SARADC_THRES0_EN: u1,
        }), base_address + 0x3c);

        /// address: 0x60040040
        /// digital saradc int register
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// saradc thres1 low interrupt enable
            APB_SARADC_THRES1_LOW_INT_ENA: u1,
            /// saradc thres0 low interrupt enable
            APB_SARADC_THRES0_LOW_INT_ENA: u1,
            /// saradc thres1 high interrupt enable
            APB_SARADC_THRES1_HIGH_INT_ENA: u1,
            /// saradc thres0 high interrupt enable
            APB_SARADC_THRES0_HIGH_INT_ENA: u1,
            /// saradc2 done interrupt enable
            APB_SARADC2_DONE_INT_ENA: u1,
            /// saradc1 done interrupt enable
            APB_SARADC1_DONE_INT_ENA: u1,
        }), base_address + 0x40);

        /// address: 0x60040044
        /// digital saradc int register
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// saradc thres1 low interrupt raw
            APB_SARADC_THRES1_LOW_INT_RAW: u1,
            /// saradc thres0 low interrupt raw
            APB_SARADC_THRES0_LOW_INT_RAW: u1,
            /// saradc thres1 high interrupt raw
            APB_SARADC_THRES1_HIGH_INT_RAW: u1,
            /// saradc thres0 high interrupt raw
            APB_SARADC_THRES0_HIGH_INT_RAW: u1,
            /// saradc2 done interrupt raw
            APB_SARADC2_DONE_INT_RAW: u1,
            /// saradc1 done interrupt raw
            APB_SARADC1_DONE_INT_RAW: u1,
        }), base_address + 0x44);

        /// address: 0x60040048
        /// digital saradc int register
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// saradc thres1 low interrupt state
            APB_SARADC_THRES1_LOW_INT_ST: u1,
            /// saradc thres0 low interrupt state
            APB_SARADC_THRES0_LOW_INT_ST: u1,
            /// saradc thres1 high interrupt state
            APB_SARADC_THRES1_HIGH_INT_ST: u1,
            /// saradc thres0 high interrupt state
            APB_SARADC_THRES0_HIGH_INT_ST: u1,
            /// saradc2 done interrupt state
            APB_SARADC2_DONE_INT_ST: u1,
            /// saradc1 done interrupt state
            APB_SARADC1_DONE_INT_ST: u1,
        }), base_address + 0x48);

        /// address: 0x6004004c
        /// digital saradc int register
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// saradc thres1 low interrupt clear
            APB_SARADC_THRES1_LOW_INT_CLR: u1,
            /// saradc thres0 low interrupt clear
            APB_SARADC_THRES0_LOW_INT_CLR: u1,
            /// saradc thres1 high interrupt clear
            APB_SARADC_THRES1_HIGH_INT_CLR: u1,
            /// saradc thres0 high interrupt clear
            APB_SARADC_THRES0_HIGH_INT_CLR: u1,
            /// saradc2 done interrupt clear
            APB_SARADC2_DONE_INT_CLR: u1,
            /// saradc1 done interrupt clear
            APB_SARADC1_DONE_INT_CLR: u1,
        }), base_address + 0x4c);

        /// address: 0x60040050
        /// digital saradc configure register
        pub const DMA_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// the dma_in_suc_eof gen when sample cnt = spi_eof_num
            APB_ADC_EOF_NUM: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// reset_apb_adc_state
            APB_ADC_RESET_FSM: u1,
            /// enable apb_adc use spi_dma
            APB_ADC_TRANS: u1,
        }), base_address + 0x50);

        /// address: 0x60040054
        /// digital saradc configure register
        pub const CLKM_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integral I2S clock divider value
            CLKM_DIV_NUM: u8,
            /// Fractional clock divider numerator value
            CLKM_DIV_B: u6,
            /// Fractional clock divider denominator value
            CLKM_DIV_A: u6,
            /// reg clk en
            CLK_EN: u1,
            /// Set this bit to enable clk_apll
            CLK_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x54);

        /// address: 0x60040058
        /// digital tsens configure register
        pub const APB_TSENS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// temperature sensor data out
            TSENS_OUT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// invert temperature sensor data
            TSENS_IN_INV: u1,
            /// temperature sensor clock divider
            TSENS_CLK_DIV: u8,
            /// temperature sensor power up
            TSENS_PU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x58);

        /// address: 0x6004005c
        /// digital tsens configure register
        pub const TSENS_CTRL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// the time that power up tsens need wait
            TSENS_XPD_WAIT: u12,
            /// force power up tsens
            TSENS_XPD_FORCE: u2,
            /// inv tsens clk
            TSENS_CLK_INV: u1,
            /// tsens clk select
            TSENS_CLK_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x60040060
        /// digital saradc configure register
        pub const CALI = @intToPtr(*volatile Mmio(32, packed struct {
            /// saradc cali factor
            APB_SARADC_CALI_CFG: u17,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x60);

        /// address: 0x600403fc
        /// version
        pub const CTRL_DATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// version
            DATE: u32,
        }), base_address + 0x3fc);
    };

    /// Debug Assist
    pub const ASSIST_DEBUG = struct {
        pub const base_address = 0x600ce000;

        /// address: 0x600ce000
        /// ASSIST_DEBUG_C0RE_0_MONTR_ENA_REG
        pub const C0RE_0_MONTR_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_area_dram0_0_rd_ena
            CORE_0_AREA_DRAM0_0_RD_ENA: u1,
            /// reg_core_0_area_dram0_0_wr_ena
            CORE_0_AREA_DRAM0_0_WR_ENA: u1,
            /// reg_core_0_area_dram0_1_rd_ena
            CORE_0_AREA_DRAM0_1_RD_ENA: u1,
            /// reg_core_0_area_dram0_1_wr_ena
            CORE_0_AREA_DRAM0_1_WR_ENA: u1,
            /// reg_core_0_area_pif_0_rd_ena
            CORE_0_AREA_PIF_0_RD_ENA: u1,
            /// reg_core_0_area_pif_0_wr_ena
            CORE_0_AREA_PIF_0_WR_ENA: u1,
            /// reg_core_0_area_pif_1_rd_ena
            CORE_0_AREA_PIF_1_RD_ENA: u1,
            /// reg_core_0_area_pif_1_wr_ena
            CORE_0_AREA_PIF_1_WR_ENA: u1,
            /// reg_core_0_sp_spill_min_ena
            CORE_0_SP_SPILL_MIN_ENA: u1,
            /// reg_core_0_sp_spill_max_ena
            CORE_0_SP_SPILL_MAX_ENA: u1,
            /// reg_core_0_iram0_exception_monitor_ena
            CORE_0_IRAM0_EXCEPTION_MONITOR_ENA: u1,
            /// reg_core_0_dram0_exception_monitor_ena
            CORE_0_DRAM0_EXCEPTION_MONITOR_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x600ce004
        /// ASSIST_DEBUG_CORE_0_INTR_RAW_REG
        pub const CORE_0_INTR_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_area_dram0_0_rd_raw
            CORE_0_AREA_DRAM0_0_RD_RAW: u1,
            /// reg_core_0_area_dram0_0_wr_raw
            CORE_0_AREA_DRAM0_0_WR_RAW: u1,
            /// reg_core_0_area_dram0_1_rd_raw
            CORE_0_AREA_DRAM0_1_RD_RAW: u1,
            /// reg_core_0_area_dram0_1_wr_raw
            CORE_0_AREA_DRAM0_1_WR_RAW: u1,
            /// reg_core_0_area_pif_0_rd_raw
            CORE_0_AREA_PIF_0_RD_RAW: u1,
            /// reg_core_0_area_pif_0_wr_raw
            CORE_0_AREA_PIF_0_WR_RAW: u1,
            /// reg_core_0_area_pif_1_rd_raw
            CORE_0_AREA_PIF_1_RD_RAW: u1,
            /// reg_core_0_area_pif_1_wr_raw
            CORE_0_AREA_PIF_1_WR_RAW: u1,
            /// reg_core_0_sp_spill_min_raw
            CORE_0_SP_SPILL_MIN_RAW: u1,
            /// reg_core_0_sp_spill_max_raw
            CORE_0_SP_SPILL_MAX_RAW: u1,
            /// reg_core_0_iram0_exception_monitor_raw
            CORE_0_IRAM0_EXCEPTION_MONITOR_RAW: u1,
            /// reg_core_0_dram0_exception_monitor_raw
            CORE_0_DRAM0_EXCEPTION_MONITOR_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x600ce008
        /// ASSIST_DEBUG_CORE_0_INTR_ENA_REG
        pub const CORE_0_INTR_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_area_dram0_0_rd_intr_ena
            CORE_0_AREA_DRAM0_0_RD_INTR_ENA: u1,
            /// reg_core_0_area_dram0_0_wr_intr_ena
            CORE_0_AREA_DRAM0_0_WR_INTR_ENA: u1,
            /// reg_core_0_area_dram0_1_rd_intr_ena
            CORE_0_AREA_DRAM0_1_RD_INTR_ENA: u1,
            /// reg_core_0_area_dram0_1_wr_intr_ena
            CORE_0_AREA_DRAM0_1_WR_INTR_ENA: u1,
            /// reg_core_0_area_pif_0_rd_intr_ena
            CORE_0_AREA_PIF_0_RD_INTR_ENA: u1,
            /// reg_core_0_area_pif_0_wr_intr_ena
            CORE_0_AREA_PIF_0_WR_INTR_ENA: u1,
            /// reg_core_0_area_pif_1_rd_intr_ena
            CORE_0_AREA_PIF_1_RD_INTR_ENA: u1,
            /// reg_core_0_area_pif_1_wr_intr_ena
            CORE_0_AREA_PIF_1_WR_INTR_ENA: u1,
            /// reg_core_0_sp_spill_min_intr_ena
            CORE_0_SP_SPILL_MIN_INTR_ENA: u1,
            /// reg_core_0_sp_spill_max_intr_ena
            CORE_0_SP_SPILL_MAX_INTR_ENA: u1,
            /// reg_core_0_iram0_exception_monitor_ena
            CORE_0_IRAM0_EXCEPTION_MONITOR_RLS: u1,
            /// reg_core_0_dram0_exception_monitor_ena
            CORE_0_DRAM0_EXCEPTION_MONITOR_RLS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x600ce00c
        /// ASSIST_DEBUG_CORE_0_INTR_CLR_REG
        pub const CORE_0_INTR_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_area_dram0_0_rd_clr
            CORE_0_AREA_DRAM0_0_RD_CLR: u1,
            /// reg_core_0_area_dram0_0_wr_clr
            CORE_0_AREA_DRAM0_0_WR_CLR: u1,
            /// reg_core_0_area_dram0_1_rd_clr
            CORE_0_AREA_DRAM0_1_RD_CLR: u1,
            /// reg_core_0_area_dram0_1_wr_clr
            CORE_0_AREA_DRAM0_1_WR_CLR: u1,
            /// reg_core_0_area_pif_0_rd_clr
            CORE_0_AREA_PIF_0_RD_CLR: u1,
            /// reg_core_0_area_pif_0_wr_clr
            CORE_0_AREA_PIF_0_WR_CLR: u1,
            /// reg_core_0_area_pif_1_rd_clr
            CORE_0_AREA_PIF_1_RD_CLR: u1,
            /// reg_core_0_area_pif_1_wr_clr
            CORE_0_AREA_PIF_1_WR_CLR: u1,
            /// reg_core_0_sp_spill_min_clr
            CORE_0_SP_SPILL_MIN_CLR: u1,
            /// reg_core_0_sp_spill_max_clr
            CORE_0_SP_SPILL_MAX_CLR: u1,
            /// reg_core_0_iram0_exception_monitor_clr
            CORE_0_IRAM0_EXCEPTION_MONITOR_CLR: u1,
            /// reg_core_0_dram0_exception_monitor_clr
            CORE_0_DRAM0_EXCEPTION_MONITOR_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xc);

        /// address: 0x600ce010
        /// ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MIN_REG
        pub const CORE_0_AREA_DRAM0_0_MIN = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x600ce014
        /// ASSIST_DEBUG_CORE_0_AREA_DRAM0_0_MAX_REG
        pub const CORE_0_AREA_DRAM0_0_MAX = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x600ce018
        /// ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MIN_REG
        pub const CORE_0_AREA_DRAM0_1_MIN = @intToPtr(*volatile u32, base_address + 0x18);

        /// address: 0x600ce01c
        /// ASSIST_DEBUG_CORE_0_AREA_DRAM0_1_MAX_REG
        pub const CORE_0_AREA_DRAM0_1_MAX = @intToPtr(*volatile u32, base_address + 0x1c);

        /// address: 0x600ce020
        /// ASSIST_DEBUG_CORE_0_AREA_PIF_0_MIN_REG
        pub const CORE_0_AREA_PIF_0_MIN = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x600ce024
        /// ASSIST_DEBUG_CORE_0_AREA_PIF_0_MAX_REG
        pub const CORE_0_AREA_PIF_0_MAX = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x600ce028
        /// ASSIST_DEBUG_CORE_0_AREA_PIF_1_MIN_REG
        pub const CORE_0_AREA_PIF_1_MIN = @intToPtr(*volatile u32, base_address + 0x28);

        /// address: 0x600ce02c
        /// ASSIST_DEBUG_CORE_0_AREA_PIF_1_MAX_REG
        pub const CORE_0_AREA_PIF_1_MAX = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x600ce030
        /// ASSIST_DEBUG_CORE_0_AREA_PC_REG
        pub const CORE_0_AREA_PC = @intToPtr(*volatile u32, base_address + 0x30);

        /// address: 0x600ce034
        /// ASSIST_DEBUG_CORE_0_AREA_SP_REG
        pub const CORE_0_AREA_SP = @intToPtr(*volatile u32, base_address + 0x34);

        /// address: 0x600ce038
        /// ASSIST_DEBUG_CORE_0_SP_MIN_REG
        pub const CORE_0_SP_MIN = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0x600ce03c
        /// ASSIST_DEBUG_CORE_0_SP_MAX_REG
        pub const CORE_0_SP_MAX = @intToPtr(*volatile u32, base_address + 0x3c);

        /// address: 0x600ce040
        /// ASSIST_DEBUG_CORE_0_SP_PC_REG
        pub const CORE_0_SP_PC = @intToPtr(*volatile u32, base_address + 0x40);

        /// address: 0x600ce044
        /// ASSIST_DEBUG_CORE_0_RCD_EN_REG
        pub const CORE_0_RCD_EN = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_rcd_recorden
            CORE_0_RCD_RECORDEN: u1,
            /// reg_core_0_rcd_pdebugen
            CORE_0_RCD_PDEBUGEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x44);

        /// address: 0x600ce048
        /// ASSIST_DEBUG_CORE_0_RCD_PDEBUGPC_REG
        pub const CORE_0_RCD_PDEBUGPC = @intToPtr(*volatile u32, base_address + 0x48);

        /// address: 0x600ce04c
        /// ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP_REG
        pub const CORE_0_RCD_PDEBUGSP = @intToPtr(*volatile u32, base_address + 0x4c);

        /// address: 0x600ce050
        /// ASSIST_DEBUG_CORE_0_RCD_PDEBUGSP_REG
        pub const CORE_0_IRAM0_EXCEPTION_MONITOR_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_iram0_recording_addr_0
            CORE_0_IRAM0_RECORDING_ADDR_0: u24,
            /// reg_core_0_iram0_recording_wr_0
            CORE_0_IRAM0_RECORDING_WR_0: u1,
            /// reg_core_0_iram0_recording_loadstore_0
            CORE_0_IRAM0_RECORDING_LOADSTORE_0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x50);

        /// address: 0x600ce054
        /// ASSIST_DEBUG_CORE_0_IRAM0_EXCEPTION_MONITOR_1_REG
        pub const CORE_0_IRAM0_EXCEPTION_MONITOR_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_iram0_recording_addr_1
            CORE_0_IRAM0_RECORDING_ADDR_1: u24,
            /// reg_core_0_iram0_recording_wr_1
            CORE_0_IRAM0_RECORDING_WR_1: u1,
            /// reg_core_0_iram0_recording_loadstore_1
            CORE_0_IRAM0_RECORDING_LOADSTORE_1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x54);

        /// address: 0x600ce058
        /// ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_0_REG
        pub const CORE_0_DRAM0_EXCEPTION_MONITOR_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_dram0_recording_addr_0
            CORE_0_DRAM0_RECORDING_ADDR_0: u24,
            /// reg_core_0_dram0_recording_wr_0
            CORE_0_DRAM0_RECORDING_WR_0: u1,
            /// reg_core_0_dram0_recording_byteen_0
            CORE_0_DRAM0_RECORDING_BYTEEN_0: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x58);

        /// address: 0x600ce05c
        /// ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_1_REG
        pub const CORE_0_DRAM0_EXCEPTION_MONITOR_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_dram0_recording_pc_0
            CORE_0_DRAM0_RECORDING_PC_0: u32,
        }), base_address + 0x5c);

        /// address: 0x600ce060
        /// ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_1_REG
        pub const CORE_0_DRAM0_EXCEPTION_MONITOR_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_dram0_recording_addr_1
            CORE_0_DRAM0_RECORDING_ADDR_1: u24,
            /// reg_core_0_dram0_recording_wr_1
            CORE_0_DRAM0_RECORDING_WR_1: u1,
            /// reg_core_0_dram0_recording_byteen_1
            CORE_0_DRAM0_RECORDING_BYTEEN_1: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x60);

        /// address: 0x600ce064
        /// ASSIST_DEBUG_CORE_0_DRAM0_EXCEPTION_MONITOR_3_REG
        pub const CORE_0_DRAM0_EXCEPTION_MONITOR_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_dram0_recording_pc_1
            CORE_0_DRAM0_RECORDING_PC_1: u32,
        }), base_address + 0x64);

        /// address: 0x600ce068
        /// ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0_REG
        pub const CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_x_iram0_dram0_limit_cycle_0
            CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x68);

        /// address: 0x600ce06c
        /// ASSIST_DEBUG_CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1_REG
        pub const CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_x_iram0_dram0_limit_cycle_1
            CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x6c);

        /// address: 0x600ce070
        /// ASSIST_DEBUG_LOG_SETTING
        pub const LOG_SETTING = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_log_ena
            LOG_ENA: u3,
            /// reg_log_mode
            LOG_MODE: u4,
            /// reg_log_mem_loop_enable
            LOG_MEM_LOOP_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x70);

        /// address: 0x600ce074
        /// ASSIST_DEBUG_LOG_DATA_0_REG
        pub const LOG_DATA_0 = @intToPtr(*volatile u32, base_address + 0x74);

        /// address: 0x600ce078
        /// ASSIST_DEBUG_LOG_DATA_MASK_REG
        pub const LOG_DATA_MASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_log_data_size
            LOG_DATA_SIZE: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x78);

        /// address: 0x600ce07c
        /// ASSIST_DEBUG_LOG_MIN_REG
        pub const LOG_MIN = @intToPtr(*volatile u32, base_address + 0x7c);

        /// address: 0x600ce080
        /// ASSIST_DEBUG_LOG_MAX_REG
        pub const LOG_MAX = @intToPtr(*volatile u32, base_address + 0x80);

        /// address: 0x600ce084
        /// ASSIST_DEBUG_LOG_MEM_START_REG
        pub const LOG_MEM_START = @intToPtr(*volatile u32, base_address + 0x84);

        /// address: 0x600ce088
        /// ASSIST_DEBUG_LOG_MEM_END_REG
        pub const LOG_MEM_END = @intToPtr(*volatile u32, base_address + 0x88);

        /// address: 0x600ce08c
        /// ASSIST_DEBUG_LOG_MEM_WRITING_ADDR_REG
        pub const LOG_MEM_WRITING_ADDR = @intToPtr(*volatile u32, base_address + 0x8c);

        /// address: 0x600ce090
        /// ASSIST_DEBUG_LOG_MEM_FULL_FLAG_REG
        pub const LOG_MEM_FULL_FLAG = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_log_mem_full_flag
            LOG_MEM_FULL_FLAG: u1,
            /// reg_clr_log_mem_full_flag
            CLR_LOG_MEM_FULL_FLAG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x90);

        /// address: 0x600ce094
        /// ASSIST_DEBUG_C0RE_0_LASTPC_BEFORE_EXCEPTION
        pub const C0RE_0_LASTPC_BEFORE_EXCEPTION = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_lastpc_before_exc
            CORE_0_LASTPC_BEFORE_EXC: u32,
        }), base_address + 0x94);

        /// address: 0x600ce098
        /// ASSIST_DEBUG_C0RE_0_DEBUG_MODE
        pub const C0RE_0_DEBUG_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core_0_debug_mode
            CORE_0_DEBUG_MODE: u1,
            /// reg_core_0_debug_module_active
            CORE_0_DEBUG_MODULE_ACTIVE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x98);

        /// address: 0x600ce1fc
        /// ASSIST_DEBUG_DATE_REG
        pub const DATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_assist_debug_date
            ASSIST_DEBUG_DATE: u28,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x1fc);
    };

    /// DMA (Direct Memory Access) Controller
    pub const DMA = struct {
        pub const base_address = 0x6003f000;

        /// address: 0x6003f000
        /// DMA_INT_RAW_CH0_REG.
        pub const INT_RAW_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// inlink descriptor has been received for Rx channel 0.
            IN_DONE_CH0_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// inlink descriptor has been received for Rx channel 0. For UHCI0, the raw
            /// interrupt bit turns to high level when the last data pointed by one inlink
            /// descriptor has been received and no data error is detected for Rx channel 0.
            IN_SUC_EOF_CH0_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when data error is detected only in
            /// the case that the peripheral is UHCI0 for Rx channel 0. For other peripherals,
            /// this raw interrupt is reserved.
            IN_ERR_EOF_CH0_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// outlink descriptor has been transmitted to peripherals for Tx channel 0.
            OUT_DONE_CH0_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// outlink descriptor has been read from memory for Tx channel 0.
            OUT_EOF_CH0_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when detecting inlink descriptor
            /// error, including owner error, the second and third word error of inlink
            /// descriptor for Rx channel 0.
            IN_DSCR_ERR_CH0_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when detecting outlink descriptor
            /// error, including owner error, the second and third word error of outlink
            /// descriptor for Tx channel 0.
            OUT_DSCR_ERR_CH0_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when Rx buffer pointed by inlink is
            /// full and receiving data is not completed, but there is no more inlink for Rx
            /// channel 0.
            IN_DSCR_EMPTY_CH0_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when data corresponding a outlink
            /// (includes one link descriptor or few link descriptors) is transmitted out for Tx
            /// channel 0.
            OUT_TOTAL_EOF_CH0_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is
            /// overflow.
            INFIFO_OVF_CH0_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Rx channel 0 is
            /// underflow.
            INFIFO_UDF_CH0_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is
            /// overflow.
            OUTFIFO_OVF_CH0_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Tx channel 0 is
            /// underflow.
            OUTFIFO_UDF_CH0_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x6003f004
        /// DMA_INT_ST_CH0_REG.
        pub const INT_ST_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
            IN_DONE_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
            IN_SUC_EOF_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
            IN_ERR_EOF_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
            OUT_DONE_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
            OUT_EOF_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
            IN_DSCR_ERR_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
            OUT_DSCR_ERR_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
            IN_DSCR_EMPTY_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
            OUT_TOTAL_EOF_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
            INFIFO_OVF_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
            INFIFO_UDF_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
            OUTFIFO_OVF_CH0_INT_ST: u1,
            /// The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
            OUTFIFO_UDF_CH0_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x4);

        /// address: 0x6003f008
        /// DMA_INT_ENA_CH0_REG.
        pub const INT_ENA_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The interrupt enable bit for the IN_DONE_CH_INT interrupt.
            IN_DONE_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
            IN_SUC_EOF_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
            IN_ERR_EOF_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
            OUT_DONE_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
            OUT_EOF_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
            IN_DSCR_ERR_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
            OUT_DSCR_ERR_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
            IN_DSCR_EMPTY_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
            OUT_TOTAL_EOF_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
            INFIFO_OVF_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
            INFIFO_UDF_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
            OUTFIFO_OVF_CH0_INT_ENA: u1,
            /// The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
            OUTFIFO_UDF_CH0_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x6003f00c
        /// DMA_INT_CLR_CH0_REG.
        pub const INT_CLR_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to clear the IN_DONE_CH_INT interrupt.
            IN_DONE_CH0_INT_CLR: u1,
            /// Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
            IN_SUC_EOF_CH0_INT_CLR: u1,
            /// Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
            IN_ERR_EOF_CH0_INT_CLR: u1,
            /// Set this bit to clear the OUT_DONE_CH_INT interrupt.
            OUT_DONE_CH0_INT_CLR: u1,
            /// Set this bit to clear the OUT_EOF_CH_INT interrupt.
            OUT_EOF_CH0_INT_CLR: u1,
            /// Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
            IN_DSCR_ERR_CH0_INT_CLR: u1,
            /// Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
            OUT_DSCR_ERR_CH0_INT_CLR: u1,
            /// Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
            IN_DSCR_EMPTY_CH0_INT_CLR: u1,
            /// Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
            OUT_TOTAL_EOF_CH0_INT_CLR: u1,
            /// Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
            INFIFO_OVF_CH0_INT_CLR: u1,
            /// Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
            INFIFO_UDF_CH0_INT_CLR: u1,
            /// Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
            OUTFIFO_OVF_CH0_INT_CLR: u1,
            /// Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
            OUTFIFO_UDF_CH0_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0xc);

        /// address: 0x6003f010
        /// DMA_INT_RAW_CH1_REG.
        pub const INT_RAW_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// inlink descriptor has been received for Rx channel 1.
            IN_DONE_CH1_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// inlink descriptor has been received for Rx channel 1. For UHCI0, the raw
            /// interrupt bit turns to high level when the last data pointed by one inlink
            /// descriptor has been received and no data error is detected for Rx channel 1.
            IN_SUC_EOF_CH1_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when data error is detected only in
            /// the case that the peripheral is UHCI0 for Rx channel 1. For other peripherals,
            /// this raw interrupt is reserved.
            IN_ERR_EOF_CH1_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// outlink descriptor has been transmitted to peripherals for Tx channel 1.
            OUT_DONE_CH1_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// outlink descriptor has been read from memory for Tx channel 1.
            OUT_EOF_CH1_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when detecting inlink descriptor
            /// error, including owner error, the second and third word error of inlink
            /// descriptor for Rx channel 1.
            IN_DSCR_ERR_CH1_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when detecting outlink descriptor
            /// error, including owner error, the second and third word error of outlink
            /// descriptor for Tx channel 1.
            OUT_DSCR_ERR_CH1_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when Rx buffer pointed by inlink is
            /// full and receiving data is not completed, but there is no more inlink for Rx
            /// channel 1.
            IN_DSCR_EMPTY_CH1_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when data corresponding a outlink
            /// (includes one link descriptor or few link descriptors) is transmitted out for Tx
            /// channel 1.
            OUT_TOTAL_EOF_CH1_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Rx channel 1 is
            /// overflow.
            INFIFO_OVF_CH1_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Rx channel 1 is
            /// underflow.
            INFIFO_UDF_CH1_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Tx channel 1 is
            /// overflow.
            OUTFIFO_OVF_CH1_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Tx channel 1 is
            /// underflow.
            OUTFIFO_UDF_CH1_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x6003f014
        /// DMA_INT_ST_CH1_REG.
        pub const INT_ST_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
            IN_DONE_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
            IN_SUC_EOF_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
            IN_ERR_EOF_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
            OUT_DONE_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
            OUT_EOF_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
            IN_DSCR_ERR_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
            OUT_DSCR_ERR_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
            IN_DSCR_EMPTY_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
            OUT_TOTAL_EOF_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
            INFIFO_OVF_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
            INFIFO_UDF_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
            OUTFIFO_OVF_CH1_INT_ST: u1,
            /// The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
            OUTFIFO_UDF_CH1_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x14);

        /// address: 0x6003f018
        /// DMA_INT_ENA_CH1_REG.
        pub const INT_ENA_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The interrupt enable bit for the IN_DONE_CH_INT interrupt.
            IN_DONE_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
            IN_SUC_EOF_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
            IN_ERR_EOF_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
            OUT_DONE_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
            OUT_EOF_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
            IN_DSCR_ERR_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
            OUT_DSCR_ERR_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
            IN_DSCR_EMPTY_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
            OUT_TOTAL_EOF_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
            INFIFO_OVF_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
            INFIFO_UDF_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
            OUTFIFO_OVF_CH1_INT_ENA: u1,
            /// The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
            OUTFIFO_UDF_CH1_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x18);

        /// address: 0x6003f01c
        /// DMA_INT_CLR_CH1_REG.
        pub const INT_CLR_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to clear the IN_DONE_CH_INT interrupt.
            IN_DONE_CH1_INT_CLR: u1,
            /// Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
            IN_SUC_EOF_CH1_INT_CLR: u1,
            /// Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
            IN_ERR_EOF_CH1_INT_CLR: u1,
            /// Set this bit to clear the OUT_DONE_CH_INT interrupt.
            OUT_DONE_CH1_INT_CLR: u1,
            /// Set this bit to clear the OUT_EOF_CH_INT interrupt.
            OUT_EOF_CH1_INT_CLR: u1,
            /// Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
            IN_DSCR_ERR_CH1_INT_CLR: u1,
            /// Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
            OUT_DSCR_ERR_CH1_INT_CLR: u1,
            /// Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
            IN_DSCR_EMPTY_CH1_INT_CLR: u1,
            /// Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
            OUT_TOTAL_EOF_CH1_INT_CLR: u1,
            /// Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
            INFIFO_OVF_CH1_INT_CLR: u1,
            /// Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
            INFIFO_UDF_CH1_INT_CLR: u1,
            /// Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
            OUTFIFO_OVF_CH1_INT_CLR: u1,
            /// Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
            OUTFIFO_UDF_CH1_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x1c);

        /// address: 0x6003f020
        /// DMA_INT_RAW_CH2_REG.
        pub const INT_RAW_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// inlink descriptor has been received for Rx channel 2.
            IN_DONE_CH2_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// inlink descriptor has been received for Rx channel 2. For UHCI0, the raw
            /// interrupt bit turns to high level when the last data pointed by one inlink
            /// descriptor has been received and no data error is detected for Rx channel 2.
            IN_SUC_EOF_CH2_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when data error is detected only in
            /// the case that the peripheral is UHCI0 for Rx channel 2. For other peripherals,
            /// this raw interrupt is reserved.
            IN_ERR_EOF_CH2_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// outlink descriptor has been transmitted to peripherals for Tx channel 2.
            OUT_DONE_CH2_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when the last data pointed by one
            /// outlink descriptor has been read from memory for Tx channel 2.
            OUT_EOF_CH2_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when detecting inlink descriptor
            /// error, including owner error, the second and third word error of inlink
            /// descriptor for Rx channel 2.
            IN_DSCR_ERR_CH2_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when detecting outlink descriptor
            /// error, including owner error, the second and third word error of outlink
            /// descriptor for Tx channel 2.
            OUT_DSCR_ERR_CH2_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when Rx buffer pointed by inlink is
            /// full and receiving data is not completed, but there is no more inlink for Rx
            /// channel 2.
            IN_DSCR_EMPTY_CH2_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when data corresponding a outlink
            /// (includes one link descriptor or few link descriptors) is transmitted out for Tx
            /// channel 2.
            OUT_TOTAL_EOF_CH2_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Rx channel 2 is
            /// overflow.
            INFIFO_OVF_CH2_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Rx channel 2 is
            /// underflow.
            INFIFO_UDF_CH2_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Tx channel 2 is
            /// overflow.
            OUTFIFO_OVF_CH2_INT_RAW: u1,
            /// This raw interrupt bit turns to high level when level 1 fifo of Tx channel 2 is
            /// underflow.
            OUTFIFO_UDF_CH2_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x20);

        /// address: 0x6003f024
        /// DMA_INT_ST_CH2_REG.
        pub const INT_ST_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw interrupt status bit for the IN_DONE_CH_INT interrupt.
            IN_DONE_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.
            IN_SUC_EOF_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.
            IN_ERR_EOF_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.
            OUT_DONE_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.
            OUT_EOF_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.
            IN_DSCR_ERR_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.
            OUT_DSCR_ERR_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.
            IN_DSCR_EMPTY_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.
            OUT_TOTAL_EOF_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.
            INFIFO_OVF_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.
            INFIFO_UDF_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
            OUTFIFO_OVF_CH2_INT_ST: u1,
            /// The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
            OUTFIFO_UDF_CH2_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x24);

        /// address: 0x6003f028
        /// DMA_INT_ENA_CH2_REG.
        pub const INT_ENA_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The interrupt enable bit for the IN_DONE_CH_INT interrupt.
            IN_DONE_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.
            IN_SUC_EOF_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.
            IN_ERR_EOF_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_DONE_CH_INT interrupt.
            OUT_DONE_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_EOF_CH_INT interrupt.
            OUT_EOF_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.
            IN_DSCR_ERR_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.
            OUT_DSCR_ERR_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.
            IN_DSCR_EMPTY_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.
            OUT_TOTAL_EOF_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.
            INFIFO_OVF_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.
            INFIFO_UDF_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.
            OUTFIFO_OVF_CH2_INT_ENA: u1,
            /// The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.
            OUTFIFO_UDF_CH2_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x28);

        /// address: 0x6003f02c
        /// DMA_INT_CLR_CH2_REG.
        pub const INT_CLR_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to clear the IN_DONE_CH_INT interrupt.
            IN_DONE_CH2_INT_CLR: u1,
            /// Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.
            IN_SUC_EOF_CH2_INT_CLR: u1,
            /// Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.
            IN_ERR_EOF_CH2_INT_CLR: u1,
            /// Set this bit to clear the OUT_DONE_CH_INT interrupt.
            OUT_DONE_CH2_INT_CLR: u1,
            /// Set this bit to clear the OUT_EOF_CH_INT interrupt.
            OUT_EOF_CH2_INT_CLR: u1,
            /// Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.
            IN_DSCR_ERR_CH2_INT_CLR: u1,
            /// Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.
            OUT_DSCR_ERR_CH2_INT_CLR: u1,
            /// Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.
            IN_DSCR_EMPTY_CH2_INT_CLR: u1,
            /// Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.
            OUT_TOTAL_EOF_CH2_INT_CLR: u1,
            /// Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.
            INFIFO_OVF_CH2_INT_CLR: u1,
            /// Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.
            INFIFO_UDF_CH2_INT_CLR: u1,
            /// Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.
            OUTFIFO_OVF_CH2_INT_CLR: u1,
            /// Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.
            OUTFIFO_UDF_CH2_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x2c);

        /// address: 0x6003f040
        /// DMA_AHB_TEST_REG.
        pub const AHB_TEST = @intToPtr(*volatile Mmio(32, packed struct {
            /// reserved
            AHB_TESTMODE: u3,
            reserved0: u1,
            /// reserved
            AHB_TESTADDR: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x40);

        /// address: 0x6003f044
        /// DMA_MISC_CONF_REG.
        pub const MISC_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit, then clear this bit to reset the internal ahb FSM.
            AHBM_RST_INTER: u1,
            reserved0: u1,
            /// Set this bit to disable priority arbitration function.
            ARB_PRI_DIS: u1,
            /// reg_clk_en
            CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x44);

        /// address: 0x6003f048
        /// DMA_DATE_REG.
        pub const DATE = @intToPtr(*volatile u32, base_address + 0x48);

        /// address: 0x6003f070
        /// DMA_IN_CONF0_CH0_REG.
        pub const IN_CONF0_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.
            IN_RST_CH0: u1,
            /// reserved
            IN_LOOP_TEST_CH0: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Rx channel 0 reading link
            /// descriptor when accessing internal SRAM.
            INDSCR_BURST_EN_CH0: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Rx channel 0 receiving data
            /// when accessing internal SRAM.
            IN_DATA_BURST_EN_CH0: u1,
            /// Set this bit 1 to enable automatic transmitting data from memory to memory via
            /// DMA.
            MEM_TRANS_EN_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x70);

        /// address: 0x6003f074
        /// DMA_IN_CONF1_CH0_REG.
        pub const IN_CONF1_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Set this bit to enable checking the owner attribute of the link descriptor.
            IN_CHECK_OWNER_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x74);

        /// address: 0x6003f078
        /// DMA_INFIFO_STATUS_CH0_REG.
        pub const INFIFO_STATUS_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L1 Rx FIFO full signal for Rx channel 0.
            INFIFO_FULL_CH0: u1,
            /// L1 Rx FIFO empty signal for Rx channel 0.
            INFIFO_EMPTY_CH0: u1,
            /// The register stores the byte number of the data in L1 Rx FIFO for Rx channel 0.
            INFIFO_CNT_CH0: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// reserved
            IN_REMAIN_UNDER_1B_CH0: u1,
            /// reserved
            IN_REMAIN_UNDER_2B_CH0: u1,
            /// reserved
            IN_REMAIN_UNDER_3B_CH0: u1,
            /// reserved
            IN_REMAIN_UNDER_4B_CH0: u1,
            /// reserved
            IN_BUF_HUNGRY_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x78);

        /// address: 0x6003f07c
        /// DMA_IN_POP_CH0_REG.
        pub const IN_POP_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the data popping from DMA FIFO.
            INFIFO_RDATA_CH0: u12,
            /// Set this bit to pop data from DMA FIFO.
            INFIFO_POP_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x7c);

        /// address: 0x6003f080
        /// DMA_IN_LINK_CH0_REG.
        pub const IN_LINK_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the 20 least significant bits of the first inlink
            /// descriptor's address.
            INLINK_ADDR_CH0: u20,
            /// Set this bit to return to current inlink descriptor's address, when there are
            /// some errors in current receiving data.
            INLINK_AUTO_RET_CH0: u1,
            /// Set this bit to stop dealing with the inlink descriptors.
            INLINK_STOP_CH0: u1,
            /// Set this bit to start dealing with the inlink descriptors.
            INLINK_START_CH0: u1,
            /// Set this bit to mount a new inlink descriptor.
            INLINK_RESTART_CH0: u1,
            /// 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM
            /// is working.
            INLINK_PARK_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x80);

        /// address: 0x6003f084
        /// DMA_IN_STATE_CH0_REG.
        pub const IN_STATE_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the current inlink descriptor's address.
            INLINK_DSCR_ADDR_CH0: u18,
            /// reserved
            IN_DSCR_STATE_CH0: u2,
            /// reserved
            IN_STATE_CH0: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x84);

        /// address: 0x6003f088
        /// DMA_IN_SUC_EOF_DES_ADDR_CH0_REG.
        pub const IN_SUC_EOF_DES_ADDR_CH0 = @intToPtr(*volatile u32, base_address + 0x88);

        /// address: 0x6003f08c
        /// DMA_IN_ERR_EOF_DES_ADDR_CH0_REG.
        pub const IN_ERR_EOF_DES_ADDR_CH0 = @intToPtr(*volatile u32, base_address + 0x8c);

        /// address: 0x6003f090
        /// DMA_IN_DSCR_CH0_REG.
        pub const IN_DSCR_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the current inlink descriptor x.
            INLINK_DSCR_CH0: u32,
        }), base_address + 0x90);

        /// address: 0x6003f094
        /// DMA_IN_DSCR_BF0_CH0_REG.
        pub const IN_DSCR_BF0_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the last inlink descriptor x-1.
            INLINK_DSCR_BF0_CH0: u32,
        }), base_address + 0x94);

        /// address: 0x6003f098
        /// DMA_IN_DSCR_BF1_CH0_REG.
        pub const IN_DSCR_BF1_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the second-to-last inlink descriptor x-2.
            INLINK_DSCR_BF1_CH0: u32,
        }), base_address + 0x98);

        /// address: 0x6003f09c
        /// DMA_IN_PRI_CH0_REG.
        pub const IN_PRI_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The priority of Rx channel 0. The larger of the value, the higher of the
            /// priority.
            RX_PRI_CH0: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x9c);

        /// address: 0x6003f0a0
        /// DMA_IN_PERI_SEL_CH0_REG.
        pub const IN_PERI_SEL_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to select peripheral for Rx channel 0. 0:SPI2. 1:
            /// reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8:
            /// ADC_DAC.
            PERI_IN_SEL_CH0: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xa0);

        /// address: 0x6003f0d0
        /// DMA_OUT_CONF0_CH0_REG.
        pub const OUT_CONF0_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is used to reset DMA channel 0 Tx FSM and Tx FIFO pointer.
            OUT_RST_CH0: u1,
            /// reserved
            OUT_LOOP_TEST_CH0: u1,
            /// Set this bit to enable automatic outlink-writeback when all the data in tx
            /// buffer has been transmitted.
            OUT_AUTO_WRBACK_CH0: u1,
            /// EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 0 is
            /// generated when data need to transmit has been popped from FIFO in DMA
            OUT_EOF_MODE_CH0: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Tx channel 0 reading link
            /// descriptor when accessing internal SRAM.
            OUTDSCR_BURST_EN_CH0: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Tx channel 0 transmitting
            /// data when accessing internal SRAM.
            OUT_DATA_BURST_EN_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xd0);

        /// address: 0x6003f0d4
        /// DMA_OUT_CONF1_CH0_REG.
        pub const OUT_CONF1_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Set this bit to enable checking the owner attribute of the link descriptor.
            OUT_CHECK_OWNER_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0xd4);

        /// address: 0x6003f0d8
        /// DMA_OUTFIFO_STATUS_CH0_REG.
        pub const OUTFIFO_STATUS_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L1 Tx FIFO full signal for Tx channel 0.
            OUTFIFO_FULL_CH0: u1,
            /// L1 Tx FIFO empty signal for Tx channel 0.
            OUTFIFO_EMPTY_CH0: u1,
            /// The register stores the byte number of the data in L1 Tx FIFO for Tx channel 0.
            OUTFIFO_CNT_CH0: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// reserved
            OUT_REMAIN_UNDER_1B_CH0: u1,
            /// reserved
            OUT_REMAIN_UNDER_2B_CH0: u1,
            /// reserved
            OUT_REMAIN_UNDER_3B_CH0: u1,
            /// reserved
            OUT_REMAIN_UNDER_4B_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0xd8);

        /// address: 0x6003f0dc
        /// DMA_OUT_PUSH_CH0_REG.
        pub const OUT_PUSH_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the data that need to be pushed into DMA FIFO.
            OUTFIFO_WDATA_CH0: u9,
            /// Set this bit to push data into DMA FIFO.
            OUTFIFO_PUSH_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0xdc);

        /// address: 0x6003f0e0
        /// DMA_OUT_LINK_CH0_REG.
        pub const OUT_LINK_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the 20 least significant bits of the first outlink
            /// descriptor's address.
            OUTLINK_ADDR_CH0: u20,
            /// Set this bit to stop dealing with the outlink descriptors.
            OUTLINK_STOP_CH0: u1,
            /// Set this bit to start dealing with the outlink descriptors.
            OUTLINK_START_CH0: u1,
            /// Set this bit to restart a new outlink from the last address.
            OUTLINK_RESTART_CH0: u1,
            /// 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's
            /// FSM is working.
            OUTLINK_PARK_CH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xe0);

        /// address: 0x6003f0e4
        /// DMA_OUT_STATE_CH0_REG.
        pub const OUT_STATE_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the current outlink descriptor's address.
            OUTLINK_DSCR_ADDR_CH0: u18,
            /// reserved
            OUT_DSCR_STATE_CH0: u2,
            /// reserved
            OUT_STATE_CH0: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xe4);

        /// address: 0x6003f0e8
        /// DMA_OUT_EOF_DES_ADDR_CH0_REG.
        pub const OUT_EOF_DES_ADDR_CH0 = @intToPtr(*volatile u32, base_address + 0xe8);

        /// address: 0x6003f0ec
        /// DMA_OUT_EOF_BFR_DES_ADDR_CH0_REG.
        pub const OUT_EOF_BFR_DES_ADDR_CH0 = @intToPtr(*volatile u32, base_address + 0xec);

        /// address: 0x6003f0f0
        /// DMA_OUT_DSCR_CH0_REG.
        pub const OUT_DSCR_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the current outlink descriptor y.
            OUTLINK_DSCR_CH0: u32,
        }), base_address + 0xf0);

        /// address: 0x6003f0f4
        /// DMA_OUT_DSCR_BF0_CH0_REG.
        pub const OUT_DSCR_BF0_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the last outlink descriptor y-1.
            OUTLINK_DSCR_BF0_CH0: u32,
        }), base_address + 0xf4);

        /// address: 0x6003f0f8
        /// DMA_OUT_DSCR_BF1_CH0_REG.
        pub const OUT_DSCR_BF1_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the second-to-last inlink descriptor x-2.
            OUTLINK_DSCR_BF1_CH0: u32,
        }), base_address + 0xf8);

        /// address: 0x6003f0fc
        /// DMA_OUT_PRI_CH0_REG.
        pub const OUT_PRI_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The priority of Tx channel 0. The larger of the value, the higher of the
            /// priority.
            TX_PRI_CH0: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xfc);

        /// address: 0x6003f100
        /// DMA_OUT_PERI_SEL_CH0_REG.
        pub const OUT_PERI_SEL_CH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to select peripheral for Tx channel 0. 0:SPI2. 1:
            /// reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8:
            /// ADC_DAC.
            PERI_OUT_SEL_CH0: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x100);

        /// address: 0x6003f130
        /// DMA_IN_CONF0_CH1_REG.
        pub const IN_CONF0_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is used to reset DMA channel 1 Rx FSM and Rx FIFO pointer.
            IN_RST_CH1: u1,
            /// reserved
            IN_LOOP_TEST_CH1: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Rx channel 1 reading link
            /// descriptor when accessing internal SRAM.
            INDSCR_BURST_EN_CH1: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Rx channel 1 receiving data
            /// when accessing internal SRAM.
            IN_DATA_BURST_EN_CH1: u1,
            /// Set this bit 1 to enable automatic transmitting data from memory to memory via
            /// DMA.
            MEM_TRANS_EN_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x130);

        /// address: 0x6003f134
        /// DMA_IN_CONF1_CH1_REG.
        pub const IN_CONF1_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Set this bit to enable checking the owner attribute of the link descriptor.
            IN_CHECK_OWNER_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x134);

        /// address: 0x6003f138
        /// DMA_INFIFO_STATUS_CH1_REG.
        pub const INFIFO_STATUS_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L1 Rx FIFO full signal for Rx channel 1.
            INFIFO_FULL_CH1: u1,
            /// L1 Rx FIFO empty signal for Rx channel 1.
            INFIFO_EMPTY_CH1: u1,
            /// The register stores the byte number of the data in L1 Rx FIFO for Rx channel 1.
            INFIFO_CNT_CH1: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// reserved
            IN_REMAIN_UNDER_1B_CH1: u1,
            /// reserved
            IN_REMAIN_UNDER_2B_CH1: u1,
            /// reserved
            IN_REMAIN_UNDER_3B_CH1: u1,
            /// reserved
            IN_REMAIN_UNDER_4B_CH1: u1,
            /// reserved
            IN_BUF_HUNGRY_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x138);

        /// address: 0x6003f13c
        /// DMA_IN_POP_CH1_REG.
        pub const IN_POP_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the data popping from DMA FIFO.
            INFIFO_RDATA_CH1: u12,
            /// Set this bit to pop data from DMA FIFO.
            INFIFO_POP_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x13c);

        /// address: 0x6003f140
        /// DMA_IN_LINK_CH1_REG.
        pub const IN_LINK_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the 20 least significant bits of the first inlink
            /// descriptor's address.
            INLINK_ADDR_CH1: u20,
            /// Set this bit to return to current inlink descriptor's address, when there are
            /// some errors in current receiving data.
            INLINK_AUTO_RET_CH1: u1,
            /// Set this bit to stop dealing with the inlink descriptors.
            INLINK_STOP_CH1: u1,
            /// Set this bit to start dealing with the inlink descriptors.
            INLINK_START_CH1: u1,
            /// Set this bit to mount a new inlink descriptor.
            INLINK_RESTART_CH1: u1,
            /// 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM
            /// is working.
            INLINK_PARK_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x140);

        /// address: 0x6003f144
        /// DMA_IN_STATE_CH1_REG.
        pub const IN_STATE_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the current inlink descriptor's address.
            INLINK_DSCR_ADDR_CH1: u18,
            /// reserved
            IN_DSCR_STATE_CH1: u2,
            /// reserved
            IN_STATE_CH1: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x144);

        /// address: 0x6003f148
        /// DMA_IN_SUC_EOF_DES_ADDR_CH1_REG.
        pub const IN_SUC_EOF_DES_ADDR_CH1 = @intToPtr(*volatile u32, base_address + 0x148);

        /// address: 0x6003f14c
        /// DMA_IN_ERR_EOF_DES_ADDR_CH1_REG.
        pub const IN_ERR_EOF_DES_ADDR_CH1 = @intToPtr(*volatile u32, base_address + 0x14c);

        /// address: 0x6003f150
        /// DMA_IN_DSCR_CH1_REG.
        pub const IN_DSCR_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the current inlink descriptor x.
            INLINK_DSCR_CH1: u32,
        }), base_address + 0x150);

        /// address: 0x6003f154
        /// DMA_IN_DSCR_BF0_CH1_REG.
        pub const IN_DSCR_BF0_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the last inlink descriptor x-1.
            INLINK_DSCR_BF0_CH1: u32,
        }), base_address + 0x154);

        /// address: 0x6003f158
        /// DMA_IN_DSCR_BF1_CH1_REG.
        pub const IN_DSCR_BF1_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the second-to-last inlink descriptor x-2.
            INLINK_DSCR_BF1_CH1: u32,
        }), base_address + 0x158);

        /// address: 0x6003f15c
        /// DMA_IN_PRI_CH1_REG.
        pub const IN_PRI_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The priority of Rx channel 1. The larger of the value, the higher of the
            /// priority.
            RX_PRI_CH1: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x15c);

        /// address: 0x6003f160
        /// DMA_IN_PERI_SEL_CH1_REG.
        pub const IN_PERI_SEL_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to select peripheral for Rx channel 1. 0:SPI2. 1:
            /// reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8:
            /// ADC_DAC.
            PERI_IN_SEL_CH1: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x160);

        /// address: 0x6003f190
        /// DMA_OUT_CONF0_CH1_REG.
        pub const OUT_CONF0_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is used to reset DMA channel 1 Tx FSM and Tx FIFO pointer.
            OUT_RST_CH1: u1,
            /// reserved
            OUT_LOOP_TEST_CH1: u1,
            /// Set this bit to enable automatic outlink-writeback when all the data in tx
            /// buffer has been transmitted.
            OUT_AUTO_WRBACK_CH1: u1,
            /// EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 1 is
            /// generated when data need to transmit has been popped from FIFO in DMA
            OUT_EOF_MODE_CH1: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Tx channel 1 reading link
            /// descriptor when accessing internal SRAM.
            OUTDSCR_BURST_EN_CH1: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Tx channel 1 transmitting
            /// data when accessing internal SRAM.
            OUT_DATA_BURST_EN_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x190);

        /// address: 0x6003f194
        /// DMA_OUT_CONF1_CH1_REG.
        pub const OUT_CONF1_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Set this bit to enable checking the owner attribute of the link descriptor.
            OUT_CHECK_OWNER_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x194);

        /// address: 0x6003f198
        /// DMA_OUTFIFO_STATUS_CH1_REG.
        pub const OUTFIFO_STATUS_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L1 Tx FIFO full signal for Tx channel 1.
            OUTFIFO_FULL_CH1: u1,
            /// L1 Tx FIFO empty signal for Tx channel 1.
            OUTFIFO_EMPTY_CH1: u1,
            /// The register stores the byte number of the data in L1 Tx FIFO for Tx channel 1.
            OUTFIFO_CNT_CH1: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// reserved
            OUT_REMAIN_UNDER_1B_CH1: u1,
            /// reserved
            OUT_REMAIN_UNDER_2B_CH1: u1,
            /// reserved
            OUT_REMAIN_UNDER_3B_CH1: u1,
            /// reserved
            OUT_REMAIN_UNDER_4B_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x198);

        /// address: 0x6003f19c
        /// DMA_OUT_PUSH_CH1_REG.
        pub const OUT_PUSH_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the data that need to be pushed into DMA FIFO.
            OUTFIFO_WDATA_CH1: u9,
            /// Set this bit to push data into DMA FIFO.
            OUTFIFO_PUSH_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x19c);

        /// address: 0x6003f1a0
        /// DMA_OUT_LINK_CH1_REG.
        pub const OUT_LINK_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the 20 least significant bits of the first outlink
            /// descriptor's address.
            OUTLINK_ADDR_CH1: u20,
            /// Set this bit to stop dealing with the outlink descriptors.
            OUTLINK_STOP_CH1: u1,
            /// Set this bit to start dealing with the outlink descriptors.
            OUTLINK_START_CH1: u1,
            /// Set this bit to restart a new outlink from the last address.
            OUTLINK_RESTART_CH1: u1,
            /// 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's
            /// FSM is working.
            OUTLINK_PARK_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x1a0);

        /// address: 0x6003f1a4
        /// DMA_OUT_STATE_CH1_REG.
        pub const OUT_STATE_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the current outlink descriptor's address.
            OUTLINK_DSCR_ADDR_CH1: u18,
            /// reserved
            OUT_DSCR_STATE_CH1: u2,
            /// reserved
            OUT_STATE_CH1: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1a4);

        /// address: 0x6003f1a8
        /// DMA_OUT_EOF_DES_ADDR_CH1_REG.
        pub const OUT_EOF_DES_ADDR_CH1 = @intToPtr(*volatile u32, base_address + 0x1a8);

        /// address: 0x6003f1ac
        /// DMA_OUT_EOF_BFR_DES_ADDR_CH1_REG.
        pub const OUT_EOF_BFR_DES_ADDR_CH1 = @intToPtr(*volatile u32, base_address + 0x1ac);

        /// address: 0x6003f1b0
        /// DMA_OUT_DSCR_CH1_REG.
        pub const OUT_DSCR_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the current outlink descriptor y.
            OUTLINK_DSCR_CH1: u32,
        }), base_address + 0x1b0);

        /// address: 0x6003f1b4
        /// DMA_OUT_DSCR_BF0_CH1_REG.
        pub const OUT_DSCR_BF0_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the last outlink descriptor y-1.
            OUTLINK_DSCR_BF0_CH1: u32,
        }), base_address + 0x1b4);

        /// address: 0x6003f1b8
        /// DMA_OUT_DSCR_BF1_CH1_REG.
        pub const OUT_DSCR_BF1_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the second-to-last inlink descriptor x-2.
            OUTLINK_DSCR_BF1_CH1: u32,
        }), base_address + 0x1b8);

        /// address: 0x6003f1bc
        /// DMA_OUT_PRI_CH1_REG.
        pub const OUT_PRI_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The priority of Tx channel 1. The larger of the value, the higher of the
            /// priority.
            TX_PRI_CH1: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x1bc);

        /// address: 0x6003f1c0
        /// DMA_OUT_PERI_SEL_CH1_REG.
        pub const OUT_PERI_SEL_CH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to select peripheral for Tx channel 1. 0:SPI2. 1:
            /// reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8:
            /// ADC_DAC.
            PERI_OUT_SEL_CH1: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x1c0);

        /// address: 0x6003f1f0
        /// DMA_IN_CONF0_CH2_REG.
        pub const IN_CONF0_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is used to reset DMA channel 2 Rx FSM and Rx FIFO pointer.
            IN_RST_CH2: u1,
            /// reserved
            IN_LOOP_TEST_CH2: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Rx channel 2 reading link
            /// descriptor when accessing internal SRAM.
            INDSCR_BURST_EN_CH2: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Rx channel 2 receiving data
            /// when accessing internal SRAM.
            IN_DATA_BURST_EN_CH2: u1,
            /// Set this bit 1 to enable automatic transmitting data from memory to memory via
            /// DMA.
            MEM_TRANS_EN_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x1f0);

        /// address: 0x6003f1f4
        /// DMA_IN_CONF1_CH2_REG.
        pub const IN_CONF1_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Set this bit to enable checking the owner attribute of the link descriptor.
            IN_CHECK_OWNER_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x1f4);

        /// address: 0x6003f1f8
        /// DMA_INFIFO_STATUS_CH2_REG.
        pub const INFIFO_STATUS_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L1 Rx FIFO full signal for Rx channel 2.
            INFIFO_FULL_CH2: u1,
            /// L1 Rx FIFO empty signal for Rx channel 2.
            INFIFO_EMPTY_CH2: u1,
            /// The register stores the byte number of the data in L1 Rx FIFO for Rx channel 2.
            INFIFO_CNT_CH2: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// reserved
            IN_REMAIN_UNDER_1B_CH2: u1,
            /// reserved
            IN_REMAIN_UNDER_2B_CH2: u1,
            /// reserved
            IN_REMAIN_UNDER_3B_CH2: u1,
            /// reserved
            IN_REMAIN_UNDER_4B_CH2: u1,
            /// reserved
            IN_BUF_HUNGRY_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x1f8);

        /// address: 0x6003f1fc
        /// DMA_IN_POP_CH2_REG.
        pub const IN_POP_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the data popping from DMA FIFO.
            INFIFO_RDATA_CH2: u12,
            /// Set this bit to pop data from DMA FIFO.
            INFIFO_POP_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x1fc);

        /// address: 0x6003f200
        /// DMA_IN_LINK_CH2_REG.
        pub const IN_LINK_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the 20 least significant bits of the first inlink
            /// descriptor's address.
            INLINK_ADDR_CH2: u20,
            /// Set this bit to return to current inlink descriptor's address, when there are
            /// some errors in current receiving data.
            INLINK_AUTO_RET_CH2: u1,
            /// Set this bit to stop dealing with the inlink descriptors.
            INLINK_STOP_CH2: u1,
            /// Set this bit to start dealing with the inlink descriptors.
            INLINK_START_CH2: u1,
            /// Set this bit to mount a new inlink descriptor.
            INLINK_RESTART_CH2: u1,
            /// 1: the inlink descriptor's FSM is in idle state. 0: the inlink descriptor's FSM
            /// is working.
            INLINK_PARK_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x200);

        /// address: 0x6003f204
        /// DMA_IN_STATE_CH2_REG.
        pub const IN_STATE_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the current inlink descriptor's address.
            INLINK_DSCR_ADDR_CH2: u18,
            /// reserved
            IN_DSCR_STATE_CH2: u2,
            /// reserved
            IN_STATE_CH2: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x204);

        /// address: 0x6003f208
        /// DMA_IN_SUC_EOF_DES_ADDR_CH2_REG.
        pub const IN_SUC_EOF_DES_ADDR_CH2 = @intToPtr(*volatile u32, base_address + 0x208);

        /// address: 0x6003f20c
        /// DMA_IN_ERR_EOF_DES_ADDR_CH2_REG.
        pub const IN_ERR_EOF_DES_ADDR_CH2 = @intToPtr(*volatile u32, base_address + 0x20c);

        /// address: 0x6003f210
        /// DMA_IN_DSCR_CH2_REG.
        pub const IN_DSCR_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the current inlink descriptor x.
            INLINK_DSCR_CH2: u32,
        }), base_address + 0x210);

        /// address: 0x6003f214
        /// DMA_IN_DSCR_BF0_CH2_REG.
        pub const IN_DSCR_BF0_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the last inlink descriptor x-1.
            INLINK_DSCR_BF0_CH2: u32,
        }), base_address + 0x214);

        /// address: 0x6003f218
        /// DMA_IN_DSCR_BF1_CH2_REG.
        pub const IN_DSCR_BF1_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the second-to-last inlink descriptor x-2.
            INLINK_DSCR_BF1_CH2: u32,
        }), base_address + 0x218);

        /// address: 0x6003f21c
        /// DMA_IN_PRI_CH2_REG.
        pub const IN_PRI_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The priority of Rx channel 2. The larger of the value, the higher of the
            /// priority.
            RX_PRI_CH2: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x21c);

        /// address: 0x6003f220
        /// DMA_IN_PERI_SEL_CH2_REG.
        pub const IN_PERI_SEL_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to select peripheral for Rx channel 2. 0:SPI2. 1:
            /// reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8:
            /// ADC_DAC.
            PERI_IN_SEL_CH2: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x220);

        /// address: 0x6003f250
        /// DMA_OUT_CONF0_CH2_REG.
        pub const OUT_CONF0_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is used to reset DMA channel 2 Tx FSM and Tx FIFO pointer.
            OUT_RST_CH2: u1,
            /// reserved
            OUT_LOOP_TEST_CH2: u1,
            /// Set this bit to enable automatic outlink-writeback when all the data in tx
            /// buffer has been transmitted.
            OUT_AUTO_WRBACK_CH2: u1,
            /// EOF flag generation mode when transmitting data. 1: EOF flag for Tx channel 2 is
            /// generated when data need to transmit has been popped from FIFO in DMA
            OUT_EOF_MODE_CH2: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Tx channel 2 reading link
            /// descriptor when accessing internal SRAM.
            OUTDSCR_BURST_EN_CH2: u1,
            /// Set this bit to 1 to enable INCR burst transfer for Tx channel 2 transmitting
            /// data when accessing internal SRAM.
            OUT_DATA_BURST_EN_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x250);

        /// address: 0x6003f254
        /// DMA_OUT_CONF1_CH2_REG.
        pub const OUT_CONF1_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Set this bit to enable checking the owner attribute of the link descriptor.
            OUT_CHECK_OWNER_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x254);

        /// address: 0x6003f258
        /// DMA_OUTFIFO_STATUS_CH2_REG.
        pub const OUTFIFO_STATUS_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L1 Tx FIFO full signal for Tx channel 2.
            OUTFIFO_FULL_CH2: u1,
            /// L1 Tx FIFO empty signal for Tx channel 2.
            OUTFIFO_EMPTY_CH2: u1,
            /// The register stores the byte number of the data in L1 Tx FIFO for Tx channel 2.
            OUTFIFO_CNT_CH2: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// reserved
            OUT_REMAIN_UNDER_1B_CH2: u1,
            /// reserved
            OUT_REMAIN_UNDER_2B_CH2: u1,
            /// reserved
            OUT_REMAIN_UNDER_3B_CH2: u1,
            /// reserved
            OUT_REMAIN_UNDER_4B_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x258);

        /// address: 0x6003f25c
        /// DMA_OUT_PUSH_CH2_REG.
        pub const OUT_PUSH_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the data that need to be pushed into DMA FIFO.
            OUTFIFO_WDATA_CH2: u9,
            /// Set this bit to push data into DMA FIFO.
            OUTFIFO_PUSH_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x25c);

        /// address: 0x6003f260
        /// DMA_OUT_LINK_CH2_REG.
        pub const OUT_LINK_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the 20 least significant bits of the first outlink
            /// descriptor's address.
            OUTLINK_ADDR_CH2: u20,
            /// Set this bit to stop dealing with the outlink descriptors.
            OUTLINK_STOP_CH2: u1,
            /// Set this bit to start dealing with the outlink descriptors.
            OUTLINK_START_CH2: u1,
            /// Set this bit to restart a new outlink from the last address.
            OUTLINK_RESTART_CH2: u1,
            /// 1: the outlink descriptor's FSM is in idle state. 0: the outlink descriptor's
            /// FSM is working.
            OUTLINK_PARK_CH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x260);

        /// address: 0x6003f264
        /// DMA_OUT_STATE_CH2_REG.
        pub const OUT_STATE_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the current outlink descriptor's address.
            OUTLINK_DSCR_ADDR_CH2: u18,
            /// reserved
            OUT_DSCR_STATE_CH2: u2,
            /// reserved
            OUT_STATE_CH2: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x264);

        /// address: 0x6003f268
        /// DMA_OUT_EOF_DES_ADDR_CH2_REG.
        pub const OUT_EOF_DES_ADDR_CH2 = @intToPtr(*volatile u32, base_address + 0x268);

        /// address: 0x6003f26c
        /// DMA_OUT_EOF_BFR_DES_ADDR_CH2_REG.
        pub const OUT_EOF_BFR_DES_ADDR_CH2 = @intToPtr(*volatile u32, base_address + 0x26c);

        /// address: 0x6003f270
        /// DMA_OUT_DSCR_CH2_REG.
        pub const OUT_DSCR_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the current outlink descriptor y.
            OUTLINK_DSCR_CH2: u32,
        }), base_address + 0x270);

        /// address: 0x6003f274
        /// DMA_OUT_DSCR_BF0_CH2_REG.
        pub const OUT_DSCR_BF0_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the last outlink descriptor y-1.
            OUTLINK_DSCR_BF0_CH2: u32,
        }), base_address + 0x274);

        /// address: 0x6003f278
        /// DMA_OUT_DSCR_BF1_CH2_REG.
        pub const OUT_DSCR_BF1_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The address of the second-to-last inlink descriptor x-2.
            OUTLINK_DSCR_BF1_CH2: u32,
        }), base_address + 0x278);

        /// address: 0x6003f27c
        /// DMA_OUT_PRI_CH2_REG.
        pub const OUT_PRI_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The priority of Tx channel 2. The larger of the value, the higher of the
            /// priority.
            TX_PRI_CH2: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x27c);

        /// address: 0x6003f280
        /// DMA_OUT_PERI_SEL_CH2_REG.
        pub const OUT_PERI_SEL_CH2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to select peripheral for Tx channel 2. 0:SPI2. 1:
            /// reserved. 2: UHCI0. 3: I2S0. 4: reserved. 5: reserved. 6: AES. 7: SHA. 8:
            /// ADC_DAC.
            PERI_OUT_SEL_CH2: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x280);
    };

    /// Digital Signature
    pub const DS = struct {
        pub const base_address = 0x6003d000;

        /// address: 0x6003d000
        /// memory that stores Y
        pub const Y_MEM = @intToPtr(*volatile [512]u8, base_address + 0x0);

        /// address: 0x6003d200
        /// memory that stores M
        pub const M_MEM = @intToPtr(*volatile [512]u8, base_address + 0x200);

        /// address: 0x6003d400
        /// memory that stores Rb
        pub const RB_MEM = @intToPtr(*volatile [512]u8, base_address + 0x400);

        /// address: 0x6003d600
        /// memory that stores BOX
        pub const BOX_MEM = @intToPtr(*volatile [48]u8, base_address + 0x600);

        /// address: 0x6003d800
        /// memory that stores X
        pub const X_MEM = @intToPtr(*volatile [512]u8, base_address + 0x800);

        /// address: 0x6003da00
        /// memory that stores Z
        pub const Z_MEM = @intToPtr(*volatile [512]u8, base_address + 0xa00);

        /// address: 0x6003de00
        /// DS start control register
        pub const SET_START = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xe00);

        /// address: 0x6003de04
        /// DS continue control register
        pub const SET_CONTINUE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xe04);

        /// address: 0x6003de08
        /// DS finish control register
        pub const SET_FINISH = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xe08);

        /// address: 0x6003de0c
        /// DS query busy register
        pub const QUERY_BUSY = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xe0c);

        /// address: 0x6003de10
        /// DS query key-wrong counter register
        pub const QUERY_KEY_WRONG = @intToPtr(*volatile MmioInt(32, u4), base_address + 0xe10);

        /// address: 0x6003de14
        /// DS query check result register
        pub const QUERY_CHECK = @intToPtr(*volatile Mmio(32, packed struct {
            /// MD checkout result. 1'b0: MD check pass, 1'b1: MD check fail
            MD_ERROR: u1,
            /// padding checkout result. 1'b0: a good padding, 1'b1: a bad padding
            PADDING_BAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xe14);

        /// address: 0x6003de20
        /// DS version control register
        pub const DATE = @intToPtr(*volatile MmioInt(32, u30), base_address + 0xe20);
    };

    /// eFuse Controller
    pub const EFUSE = struct {
        pub const base_address = 0x60008800;

        /// address: 0x60008800
        /// Register 0 that stores data to be programmed.
        pub const PGM_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 0th 32-bit data to be programmed.
            PGM_DATA_0: u32,
        }), base_address + 0x0);

        /// address: 0x60008804
        /// Register 1 that stores data to be programmed.
        pub const PGM_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 1st 32-bit data to be programmed.
            PGM_DATA_1: u32,
        }), base_address + 0x4);

        /// address: 0x60008808
        /// Register 2 that stores data to be programmed.
        pub const PGM_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 2nd 32-bit data to be programmed.
            PGM_DATA_2: u32,
        }), base_address + 0x8);

        /// address: 0x6000880c
        /// Register 3 that stores data to be programmed.
        pub const PGM_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 3rd 32-bit data to be programmed.
            PGM_DATA_3: u32,
        }), base_address + 0xc);

        /// address: 0x60008810
        /// Register 4 that stores data to be programmed.
        pub const PGM_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 4th 32-bit data to be programmed.
            PGM_DATA_4: u32,
        }), base_address + 0x10);

        /// address: 0x60008814
        /// Register 5 that stores data to be programmed.
        pub const PGM_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 5th 32-bit data to be programmed.
            PGM_DATA_5: u32,
        }), base_address + 0x14);

        /// address: 0x60008818
        /// Register 6 that stores data to be programmed.
        pub const PGM_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 6th 32-bit data to be programmed.
            PGM_DATA_6: u32,
        }), base_address + 0x18);

        /// address: 0x6000881c
        /// Register 7 that stores data to be programmed.
        pub const PGM_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 7th 32-bit data to be programmed.
            PGM_DATA_7: u32,
        }), base_address + 0x1c);

        /// address: 0x60008820
        /// Register 0 that stores the RS code to be programmed.
        pub const PGM_CHECK_VALUE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 0th 32-bit RS code to be programmed.
            PGM_RS_DATA_0: u32,
        }), base_address + 0x20);

        /// address: 0x60008824
        /// Register 1 that stores the RS code to be programmed.
        pub const PGM_CHECK_VALUE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 1st 32-bit RS code to be programmed.
            PGM_RS_DATA_1: u32,
        }), base_address + 0x24);

        /// address: 0x60008828
        /// Register 2 that stores the RS code to be programmed.
        pub const PGM_CHECK_VALUE2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The content of the 2nd 32-bit RS code to be programmed.
            PGM_RS_DATA_2: u32,
        }), base_address + 0x28);

        /// address: 0x6000882c
        /// BLOCK0 data register 0.
        pub const RD_WR_DIS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Disable programming of individual eFuses.
            WR_DIS: u32,
        }), base_address + 0x2c);

        /// address: 0x60008830
        /// BLOCK0 data register 1.
        pub const RD_REPEAT_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to disable reading from BlOCK4-10.
            RD_DIS: u7,
            /// Set this bit to disable boot from RTC RAM.
            DIS_RTC_RAM_BOOT: u1,
            /// Set this bit to disable Icache.
            DIS_ICACHE: u1,
            /// Set this bit to disable function of usb switch to jtag in module of usb device.
            DIS_USB_JTAG: u1,
            /// Set this bit to disable Icache in download mode (boot_mode[3:0] is 0, 1, 2, 3,
            /// 6, 7).
            DIS_DOWNLOAD_ICACHE: u1,
            /// Set this bit to disable usb device.
            DIS_USB_DEVICE: u1,
            /// Set this bit to disable the function that forces chip into download mode.
            DIS_FORCE_DOWNLOAD: u1,
            /// Reserved (used for four backups method).
            RPT4_RESERVED6: u1,
            /// Set this bit to disable CAN function.
            DIS_CAN: u1,
            /// Set this bit to enable selection between usb_to_jtag and pad_to_jtag through
            /// strapping gpio10 when both reg_dis_usb_jtag and reg_dis_pad_jtag are equal to 0.
            JTAG_SEL_ENABLE: u1,
            /// Set these bits to disable JTAG in the soft way (odd number 1 means disable ).
            /// JTAG can be enabled in HMAC module.
            SOFT_DIS_JTAG: u3,
            /// Set this bit to disable JTAG in the hard way. JTAG is disabled permanently.
            DIS_PAD_JTAG: u1,
            /// Set this bit to disable flash encryption when in download boot modes.
            DIS_DOWNLOAD_MANUAL_ENCRYPT: u1,
            /// Controls single-end input threshold vrefh, 1.76 V to 2 V with step of 80 mV,
            /// stored in eFuse.
            USB_DREFH: u2,
            /// Controls single-end input threshold vrefl, 0.8 V to 1.04 V with step of 80 mV,
            /// stored in eFuse.
            USB_DREFL: u2,
            /// Set this bit to exchange USB D+ and D- pins.
            USB_EXCHG_PINS: u1,
            /// Set this bit to vdd spi pin function as gpio.
            VDD_SPI_AS_GPIO: u1,
            /// Enable btlc gpio.
            BTLC_GPIO_ENABLE: u2,
            /// Set this bit to enable power glitch function.
            POWERGLITCH_EN: u1,
            /// Sample delay configuration of power glitch.
            POWER_GLITCH_DSENSE: u2,
        }), base_address + 0x30);

        /// address: 0x60008834
        /// BLOCK0 data register 2.
        pub const RD_REPEAT_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved (used for four backups method).
            RPT4_RESERVED2: u16,
            /// Selects RTC watchdog timeout threshold, in unit of slow clock cycle. 0: 40000.
            /// 1: 80000. 2: 160000. 3:320000.
            WDT_DELAY_SEL: u2,
            /// Set this bit to enable SPI boot encrypt/decrypt. Odd number of 1: enable. even
            /// number of 1: disable.
            SPI_BOOT_CRYPT_CNT: u3,
            /// Set this bit to enable revoking first secure boot key.
            SECURE_BOOT_KEY_REVOKE0: u1,
            /// Set this bit to enable revoking second secure boot key.
            SECURE_BOOT_KEY_REVOKE1: u1,
            /// Set this bit to enable revoking third secure boot key.
            SECURE_BOOT_KEY_REVOKE2: u1,
            /// Purpose of Key0.
            KEY_PURPOSE_0: u4,
            /// Purpose of Key1.
            KEY_PURPOSE_1: u4,
        }), base_address + 0x34);

        /// address: 0x60008838
        /// BLOCK0 data register 3.
        pub const RD_REPEAT_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Purpose of Key2.
            KEY_PURPOSE_2: u4,
            /// Purpose of Key3.
            KEY_PURPOSE_3: u4,
            /// Purpose of Key4.
            KEY_PURPOSE_4: u4,
            /// Purpose of Key5.
            KEY_PURPOSE_5: u4,
            /// Reserved (used for four backups method).
            RPT4_RESERVED3: u4,
            /// Set this bit to enable secure boot.
            SECURE_BOOT_EN: u1,
            /// Set this bit to enable revoking aggressive secure boot.
            SECURE_BOOT_AGGRESSIVE_REVOKE: u1,
            /// Reserved (used for four backups method).
            RPT4_RESERVED0: u6,
            /// Configures flash waiting time after power-up, in unit of ms. If the value is
            /// less than 15, the waiting time is the configurable value; Otherwise, the waiting
            /// time is twice the configurable value.
            FLASH_TPUW: u4,
        }), base_address + 0x38);

        /// address: 0x6000883c
        /// BLOCK0 data register 4.
        pub const RD_REPEAT_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to disable download mode (boot_mode[3:0] = 0, 1, 2, 3, 6, 7).
            DIS_DOWNLOAD_MODE: u1,
            /// Set this bit to disable Legacy SPI boot mode (boot_mode[3:0] = 4).
            DIS_LEGACY_SPI_BOOT: u1,
            /// Selectes the default UART print channel. 0: UART0. 1: UART1.
            UART_PRINT_CHANNEL: u1,
            /// Set ECC mode in ROM, 0: ROM would Enable Flash ECC 16to18 byte mode. 1:ROM would
            /// use 16to17 byte mode.
            FLASH_ECC_MODE: u1,
            /// Set this bit to disable UART download mode through USB.
            DIS_USB_DOWNLOAD_MODE: u1,
            /// Set this bit to enable secure UART download mode.
            ENABLE_SECURITY_DOWNLOAD: u1,
            /// Set the default UARTboot message output mode. 00: Enabled. 01: Enabled when
            /// GPIO8 is low at reset. 10: Enabled when GPIO8 is high at reset. 11:disabled.
            UART_PRINT_CONTROL: u2,
            /// GPIO33-GPIO37 power supply selection in ROM code. 0: VDD3P3_CPU. 1: VDD_SPI.
            PIN_POWER_SELECTION: u1,
            /// Set the maximum lines of SPI flash. 0: four lines. 1: eight lines.
            FLASH_TYPE: u1,
            /// Set Flash page size.
            FLASH_PAGE_SIZE: u2,
            /// Set 1 to enable ECC for flash boot.
            FLASH_ECC_EN: u1,
            /// Set this bit to force ROM code to send a resume command during SPI boot.
            FORCE_SEND_RESUME: u1,
            /// Secure version (used by ESP-IDF anti-rollback feature).
            SECURE_VERSION: u16,
            /// Reserved (used for four backups method).
            RPT4_RESERVED1: u2,
        }), base_address + 0x3c);

        /// address: 0x60008840
        /// BLOCK0 data register 5.
        pub const RD_REPEAT_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved (used for four backups method).
            RPT4_RESERVED4: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x40);

        /// address: 0x60008844
        /// BLOCK1 data register 0.
        pub const RD_MAC_SPI_SYS_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the low 32 bits of MAC address.
            MAC_0: u32,
        }), base_address + 0x44);

        /// address: 0x60008848
        /// BLOCK1 data register 1.
        pub const RD_MAC_SPI_SYS_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the high 16 bits of MAC address.
            MAC_1: u16,
            /// Stores the zeroth part of SPI_PAD_CONF.
            SPI_PAD_CONF_0: u16,
        }), base_address + 0x48);

        /// address: 0x6000884c
        /// BLOCK1 data register 2.
        pub const RD_MAC_SPI_SYS_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the first part of SPI_PAD_CONF.
            SPI_PAD_CONF_1: u32,
        }), base_address + 0x4c);

        /// address: 0x60008850
        /// BLOCK1 data register 3.
        pub const RD_MAC_SPI_SYS_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second part of SPI_PAD_CONF.
            SPI_PAD_CONF_2: u18,
            /// Stores the fist 14 bits of the zeroth part of system data.
            SYS_DATA_PART0_0: u14,
        }), base_address + 0x50);

        /// address: 0x60008854
        /// BLOCK1 data register 4.
        pub const RD_MAC_SPI_SYS_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fist 32 bits of the zeroth part of system data.
            SYS_DATA_PART0_1: u32,
        }), base_address + 0x54);

        /// address: 0x60008858
        /// BLOCK1 data register 5.
        pub const RD_MAC_SPI_SYS_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second 32 bits of the zeroth part of system data.
            SYS_DATA_PART0_2: u32,
        }), base_address + 0x58);

        /// address: 0x6000885c
        /// Register 0 of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the zeroth 32 bits of the first part of system data.
            SYS_DATA_PART1_0: u32,
        }), base_address + 0x5c);

        /// address: 0x60008860
        /// Register 1 of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the first 32 bits of the first part of system data.
            SYS_DATA_PART1_1: u32,
        }), base_address + 0x60);

        /// address: 0x60008864
        /// Register 2 of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second 32 bits of the first part of system data.
            SYS_DATA_PART1_2: u32,
        }), base_address + 0x64);

        /// address: 0x60008868
        /// Register 3 of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the third 32 bits of the first part of system data.
            SYS_DATA_PART1_3: u32,
        }), base_address + 0x68);

        /// address: 0x6000886c
        /// Register 4 of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fourth 32 bits of the first part of system data.
            SYS_DATA_PART1_4: u32,
        }), base_address + 0x6c);

        /// address: 0x60008870
        /// Register 5 of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fifth 32 bits of the first part of system data.
            SYS_DATA_PART1_5: u32,
        }), base_address + 0x70);

        /// address: 0x60008874
        /// Register 6 of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the sixth 32 bits of the first part of system data.
            SYS_DATA_PART1_6: u32,
        }), base_address + 0x74);

        /// address: 0x60008878
        /// Register 7 of BLOCK2 (system).
        pub const RD_SYS_PART1_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the seventh 32 bits of the first part of system data.
            SYS_DATA_PART1_7: u32,
        }), base_address + 0x78);

        /// address: 0x6000887c
        /// Register 0 of BLOCK3 (user).
        pub const RD_USR_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the zeroth 32 bits of BLOCK3 (user).
            USR_DATA0: u32,
        }), base_address + 0x7c);

        /// address: 0x60008880
        /// Register 1 of BLOCK3 (user).
        pub const RD_USR_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the first 32 bits of BLOCK3 (user).
            USR_DATA1: u32,
        }), base_address + 0x80);

        /// address: 0x60008884
        /// Register 2 of BLOCK3 (user).
        pub const RD_USR_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second 32 bits of BLOCK3 (user).
            USR_DATA2: u32,
        }), base_address + 0x84);

        /// address: 0x60008888
        /// Register 3 of BLOCK3 (user).
        pub const RD_USR_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the third 32 bits of BLOCK3 (user).
            USR_DATA3: u32,
        }), base_address + 0x88);

        /// address: 0x6000888c
        /// Register 4 of BLOCK3 (user).
        pub const RD_USR_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fourth 32 bits of BLOCK3 (user).
            USR_DATA4: u32,
        }), base_address + 0x8c);

        /// address: 0x60008890
        /// Register 5 of BLOCK3 (user).
        pub const RD_USR_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fifth 32 bits of BLOCK3 (user).
            USR_DATA5: u32,
        }), base_address + 0x90);

        /// address: 0x60008894
        /// Register 6 of BLOCK3 (user).
        pub const RD_USR_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the sixth 32 bits of BLOCK3 (user).
            USR_DATA6: u32,
        }), base_address + 0x94);

        /// address: 0x60008898
        /// Register 7 of BLOCK3 (user).
        pub const RD_USR_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the seventh 32 bits of BLOCK3 (user).
            USR_DATA7: u32,
        }), base_address + 0x98);

        /// address: 0x6000889c
        /// Register 0 of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the zeroth 32 bits of KEY0.
            KEY0_DATA0: u32,
        }), base_address + 0x9c);

        /// address: 0x600088a0
        /// Register 1 of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the first 32 bits of KEY0.
            KEY0_DATA1: u32,
        }), base_address + 0xa0);

        /// address: 0x600088a4
        /// Register 2 of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second 32 bits of KEY0.
            KEY0_DATA2: u32,
        }), base_address + 0xa4);

        /// address: 0x600088a8
        /// Register 3 of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the third 32 bits of KEY0.
            KEY0_DATA3: u32,
        }), base_address + 0xa8);

        /// address: 0x600088ac
        /// Register 4 of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fourth 32 bits of KEY0.
            KEY0_DATA4: u32,
        }), base_address + 0xac);

        /// address: 0x600088b0
        /// Register 5 of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fifth 32 bits of KEY0.
            KEY0_DATA5: u32,
        }), base_address + 0xb0);

        /// address: 0x600088b4
        /// Register 6 of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the sixth 32 bits of KEY0.
            KEY0_DATA6: u32,
        }), base_address + 0xb4);

        /// address: 0x600088b8
        /// Register 7 of BLOCK4 (KEY0).
        pub const RD_KEY0_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the seventh 32 bits of KEY0.
            KEY0_DATA7: u32,
        }), base_address + 0xb8);

        /// address: 0x600088bc
        /// Register 0 of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the zeroth 32 bits of KEY1.
            KEY1_DATA0: u32,
        }), base_address + 0xbc);

        /// address: 0x600088c0
        /// Register 1 of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the first 32 bits of KEY1.
            KEY1_DATA1: u32,
        }), base_address + 0xc0);

        /// address: 0x600088c4
        /// Register 2 of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second 32 bits of KEY1.
            KEY1_DATA2: u32,
        }), base_address + 0xc4);

        /// address: 0x600088c8
        /// Register 3 of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the third 32 bits of KEY1.
            KEY1_DATA3: u32,
        }), base_address + 0xc8);

        /// address: 0x600088cc
        /// Register 4 of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fourth 32 bits of KEY1.
            KEY1_DATA4: u32,
        }), base_address + 0xcc);

        /// address: 0x600088d0
        /// Register 5 of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fifth 32 bits of KEY1.
            KEY1_DATA5: u32,
        }), base_address + 0xd0);

        /// address: 0x600088d4
        /// Register 6 of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the sixth 32 bits of KEY1.
            KEY1_DATA6: u32,
        }), base_address + 0xd4);

        /// address: 0x600088d8
        /// Register 7 of BLOCK5 (KEY1).
        pub const RD_KEY1_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the seventh 32 bits of KEY1.
            KEY1_DATA7: u32,
        }), base_address + 0xd8);

        /// address: 0x600088dc
        /// Register 0 of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the zeroth 32 bits of KEY2.
            KEY2_DATA0: u32,
        }), base_address + 0xdc);

        /// address: 0x600088e0
        /// Register 1 of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the first 32 bits of KEY2.
            KEY2_DATA1: u32,
        }), base_address + 0xe0);

        /// address: 0x600088e4
        /// Register 2 of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second 32 bits of KEY2.
            KEY2_DATA2: u32,
        }), base_address + 0xe4);

        /// address: 0x600088e8
        /// Register 3 of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the third 32 bits of KEY2.
            KEY2_DATA3: u32,
        }), base_address + 0xe8);

        /// address: 0x600088ec
        /// Register 4 of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fourth 32 bits of KEY2.
            KEY2_DATA4: u32,
        }), base_address + 0xec);

        /// address: 0x600088f0
        /// Register 5 of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fifth 32 bits of KEY2.
            KEY2_DATA5: u32,
        }), base_address + 0xf0);

        /// address: 0x600088f4
        /// Register 6 of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the sixth 32 bits of KEY2.
            KEY2_DATA6: u32,
        }), base_address + 0xf4);

        /// address: 0x600088f8
        /// Register 7 of BLOCK6 (KEY2).
        pub const RD_KEY2_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the seventh 32 bits of KEY2.
            KEY2_DATA7: u32,
        }), base_address + 0xf8);

        /// address: 0x600088fc
        /// Register 0 of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the zeroth 32 bits of KEY3.
            KEY3_DATA0: u32,
        }), base_address + 0xfc);

        /// address: 0x60008900
        /// Register 1 of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the first 32 bits of KEY3.
            KEY3_DATA1: u32,
        }), base_address + 0x100);

        /// address: 0x60008904
        /// Register 2 of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second 32 bits of KEY3.
            KEY3_DATA2: u32,
        }), base_address + 0x104);

        /// address: 0x60008908
        /// Register 3 of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the third 32 bits of KEY3.
            KEY3_DATA3: u32,
        }), base_address + 0x108);

        /// address: 0x6000890c
        /// Register 4 of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fourth 32 bits of KEY3.
            KEY3_DATA4: u32,
        }), base_address + 0x10c);

        /// address: 0x60008910
        /// Register 5 of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fifth 32 bits of KEY3.
            KEY3_DATA5: u32,
        }), base_address + 0x110);

        /// address: 0x60008914
        /// Register 6 of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the sixth 32 bits of KEY3.
            KEY3_DATA6: u32,
        }), base_address + 0x114);

        /// address: 0x60008918
        /// Register 7 of BLOCK7 (KEY3).
        pub const RD_KEY3_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the seventh 32 bits of KEY3.
            KEY3_DATA7: u32,
        }), base_address + 0x118);

        /// address: 0x6000891c
        /// Register 0 of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the zeroth 32 bits of KEY4.
            KEY4_DATA0: u32,
        }), base_address + 0x11c);

        /// address: 0x60008920
        /// Register 1 of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the first 32 bits of KEY4.
            KEY4_DATA1: u32,
        }), base_address + 0x120);

        /// address: 0x60008924
        /// Register 2 of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second 32 bits of KEY4.
            KEY4_DATA2: u32,
        }), base_address + 0x124);

        /// address: 0x60008928
        /// Register 3 of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the third 32 bits of KEY4.
            KEY4_DATA3: u32,
        }), base_address + 0x128);

        /// address: 0x6000892c
        /// Register 4 of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fourth 32 bits of KEY4.
            KEY4_DATA4: u32,
        }), base_address + 0x12c);

        /// address: 0x60008930
        /// Register 5 of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fifth 32 bits of KEY4.
            KEY4_DATA5: u32,
        }), base_address + 0x130);

        /// address: 0x60008934
        /// Register 6 of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the sixth 32 bits of KEY4.
            KEY4_DATA6: u32,
        }), base_address + 0x134);

        /// address: 0x60008938
        /// Register 7 of BLOCK8 (KEY4).
        pub const RD_KEY4_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the seventh 32 bits of KEY4.
            KEY4_DATA7: u32,
        }), base_address + 0x138);

        /// address: 0x6000893c
        /// Register 0 of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the zeroth 32 bits of KEY5.
            KEY5_DATA0: u32,
        }), base_address + 0x13c);

        /// address: 0x60008940
        /// Register 1 of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the first 32 bits of KEY5.
            KEY5_DATA1: u32,
        }), base_address + 0x140);

        /// address: 0x60008944
        /// Register 2 of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the second 32 bits of KEY5.
            KEY5_DATA2: u32,
        }), base_address + 0x144);

        /// address: 0x60008948
        /// Register 3 of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the third 32 bits of KEY5.
            KEY5_DATA3: u32,
        }), base_address + 0x148);

        /// address: 0x6000894c
        /// Register 4 of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fourth 32 bits of KEY5.
            KEY5_DATA4: u32,
        }), base_address + 0x14c);

        /// address: 0x60008950
        /// Register 5 of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the fifth 32 bits of KEY5.
            KEY5_DATA5: u32,
        }), base_address + 0x150);

        /// address: 0x60008954
        /// Register 6 of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the sixth 32 bits of KEY5.
            KEY5_DATA6: u32,
        }), base_address + 0x154);

        /// address: 0x60008958
        /// Register 7 of BLOCK9 (KEY5).
        pub const RD_KEY5_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the seventh 32 bits of KEY5.
            KEY5_DATA7: u32,
        }), base_address + 0x158);

        /// address: 0x6000895c
        /// Register 0 of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the 0th 32 bits of the 2nd part of system data.
            SYS_DATA_PART2_0: u32,
        }), base_address + 0x15c);

        /// address: 0x60008960
        /// Register 1 of BLOCK9 (KEY5).
        pub const RD_SYS_PART2_DATA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the 1st 32 bits of the 2nd part of system data.
            SYS_DATA_PART2_1: u32,
        }), base_address + 0x160);

        /// address: 0x60008964
        /// Register 2 of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the 2nd 32 bits of the 2nd part of system data.
            SYS_DATA_PART2_2: u32,
        }), base_address + 0x164);

        /// address: 0x60008968
        /// Register 3 of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the 3rd 32 bits of the 2nd part of system data.
            SYS_DATA_PART2_3: u32,
        }), base_address + 0x168);

        /// address: 0x6000896c
        /// Register 4 of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the 4th 32 bits of the 2nd part of system data.
            SYS_DATA_PART2_4: u32,
        }), base_address + 0x16c);

        /// address: 0x60008970
        /// Register 5 of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the 5th 32 bits of the 2nd part of system data.
            SYS_DATA_PART2_5: u32,
        }), base_address + 0x170);

        /// address: 0x60008974
        /// Register 6 of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the 6th 32 bits of the 2nd part of system data.
            SYS_DATA_PART2_6: u32,
        }), base_address + 0x174);

        /// address: 0x60008978
        /// Register 7 of BLOCK10 (system).
        pub const RD_SYS_PART2_DATA7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the 7th 32 bits of the 2nd part of system data.
            SYS_DATA_PART2_7: u32,
        }), base_address + 0x178);

        /// address: 0x6000897c
        /// Programming error record register 0 of BLOCK0.
        pub const RD_REPEAT_ERR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If any bit in RD_DIS is 1, then it indicates a programming error.
            RD_DIS_ERR: u7,
            /// If DIS_RTC_RAM_BOOT is 1, then it indicates a programming error.
            DIS_RTC_RAM_BOOT_ERR: u1,
            /// If DIS_ICACHE is 1, then it indicates a programming error.
            DIS_ICACHE_ERR: u1,
            /// If DIS_USB_JTAG is 1, then it indicates a programming error.
            DIS_USB_JTAG_ERR: u1,
            /// If DIS_DOWNLOAD_ICACHE is 1, then it indicates a programming error.
            DIS_DOWNLOAD_ICACHE_ERR: u1,
            /// If DIS_USB_DEVICE is 1, then it indicates a programming error.
            DIS_USB_DEVICE_ERR: u1,
            /// If DIS_FORCE_DOWNLOAD is 1, then it indicates a programming error.
            DIS_FORCE_DOWNLOAD_ERR: u1,
            /// Reserved.
            RPT4_RESERVED6_ERR: u1,
            /// If DIS_CAN is 1, then it indicates a programming error.
            DIS_CAN_ERR: u1,
            /// If JTAG_SEL_ENABLE is 1, then it indicates a programming error.
            JTAG_SEL_ENABLE_ERR: u1,
            /// If SOFT_DIS_JTAG is 1, then it indicates a programming error.
            SOFT_DIS_JTAG_ERR: u3,
            /// If DIS_PAD_JTAG is 1, then it indicates a programming error.
            DIS_PAD_JTAG_ERR: u1,
            /// If DIS_DOWNLOAD_MANUAL_ENCRYPT is 1, then it indicates a programming error.
            DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR: u1,
            /// If any bit in USB_DREFH is 1, then it indicates a programming error.
            USB_DREFH_ERR: u2,
            /// If any bit in USB_DREFL is 1, then it indicates a programming error.
            USB_DREFL_ERR: u2,
            /// If USB_EXCHG_PINS is 1, then it indicates a programming error.
            USB_EXCHG_PINS_ERR: u1,
            /// If VDD_SPI_AS_GPIO is 1, then it indicates a programming error.
            VDD_SPI_AS_GPIO_ERR: u1,
            /// If any bit in BTLC_GPIO_ENABLE is 1, then it indicates a programming error.
            BTLC_GPIO_ENABLE_ERR: u2,
            /// If POWERGLITCH_EN is 1, then it indicates a programming error.
            POWERGLITCH_EN_ERR: u1,
            /// If any bit in POWER_GLITCH_DSENSE is 1, then it indicates a programming error.
            POWER_GLITCH_DSENSE_ERR: u2,
        }), base_address + 0x17c);

        /// address: 0x60008980
        /// Programming error record register 1 of BLOCK0.
        pub const RD_REPEAT_ERR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            RPT4_RESERVED2_ERR: u16,
            /// If any bit in WDT_DELAY_SEL is 1, then it indicates a programming error.
            WDT_DELAY_SEL_ERR: u2,
            /// If any bit in SPI_BOOT_CRYPT_CNT is 1, then it indicates a programming error.
            SPI_BOOT_CRYPT_CNT_ERR: u3,
            /// If SECURE_BOOT_KEY_REVOKE0 is 1, then it indicates a programming error.
            SECURE_BOOT_KEY_REVOKE0_ERR: u1,
            /// If SECURE_BOOT_KEY_REVOKE1 is 1, then it indicates a programming error.
            SECURE_BOOT_KEY_REVOKE1_ERR: u1,
            /// If SECURE_BOOT_KEY_REVOKE2 is 1, then it indicates a programming error.
            SECURE_BOOT_KEY_REVOKE2_ERR: u1,
            /// If any bit in KEY_PURPOSE_0 is 1, then it indicates a programming error.
            KEY_PURPOSE_0_ERR: u4,
            /// If any bit in KEY_PURPOSE_1 is 1, then it indicates a programming error.
            KEY_PURPOSE_1_ERR: u4,
        }), base_address + 0x180);

        /// address: 0x60008984
        /// Programming error record register 2 of BLOCK0.
        pub const RD_REPEAT_ERR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If any bit in KEY_PURPOSE_2 is 1, then it indicates a programming error.
            KEY_PURPOSE_2_ERR: u4,
            /// If any bit in KEY_PURPOSE_3 is 1, then it indicates a programming error.
            KEY_PURPOSE_3_ERR: u4,
            /// If any bit in KEY_PURPOSE_4 is 1, then it indicates a programming error.
            KEY_PURPOSE_4_ERR: u4,
            /// If any bit in KEY_PURPOSE_5 is 1, then it indicates a programming error.
            KEY_PURPOSE_5_ERR: u4,
            /// Reserved.
            RPT4_RESERVED3_ERR: u4,
            /// If SECURE_BOOT_EN is 1, then it indicates a programming error.
            SECURE_BOOT_EN_ERR: u1,
            /// If SECURE_BOOT_AGGRESSIVE_REVOKE is 1, then it indicates a programming error.
            SECURE_BOOT_AGGRESSIVE_REVOKE_ERR: u1,
            /// Reserved.
            RPT4_RESERVED0_ERR: u6,
            /// If any bit in FLASH_TPUM is 1, then it indicates a programming error.
            FLASH_TPUW_ERR: u4,
        }), base_address + 0x184);

        /// address: 0x60008988
        /// Programming error record register 3 of BLOCK0.
        pub const RD_REPEAT_ERR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// If DIS_DOWNLOAD_MODE is 1, then it indicates a programming error.
            DIS_DOWNLOAD_MODE_ERR: u1,
            /// If DIS_LEGACY_SPI_BOOT is 1, then it indicates a programming error.
            DIS_LEGACY_SPI_BOOT_ERR: u1,
            /// If UART_PRINT_CHANNEL is 1, then it indicates a programming error.
            UART_PRINT_CHANNEL_ERR: u1,
            /// If FLASH_ECC_MODE is 1, then it indicates a programming error.
            FLASH_ECC_MODE_ERR: u1,
            /// If DIS_USB_DOWNLOAD_MODE is 1, then it indicates a programming error.
            DIS_USB_DOWNLOAD_MODE_ERR: u1,
            /// If ENABLE_SECURITY_DOWNLOAD is 1, then it indicates a programming error.
            ENABLE_SECURITY_DOWNLOAD_ERR: u1,
            /// If any bit in UART_PRINT_CONTROL is 1, then it indicates a programming error.
            UART_PRINT_CONTROL_ERR: u2,
            /// If PIN_POWER_SELECTION is 1, then it indicates a programming error.
            PIN_POWER_SELECTION_ERR: u1,
            /// If FLASH_TYPE is 1, then it indicates a programming error.
            FLASH_TYPE_ERR: u1,
            /// If any bits in FLASH_PAGE_SIZE is 1, then it indicates a programming error.
            FLASH_PAGE_SIZE_ERR: u2,
            /// If FLASH_ECC_EN_ERR is 1, then it indicates a programming error.
            FLASH_ECC_EN_ERR: u1,
            /// If FORCE_SEND_RESUME is 1, then it indicates a programming error.
            FORCE_SEND_RESUME_ERR: u1,
            /// If any bit in SECURE_VERSION is 1, then it indicates a programming error.
            SECURE_VERSION_ERR: u16,
            /// Reserved.
            RPT4_RESERVED1_ERR: u2,
        }), base_address + 0x188);

        /// address: 0x60008990
        /// Programming error record register 4 of BLOCK0.
        pub const RD_REPEAT_ERR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            RPT4_RESERVED4_ERR: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x190);

        /// address: 0x600089c0
        /// Programming error record register 0 of BLOCK1-10.
        pub const RD_RS_ERR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of this signal means the number of error bytes.
            MAC_SPI_8M_ERR_NUM: u3,
            /// 0: Means no failure and that the data of MAC_SPI_8M is reliable 1: Means that
            /// programming user data failed and the number of error bytes is over 6.
            MAC_SPI_8M_FAIL: u1,
            /// The value of this signal means the number of error bytes.
            SYS_PART1_NUM: u3,
            /// 0: Means no failure and that the data of system part1 is reliable 1: Means that
            /// programming user data failed and the number of error bytes is over 6.
            SYS_PART1_FAIL: u1,
            /// The value of this signal means the number of error bytes.
            USR_DATA_ERR_NUM: u3,
            /// 0: Means no failure and that the user data is reliable 1: Means that programming
            /// user data failed and the number of error bytes is over 6.
            USR_DATA_FAIL: u1,
            /// The value of this signal means the number of error bytes.
            KEY0_ERR_NUM: u3,
            /// 0: Means no failure and that the data of key0 is reliable 1: Means that
            /// programming key0 failed and the number of error bytes is over 6.
            KEY0_FAIL: u1,
            /// The value of this signal means the number of error bytes.
            KEY1_ERR_NUM: u3,
            /// 0: Means no failure and that the data of key1 is reliable 1: Means that
            /// programming key1 failed and the number of error bytes is over 6.
            KEY1_FAIL: u1,
            /// The value of this signal means the number of error bytes.
            KEY2_ERR_NUM: u3,
            /// 0: Means no failure and that the data of key2 is reliable 1: Means that
            /// programming key2 failed and the number of error bytes is over 6.
            KEY2_FAIL: u1,
            /// The value of this signal means the number of error bytes.
            KEY3_ERR_NUM: u3,
            /// 0: Means no failure and that the data of key3 is reliable 1: Means that
            /// programming key3 failed and the number of error bytes is over 6.
            KEY3_FAIL: u1,
            /// The value of this signal means the number of error bytes.
            KEY4_ERR_NUM: u3,
            /// 0: Means no failure and that the data of key4 is reliable 1: Means that
            /// programming key4 failed and the number of error bytes is over 6.
            KEY4_FAIL: u1,
        }), base_address + 0x1c0);

        /// address: 0x600089c4
        /// Programming error record register 1 of BLOCK1-10.
        pub const RD_RS_ERR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of this signal means the number of error bytes.
            KEY5_ERR_NUM: u3,
            /// 0: Means no failure and that the data of KEY5 is reliable 1: Means that
            /// programming user data failed and the number of error bytes is over 6.
            KEY5_FAIL: u1,
            /// The value of this signal means the number of error bytes.
            SYS_PART2_ERR_NUM: u3,
            /// 0: Means no failure and that the data of system part2 is reliable 1: Means that
            /// programming user data failed and the number of error bytes is over 6.
            SYS_PART2_FAIL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c4);

        /// address: 0x600089c8
        /// eFuse clcok configuration register.
        pub const CLK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to force eFuse SRAM into power-saving mode.
            EFUSE_MEM_FORCE_PD: u1,
            /// Set this bit and force to activate clock signal of eFuse SRAM.
            MEM_CLK_FORCE_ON: u1,
            /// Set this bit to force eFuse SRAM into working mode.
            EFUSE_MEM_FORCE_PU: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Set this bit and force to enable clock signal of eFuse memory.
            EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c8);

        /// address: 0x600089cc
        /// eFuse operation mode configuraiton register;
        pub const CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// 0x5A5A: Operate programming command 0x5AA5: Operate read command.
            OP_CODE: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1cc);

        /// address: 0x600089d0
        /// eFuse status register.
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Indicates the state of the eFuse state machine.
            STATE: u4,
            /// The value of OTP_LOAD_SW.
            OTP_LOAD_SW: u1,
            /// The value of OTP_VDDQ_C_SYNC2.
            OTP_VDDQ_C_SYNC2: u1,
            /// The value of OTP_STROBE_SW.
            OTP_STROBE_SW: u1,
            /// The value of OTP_CSB_SW.
            OTP_CSB_SW: u1,
            /// The value of OTP_PGENB_SW.
            OTP_PGENB_SW: u1,
            /// The value of OTP_VDDQ_IS_SW.
            OTP_VDDQ_IS_SW: u1,
            /// Indicates the number of error bits during programming BLOCK0.
            REPEAT_ERR_CNT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x1d0);

        /// address: 0x600089d4
        /// eFuse command register.
        pub const CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to send read command.
            READ_CMD: u1,
            /// Set this bit to send programming command.
            PGM_CMD: u1,
            /// The serial number of the block to be programmed. Value 0-10 corresponds to block
            /// number 0-10, respectively.
            BLK_NUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x1d4);

        /// address: 0x600089d8
        /// eFuse raw interrupt register.
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw bit signal for read_done interrupt.
            READ_DONE_INT_RAW: u1,
            /// The raw bit signal for pgm_done interrupt.
            PGM_DONE_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1d8);

        /// address: 0x600089dc
        /// eFuse interrupt status register.
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The status signal for read_done interrupt.
            READ_DONE_INT_ST: u1,
            /// The status signal for pgm_done interrupt.
            PGM_DONE_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1dc);

        /// address: 0x600089e0
        /// eFuse interrupt enable register.
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The enable signal for read_done interrupt.
            READ_DONE_INT_ENA: u1,
            /// The enable signal for pgm_done interrupt.
            PGM_DONE_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1e0);

        /// address: 0x600089e4
        /// eFuse interrupt clear register.
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The clear signal for read_done interrupt.
            READ_DONE_INT_CLR: u1,
            /// The clear signal for pgm_done interrupt.
            PGM_DONE_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x1e4);

        /// address: 0x600089e8
        /// Controls the eFuse programming voltage.
        pub const DAC_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Controls the division factor of the rising clock of the programming voltage.
            DAC_CLK_DIV: u8,
            /// Don't care.
            DAC_CLK_PAD_SEL: u1,
            /// Controls the rising period of the programming voltage.
            DAC_NUM: u8,
            /// Reduces the power supply of the programming voltage.
            OE_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x1e8);

        /// address: 0x600089ec
        /// Configures read timing parameters.
        pub const RD_TIM_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Configures the initial read time of eFuse.
            READ_INIT_NUM: u8,
        }), base_address + 0x1ec);

        /// address: 0x600089f0
        /// Configurarion register 1 of eFuse programming timing parameters.
        pub const WR_TIM_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Configures the power up time for VDDQ.
            PWR_ON_NUM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x1f0);

        /// address: 0x600089f4
        /// Configurarion register 2 of eFuse programming timing parameters.
        pub const WR_TIM_CONF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Configures the power outage time for VDDQ.
            PWR_OFF_NUM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1f4);

        /// address: 0x600089fc
        /// eFuse version register.
        pub const DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0x1fc);
    };

    /// External Memory
    pub const EXTMEM = struct {
        pub const base_address = 0x600c4000;

        /// address: 0x600c4000
        /// This description will be updated in the near future.
        pub const ICACHE_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to activate the data cache. 0: disable, 1: enable
            ICACHE_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x0);

        /// address: 0x600c4004
        /// This description will be updated in the near future.
        pub const ICACHE_CTRL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to disable core0 ibus, 0: enable, 1: disable
            ICACHE_SHUT_IBUS: u1,
            /// The bit is used to disable core1 ibus, 0: enable, 1: disable
            ICACHE_SHUT_DBUS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x600c4008
        /// This description will be updated in the near future.
        pub const ICACHE_TAG_POWER_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to close clock gating of icache tag memory. 1: close gating, 0:
            /// open clock gating.
            ICACHE_TAG_MEM_FORCE_ON: u1,
            /// The bit is used to power icache tag memory down, 0: follow rtc_lslp, 1: power
            /// down
            ICACHE_TAG_MEM_FORCE_PD: u1,
            /// The bit is used to power icache tag memory up, 0: follow rtc_lslp, 1: power up
            ICACHE_TAG_MEM_FORCE_PU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x8);

        /// address: 0x600c400c
        /// This description will be updated in the near future.
        pub const ICACHE_PRELOCK_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable the first section of prelock function.
            ICACHE_PRELOCK_SCT0_EN: u1,
            /// The bit is used to enable the second section of prelock function.
            ICACHE_PRELOCK_SCT1_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x600c4010
        /// This description will be updated in the near future.
        pub const ICACHE_PRELOCK_SCT0_ADDR = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x600c4014
        /// This description will be updated in the near future.
        pub const ICACHE_PRELOCK_SCT1_ADDR = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x600c4018
        /// This description will be updated in the near future.
        pub const ICACHE_PRELOCK_SCT_SIZE = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bits are used to configure the second length of data locking, which is
            /// combined with ICACHE_PRELOCK_SCT1_ADDR_REG
            ICACHE_PRELOCK_SCT1_SIZE: u16,
            /// The bits are used to configure the first length of data locking, which is
            /// combined with ICACHE_PRELOCK_SCT0_ADDR_REG
            ICACHE_PRELOCK_SCT0_SIZE: u16,
        }), base_address + 0x18);

        /// address: 0x600c401c
        /// This description will be updated in the near future.
        pub const ICACHE_LOCK_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable lock operation. It will be cleared by hardware after
            /// lock operation done.
            ICACHE_LOCK_ENA: u1,
            /// The bit is used to enable unlock operation. It will be cleared by hardware after
            /// unlock operation done.
            ICACHE_UNLOCK_ENA: u1,
            /// The bit is used to indicate unlock/lock operation is finished.
            ICACHE_LOCK_DONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x1c);

        /// address: 0x600c4020
        /// This description will be updated in the near future.
        pub const ICACHE_LOCK_ADDR = @intToPtr(*volatile u32, base_address + 0x20);

        /// address: 0x600c4024
        /// This description will be updated in the near future.
        pub const ICACHE_LOCK_SIZE = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x600c4028
        /// This description will be updated in the near future.
        pub const ICACHE_SYNC_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable invalidate operation. It will be cleared by hardware
            /// after invalidate operation done.
            ICACHE_INVALIDATE_ENA: u1,
            /// The bit is used to indicate invalidate operation is finished.
            ICACHE_SYNC_DONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x28);

        /// address: 0x600c402c
        /// This description will be updated in the near future.
        pub const ICACHE_SYNC_ADDR = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x600c4030
        /// This description will be updated in the near future.
        pub const ICACHE_SYNC_SIZE = @intToPtr(*volatile MmioInt(32, u23), base_address + 0x30);

        /// address: 0x600c4034
        /// This description will be updated in the near future.
        pub const ICACHE_PRELOAD_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable preload operation. It will be cleared by hardware
            /// after preload operation done.
            ICACHE_PRELOAD_ENA: u1,
            /// The bit is used to indicate preload operation is finished.
            ICACHE_PRELOAD_DONE: u1,
            /// The bit is used to configure the direction of preload operation. 1: descending,
            /// 0: ascending.
            ICACHE_PRELOAD_ORDER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x34);

        /// address: 0x600c4038
        /// This description will be updated in the near future.
        pub const ICACHE_PRELOAD_ADDR = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0x600c403c
        /// This description will be updated in the near future.
        pub const ICACHE_PRELOAD_SIZE = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x600c4040
        /// This description will be updated in the near future.
        pub const ICACHE_AUTOLOAD_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bits are used to enable the first section for autoload operation.
            ICACHE_AUTOLOAD_SCT0_ENA: u1,
            /// The bits are used to enable the second section for autoload operation.
            ICACHE_AUTOLOAD_SCT1_ENA: u1,
            /// The bit is used to enable and disable autoload operation. It is combined with
            /// icache_autoload_done. 1: enable, 0: disable.
            ICACHE_AUTOLOAD_ENA: u1,
            /// The bit is used to indicate autoload operation is finished.
            ICACHE_AUTOLOAD_DONE: u1,
            /// The bits are used to configure the direction of autoload. 1: descending, 0:
            /// ascending.
            ICACHE_AUTOLOAD_ORDER: u1,
            /// The bits are used to configure trigger conditions for autoload. 0/3: cache miss,
            /// 1: cache hit, 2: both cache miss and hit.
            ICACHE_AUTOLOAD_RQST: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x40);

        /// address: 0x600c4044
        /// This description will be updated in the near future.
        pub const ICACHE_AUTOLOAD_SCT0_ADDR = @intToPtr(*volatile u32, base_address + 0x44);

        /// address: 0x600c4048
        /// This description will be updated in the near future.
        pub const ICACHE_AUTOLOAD_SCT0_SIZE = @intToPtr(*volatile MmioInt(32, u27), base_address + 0x48);

        /// address: 0x600c404c
        /// This description will be updated in the near future.
        pub const ICACHE_AUTOLOAD_SCT1_ADDR = @intToPtr(*volatile u32, base_address + 0x4c);

        /// address: 0x600c4050
        /// This description will be updated in the near future.
        pub const ICACHE_AUTOLOAD_SCT1_SIZE = @intToPtr(*volatile MmioInt(32, u27), base_address + 0x50);

        /// address: 0x600c4054
        /// This description will be updated in the near future.
        pub const IBUS_TO_FLASH_START_VADDR = @intToPtr(*volatile u32, base_address + 0x54);

        /// address: 0x600c4058
        /// This description will be updated in the near future.
        pub const IBUS_TO_FLASH_END_VADDR = @intToPtr(*volatile u32, base_address + 0x58);

        /// address: 0x600c405c
        /// This description will be updated in the near future.
        pub const DBUS_TO_FLASH_START_VADDR = @intToPtr(*volatile u32, base_address + 0x5c);

        /// address: 0x600c4060
        /// This description will be updated in the near future.
        pub const DBUS_TO_FLASH_END_VADDR = @intToPtr(*volatile u32, base_address + 0x60);

        /// address: 0x600c4064
        /// This description will be updated in the near future.
        pub const CACHE_ACS_CNT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to clear ibus counter.
            IBUS_ACS_CNT_CLR: u1,
            /// The bit is used to clear dbus counter.
            DBUS_ACS_CNT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x64);

        /// address: 0x600c4068
        /// This description will be updated in the near future.
        pub const IBUS_ACS_MISS_CNT = @intToPtr(*volatile u32, base_address + 0x68);

        /// address: 0x600c406c
        /// This description will be updated in the near future.
        pub const IBUS_ACS_CNT = @intToPtr(*volatile u32, base_address + 0x6c);

        /// address: 0x600c4070
        /// This description will be updated in the near future.
        pub const DBUS_ACS_FLASH_MISS_CNT = @intToPtr(*volatile u32, base_address + 0x70);

        /// address: 0x600c4074
        /// This description will be updated in the near future.
        pub const DBUS_ACS_CNT = @intToPtr(*volatile u32, base_address + 0x74);

        /// address: 0x600c4078
        /// This description will be updated in the near future.
        pub const CACHE_ILG_INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable interrupt by sync configurations fault.
            ICACHE_SYNC_OP_FAULT_INT_ENA: u1,
            /// The bit is used to enable interrupt by preload configurations fault.
            ICACHE_PRELOAD_OP_FAULT_INT_ENA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// The bit is used to enable interrupt by mmu entry fault.
            MMU_ENTRY_FAULT_INT_ENA: u1,
            reserved3: u1,
            /// The bit is used to enable interrupt by ibus counter overflow.
            IBUS_CNT_OVF_INT_ENA: u1,
            /// The bit is used to enable interrupt by dbus counter overflow.
            DBUS_CNT_OVF_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x78);

        /// address: 0x600c407c
        /// This description will be updated in the near future.
        pub const CACHE_ILG_INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to clear interrupt by sync configurations fault.
            ICACHE_SYNC_OP_FAULT_INT_CLR: u1,
            /// The bit is used to clear interrupt by preload configurations fault.
            ICACHE_PRELOAD_OP_FAULT_INT_CLR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// The bit is used to clear interrupt by mmu entry fault.
            MMU_ENTRY_FAULT_INT_CLR: u1,
            reserved3: u1,
            /// The bit is used to clear interrupt by ibus counter overflow.
            IBUS_CNT_OVF_INT_CLR: u1,
            /// The bit is used to clear interrupt by dbus counter overflow.
            DBUS_CNT_OVF_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x7c);

        /// address: 0x600c4080
        /// This description will be updated in the near future.
        pub const CACHE_ILG_INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to indicate interrupt by sync configurations fault.
            ICACHE_SYNC_OP_FAULT_ST: u1,
            /// The bit is used to indicate interrupt by preload configurations fault.
            ICACHE_PRELOAD_OP_FAULT_ST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// The bit is used to indicate interrupt by mmu entry fault.
            MMU_ENTRY_FAULT_ST: u1,
            reserved3: u1,
            /// The bit is used to indicate interrupt by ibus access flash/spiram counter
            /// overflow.
            IBUS_ACS_CNT_OVF_ST: u1,
            /// The bit is used to indicate interrupt by ibus access flash/spiram miss counter
            /// overflow.
            IBUS_ACS_MISS_CNT_OVF_ST: u1,
            /// The bit is used to indicate interrupt by dbus access flash/spiram counter
            /// overflow.
            DBUS_ACS_CNT_OVF_ST: u1,
            /// The bit is used to indicate interrupt by dbus access flash miss counter
            /// overflow.
            DBUS_ACS_FLASH_MISS_CNT_OVF_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x80);

        /// address: 0x600c4084
        /// This description will be updated in the near future.
        pub const CORE0_ACS_CACHE_INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable interrupt by cpu access icache while the corresponding
            /// ibus is disabled which include speculative access.
            CORE0_IBUS_ACS_MSK_IC_INT_ENA: u1,
            /// The bit is used to enable interrupt by ibus trying to write icache
            CORE0_IBUS_WR_IC_INT_ENA: u1,
            /// The bit is used to enable interrupt by authentication fail.
            CORE0_IBUS_REJECT_INT_ENA: u1,
            /// The bit is used to enable interrupt by cpu access icache while the corresponding
            /// dbus is disabled which include speculative access.
            CORE0_DBUS_ACS_MSK_IC_INT_ENA: u1,
            /// The bit is used to enable interrupt by authentication fail.
            CORE0_DBUS_REJECT_INT_ENA: u1,
            /// The bit is used to enable interrupt by dbus trying to write icache
            CORE0_DBUS_WR_IC_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x84);

        /// address: 0x600c4088
        /// This description will be updated in the near future.
        pub const CORE0_ACS_CACHE_INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to clear interrupt by cpu access icache while the corresponding
            /// ibus is disabled or icache is disabled which include speculative access.
            CORE0_IBUS_ACS_MSK_IC_INT_CLR: u1,
            /// The bit is used to clear interrupt by ibus trying to write icache
            CORE0_IBUS_WR_IC_INT_CLR: u1,
            /// The bit is used to clear interrupt by authentication fail.
            CORE0_IBUS_REJECT_INT_CLR: u1,
            /// The bit is used to clear interrupt by cpu access icache while the corresponding
            /// dbus is disabled or icache is disabled which include speculative access.
            CORE0_DBUS_ACS_MSK_IC_INT_CLR: u1,
            /// The bit is used to clear interrupt by authentication fail.
            CORE0_DBUS_REJECT_INT_CLR: u1,
            /// The bit is used to clear interrupt by dbus trying to write icache
            CORE0_DBUS_WR_IC_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x88);

        /// address: 0x600c408c
        /// This description will be updated in the near future.
        pub const CORE0_ACS_CACHE_INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to indicate interrupt by cpu access icache while the core0_ibus
            /// is disabled or icache is disabled which include speculative access.
            CORE0_IBUS_ACS_MSK_ICACHE_ST: u1,
            /// The bit is used to indicate interrupt by ibus trying to write icache
            CORE0_IBUS_WR_ICACHE_ST: u1,
            /// The bit is used to indicate interrupt by authentication fail.
            CORE0_IBUS_REJECT_ST: u1,
            /// The bit is used to indicate interrupt by cpu access icache while the core0_dbus
            /// is disabled or icache is disabled which include speculative access.
            CORE0_DBUS_ACS_MSK_ICACHE_ST: u1,
            /// The bit is used to indicate interrupt by authentication fail.
            CORE0_DBUS_REJECT_ST: u1,
            /// The bit is used to indicate interrupt by dbus trying to write icache
            CORE0_DBUS_WR_ICACHE_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x8c);

        /// address: 0x600c4090
        /// This description will be updated in the near future.
        pub const CORE0_DBUS_REJECT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bits are used to indicate the attribute of CPU access dbus when
            /// authentication fail. 0: invalidate, 1: execute-able, 2: read-able, 4:
            /// write-able.
            CORE0_DBUS_ATTR: u3,
            /// The bit is used to indicate the world of CPU access dbus when authentication
            /// fail. 0: WORLD0, 1: WORLD1
            CORE0_DBUS_WORLD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x90);

        /// address: 0x600c4094
        /// This description will be updated in the near future.
        pub const CORE0_DBUS_REJECT_VADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bits are used to indicate the virtual address of CPU access dbus when
            /// authentication fail.
            CORE0_DBUS_VADDR: u32,
        }), base_address + 0x94);

        /// address: 0x600c4098
        /// This description will be updated in the near future.
        pub const CORE0_IBUS_REJECT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bits are used to indicate the attribute of CPU access ibus when
            /// authentication fail. 0: invalidate, 1: execute-able, 2: read-able
            CORE0_IBUS_ATTR: u3,
            /// The bit is used to indicate the world of CPU access ibus when authentication
            /// fail. 0: WORLD0, 1: WORLD1
            CORE0_IBUS_WORLD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x98);

        /// address: 0x600c409c
        /// This description will be updated in the near future.
        pub const CORE0_IBUS_REJECT_VADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bits are used to indicate the virtual address of CPU access ibus when
            /// authentication fail.
            CORE0_IBUS_VADDR: u32,
        }), base_address + 0x9c);

        /// address: 0x600c40a0
        /// This description will be updated in the near future.
        pub const CACHE_MMU_FAULT_CONTENT = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bits are used to indicate the content of mmu entry which cause mmu fault..
            CACHE_MMU_FAULT_CONTENT: u10,
            /// The right-most 3 bits are used to indicate the operations which cause mmu fault
            /// occurrence. 0: default, 1: cpu miss, 2: preload miss, 3: writeback, 4: cpu miss
            /// evict recovery address, 5: load miss evict recovery address, 6: external dma tx,
            /// 7: external dma rx. The most significant bit is used to indicate this operation
            /// occurs in which one icache.
            CACHE_MMU_FAULT_CODE: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xa0);

        /// address: 0x600c40a4
        /// This description will be updated in the near future.
        pub const CACHE_MMU_FAULT_VADDR = @intToPtr(*volatile u32, base_address + 0xa4);

        /// address: 0x600c40a8
        /// This description will be updated in the near future.
        pub const CACHE_WRAP_AROUND_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable wrap around mode when read data from flash.
            CACHE_FLASH_WRAP_AROUND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xa8);

        /// address: 0x600c40ac
        /// This description will be updated in the near future.
        pub const CACHE_MMU_POWER_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable clock gating to save power when access mmu memory, 0:
            /// enable, 1: disable
            CACHE_MMU_MEM_FORCE_ON: u1,
            /// The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power down
            CACHE_MMU_MEM_FORCE_PD: u1,
            /// The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd, 1: power up
            CACHE_MMU_MEM_FORCE_PU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xac);

        /// address: 0x600c40b0
        /// This description will be updated in the near future.
        pub const CACHE_STATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to indicate whether icache main fsm is in idle state or not. 1:
            /// in idle state, 0: not in idle state
            ICACHE_STATE: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xb0);

        /// address: 0x600c40b4
        /// This description will be updated in the near future.
        pub const CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            RECORD_DISABLE_DB_ENCRYPT: u1,
            /// Reserved.
            RECORD_DISABLE_G0CB_DECRYPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xb4);

        /// address: 0x600c40b8
        /// This description will be updated in the near future.
        pub const CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to close clock gating of manual crypt clock. 1: close gating, 0:
            /// open clock gating.
            CLK_FORCE_ON_MANUAL_CRYPT: u1,
            /// The bit is used to close clock gating of automatic crypt clock. 1: close gating,
            /// 0: open clock gating.
            CLK_FORCE_ON_AUTO_CRYPT: u1,
            /// The bit is used to close clock gating of external memory encrypt and decrypt
            /// clock. 1: close gating, 0: open clock gating.
            CLK_FORCE_ON_CRYPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xb8);

        /// address: 0x600c40bc
        /// This description will be updated in the near future.
        pub const CACHE_PRELOAD_INT_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to indicate the interrupt by icache pre-load done.
            ICACHE_PRELOAD_INT_ST: u1,
            /// The bit is used to enable the interrupt by icache pre-load done.
            ICACHE_PRELOAD_INT_ENA: u1,
            /// The bit is used to clear the interrupt by icache pre-load done.
            ICACHE_PRELOAD_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xbc);

        /// address: 0x600c40c0
        /// This description will be updated in the near future.
        pub const CACHE_SYNC_INT_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to indicate the interrupt by icache sync done.
            ICACHE_SYNC_INT_ST: u1,
            /// The bit is used to enable the interrupt by icache sync done.
            ICACHE_SYNC_INT_ENA: u1,
            /// The bit is used to clear the interrupt by icache sync done.
            ICACHE_SYNC_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc0);

        /// address: 0x600c40c4
        /// This description will be updated in the near future.
        pub const CACHE_MMU_OWNER = @intToPtr(*volatile MmioInt(32, u4), base_address + 0xc4);

        /// address: 0x600c40c8
        /// This description will be updated in the near future.
        pub const CACHE_CONF_MISC = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to disable checking mmu entry fault by preload operation.
            CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT: u1,
            /// The bit is used to disable checking mmu entry fault by sync operation.
            CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT: u1,
            /// The bit is used to enable cache trace function.
            CACHE_TRACE_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc8);

        /// address: 0x600c40cc
        /// This description will be updated in the near future.
        pub const ICACHE_FREEZE = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable icache freeze mode
            ENA: u1,
            /// The bit is used to configure freeze mode, 0: assert busy if CPU miss 1: assert
            /// hit if CPU miss
            MODE: u1,
            /// The bit is used to indicate icache freeze success
            DONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xcc);

        /// address: 0x600c40d0
        /// This description will be updated in the near future.
        pub const ICACHE_ATOMIC_OPERATE_ENA = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xd0);

        /// address: 0x600c40d4
        /// This description will be updated in the near future.
        pub const CACHE_REQUEST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to disable request recording which could cause performance issue
            BYPASS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xd4);

        /// address: 0x600c40d8
        /// This description will be updated in the near future.
        pub const IBUS_PMS_TBL_LOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure the ibus permission control section boundary0
            IBUS_PMS_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xd8);

        /// address: 0x600c40dc
        /// This description will be updated in the near future.
        pub const IBUS_PMS_TBL_BOUNDARY0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure the ibus permission control section boundary0
            IBUS_PMS_BOUNDARY0: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xdc);

        /// address: 0x600c40e0
        /// This description will be updated in the near future.
        pub const IBUS_PMS_TBL_BOUNDARY1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure the ibus permission control section boundary1
            IBUS_PMS_BOUNDARY1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xe0);

        /// address: 0x600c40e4
        /// This description will be updated in the near future.
        pub const IBUS_PMS_TBL_BOUNDARY2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure the ibus permission control section boundary2
            IBUS_PMS_BOUNDARY2: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xe4);

        /// address: 0x600c40e8
        /// This description will be updated in the near future.
        pub const IBUS_PMS_TBL_ATTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure attribute of the ibus permission control section1,
            /// bit0: fetch in world0, bit1: load in world0, bit2: fetch in world1, bit3: load
            /// in world1
            IBUS_PMS_SCT1_ATTR: u4,
            /// The bit is used to configure attribute of the ibus permission control section2,
            /// bit0: fetch in world0, bit1: load in world0, bit2: fetch in world1, bit3: load
            /// in world1
            IBUS_PMS_SCT2_ATTR: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xe8);

        /// address: 0x600c40ec
        /// This description will be updated in the near future.
        pub const DBUS_PMS_TBL_LOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure the ibus permission control section boundary0
            DBUS_PMS_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xec);

        /// address: 0x600c40f0
        /// This description will be updated in the near future.
        pub const DBUS_PMS_TBL_BOUNDARY0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure the dbus permission control section boundary0
            DBUS_PMS_BOUNDARY0: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xf0);

        /// address: 0x600c40f4
        /// This description will be updated in the near future.
        pub const DBUS_PMS_TBL_BOUNDARY1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure the dbus permission control section boundary1
            DBUS_PMS_BOUNDARY1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xf4);

        /// address: 0x600c40f8
        /// This description will be updated in the near future.
        pub const DBUS_PMS_TBL_BOUNDARY2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure the dbus permission control section boundary2
            DBUS_PMS_BOUNDARY2: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xf8);

        /// address: 0x600c40fc
        /// This description will be updated in the near future.
        pub const DBUS_PMS_TBL_ATTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to configure attribute of the dbus permission control section1,
            /// bit0: load in world0, bit2: load in world1
            DBUS_PMS_SCT1_ATTR: u2,
            /// The bit is used to configure attribute of the dbus permission control section2,
            /// bit0: load in world0, bit2: load in world1
            DBUS_PMS_SCT2_ATTR: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xfc);

        /// address: 0x600c4100
        /// This description will be updated in the near future.
        pub const CLOCK_GATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// clock gate enable.
            CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x100);

        /// address: 0x600c43fc
        /// This description will be updated in the near future.
        pub const REG_DATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// version information
            DATE: u28,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x3fc);
    };

    /// General Purpose Input/Output
    pub const GPIO = struct {
        pub const base_address = 0x60004000;

        /// address: 0x60004000
        /// GPIO bit select register
        pub const BT_SELECT = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO bit select register
            BT_SEL: u32,
        }), base_address + 0x0);

        /// address: 0x60004004
        /// GPIO output register
        pub const OUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO output register for GPIO0-25
            DATA_ORIG: u26,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x4);

        /// address: 0x60004008
        /// GPIO output set register
        pub const OUT_W1TS = @intToPtr(*volatile MmioInt(32, u26), base_address + 0x8);

        /// address: 0x6000400c
        /// GPIO output clear register
        pub const OUT_W1TC = @intToPtr(*volatile MmioInt(32, u26), base_address + 0xc);

        /// address: 0x6000401c
        /// GPIO sdio select register
        pub const SDIO_SELECT = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO sdio select register
            SDIO_SEL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x60004020
        /// GPIO output enable register
        pub const ENABLE = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO output enable register for GPIO0-25
            DATA: u26,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x20);

        /// address: 0x60004024
        /// GPIO output enable set register
        pub const ENABLE_W1TS = @intToPtr(*volatile MmioInt(32, u26), base_address + 0x24);

        /// address: 0x60004028
        /// GPIO output enable clear register
        pub const ENABLE_W1TC = @intToPtr(*volatile MmioInt(32, u26), base_address + 0x28);

        /// address: 0x60004038
        /// pad strapping register
        pub const STRAP = @intToPtr(*volatile Mmio(32, packed struct {
            /// pad strapping register
            STRAPPING: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x6000403c
        /// GPIO input register
        pub const IN = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO input register for GPIO0-25
            DATA_NEXT: u26,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x3c);

        /// address: 0x60004044
        /// GPIO interrupt status register
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO interrupt status register for GPIO0-25
            INTERRUPT: u26,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x44);

        /// address: 0x60004048
        /// GPIO interrupt status set register
        pub const STATUS_W1TS = @intToPtr(*volatile MmioInt(32, u26), base_address + 0x48);

        /// address: 0x6000404c
        /// GPIO interrupt status clear register
        pub const STATUS_W1TC = @intToPtr(*volatile MmioInt(32, u26), base_address + 0x4c);

        /// address: 0x6000405c
        /// GPIO PRO_CPU interrupt status register
        pub const PCPU_INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO PRO_CPU interrupt status register for GPIO0-25
            PROCPU_INT: u26,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x5c);

        /// address: 0x60004060
        /// GPIO PRO_CPU(not shielded) interrupt status register
        pub const PCPU_NMI_INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-25
            PROCPU_NMI_INT: u26,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x60);

        /// address: 0x60004064
        /// GPIO CPUSDIO interrupt status register
        pub const CPUSDIO_INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO CPUSDIO interrupt status register for GPIO0-25
            SDIO_INT: u26,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x64);

        /// address: 0x60004074
        /// GPIO pin configuration register
        pub const PIN0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x74);

        /// address: 0x60004078
        /// GPIO pin configuration register
        pub const PIN1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x78);

        /// address: 0x6000407c
        /// GPIO pin configuration register
        pub const PIN2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x7c);

        /// address: 0x60004080
        /// GPIO pin configuration register
        pub const PIN3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x80);

        /// address: 0x60004084
        /// GPIO pin configuration register
        pub const PIN4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x84);

        /// address: 0x60004088
        /// GPIO pin configuration register
        pub const PIN5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x88);

        /// address: 0x6000408c
        /// GPIO pin configuration register
        pub const PIN6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x8c);

        /// address: 0x60004090
        /// GPIO pin configuration register
        pub const PIN7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x90);

        /// address: 0x60004094
        /// GPIO pin configuration register
        pub const PIN8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x94);

        /// address: 0x60004098
        /// GPIO pin configuration register
        pub const PIN9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x98);

        /// address: 0x6000409c
        /// GPIO pin configuration register
        pub const PIN10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x9c);

        /// address: 0x600040a0
        /// GPIO pin configuration register
        pub const PIN11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xa0);

        /// address: 0x600040a4
        /// GPIO pin configuration register
        pub const PIN12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xa4);

        /// address: 0x600040a8
        /// GPIO pin configuration register
        pub const PIN13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xa8);

        /// address: 0x600040ac
        /// GPIO pin configuration register
        pub const PIN14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xac);

        /// address: 0x600040b0
        /// GPIO pin configuration register
        pub const PIN15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xb0);

        /// address: 0x600040b4
        /// GPIO pin configuration register
        pub const PIN16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xb4);

        /// address: 0x600040b8
        /// GPIO pin configuration register
        pub const PIN17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xb8);

        /// address: 0x600040bc
        /// GPIO pin configuration register
        pub const PIN18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xbc);

        /// address: 0x600040c0
        /// GPIO pin configuration register
        pub const PIN19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xc0);

        /// address: 0x600040c4
        /// GPIO pin configuration register
        pub const PIN20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xc4);

        /// address: 0x600040c8
        /// GPIO pin configuration register
        pub const PIN21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xc8);

        /// address: 0x600040cc
        /// GPIO pin configuration register
        pub const PIN22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xcc);

        /// address: 0x600040d0
        /// GPIO pin configuration register
        pub const PIN23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xd0);

        /// address: 0x600040d4
        /// GPIO pin configuration register
        pub const PIN24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xd4);

        /// address: 0x600040d8
        /// GPIO pin configuration register
        pub const PIN25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// set GPIO input_sync2 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC2_BYPASS: u2,
            /// set this bit to select pad driver. 1:open-drain. :normal.
            PIN_PAD_DRIVER: u1,
            /// set GPIO input_sync1 signal mode. :disable. 1:trigger at negedge. 2or3:trigger
            /// at posedge.
            PIN_SYNC1_BYPASS: u2,
            reserved0: u1,
            reserved1: u1,
            /// set this value to choose interrupt mode. :disable GPIO interrupt. 1:trigger at
            /// posedge. 2:trigger at negedge. 3:trigger at any edge. 4:valid at low level.
            /// 5:valid at high level
            PIN_INT_TYPE: u3,
            /// set this bit to enable GPIO wakeup.(can only wakeup CPU from Light-sleep Mode)
            PIN_WAKEUP_ENABLE: u1,
            /// reserved
            PIN_CONFIG: u2,
            /// set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not shielded)
            /// interrupt.
            PIN_INT_ENA: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xd8);

        /// address: 0x6000414c
        /// GPIO interrupt source register
        pub const STATUS_NEXT = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO interrupt source register for GPIO0-25
            STATUS_INTERRUPT_NEXT: u26,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x14c);

        /// address: 0x60004154
        /// GPIO input function configuration register
        pub const FUNC0_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x154);

        /// address: 0x60004158
        /// GPIO input function configuration register
        pub const FUNC1_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x158);

        /// address: 0x6000415c
        /// GPIO input function configuration register
        pub const FUNC2_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x15c);

        /// address: 0x60004160
        /// GPIO input function configuration register
        pub const FUNC3_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x160);

        /// address: 0x60004164
        /// GPIO input function configuration register
        pub const FUNC4_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x164);

        /// address: 0x60004168
        /// GPIO input function configuration register
        pub const FUNC5_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x168);

        /// address: 0x6000416c
        /// GPIO input function configuration register
        pub const FUNC6_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x16c);

        /// address: 0x60004170
        /// GPIO input function configuration register
        pub const FUNC7_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x170);

        /// address: 0x60004174
        /// GPIO input function configuration register
        pub const FUNC8_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x174);

        /// address: 0x60004178
        /// GPIO input function configuration register
        pub const FUNC9_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x178);

        /// address: 0x6000417c
        /// GPIO input function configuration register
        pub const FUNC10_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x17c);

        /// address: 0x60004180
        /// GPIO input function configuration register
        pub const FUNC11_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x180);

        /// address: 0x60004184
        /// GPIO input function configuration register
        pub const FUNC12_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x184);

        /// address: 0x60004188
        /// GPIO input function configuration register
        pub const FUNC13_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x188);

        /// address: 0x6000418c
        /// GPIO input function configuration register
        pub const FUNC14_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x18c);

        /// address: 0x60004190
        /// GPIO input function configuration register
        pub const FUNC15_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x190);

        /// address: 0x60004194
        /// GPIO input function configuration register
        pub const FUNC16_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x194);

        /// address: 0x60004198
        /// GPIO input function configuration register
        pub const FUNC17_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x198);

        /// address: 0x6000419c
        /// GPIO input function configuration register
        pub const FUNC18_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x19c);

        /// address: 0x600041a0
        /// GPIO input function configuration register
        pub const FUNC19_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1a0);

        /// address: 0x600041a4
        /// GPIO input function configuration register
        pub const FUNC20_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1a4);

        /// address: 0x600041a8
        /// GPIO input function configuration register
        pub const FUNC21_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1a8);

        /// address: 0x600041ac
        /// GPIO input function configuration register
        pub const FUNC22_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1ac);

        /// address: 0x600041b0
        /// GPIO input function configuration register
        pub const FUNC23_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1b0);

        /// address: 0x600041b4
        /// GPIO input function configuration register
        pub const FUNC24_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1b4);

        /// address: 0x600041b8
        /// GPIO input function configuration register
        pub const FUNC25_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1b8);

        /// address: 0x600041bc
        /// GPIO input function configuration register
        pub const FUNC26_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1bc);

        /// address: 0x600041c0
        /// GPIO input function configuration register
        pub const FUNC27_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1c0);

        /// address: 0x600041c4
        /// GPIO input function configuration register
        pub const FUNC28_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1c4);

        /// address: 0x600041c8
        /// GPIO input function configuration register
        pub const FUNC29_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1c8);

        /// address: 0x600041cc
        /// GPIO input function configuration register
        pub const FUNC30_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1cc);

        /// address: 0x600041d0
        /// GPIO input function configuration register
        pub const FUNC31_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1d0);

        /// address: 0x600041d4
        /// GPIO input function configuration register
        pub const FUNC32_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1d4);

        /// address: 0x600041d8
        /// GPIO input function configuration register
        pub const FUNC33_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1d8);

        /// address: 0x600041dc
        /// GPIO input function configuration register
        pub const FUNC34_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1dc);

        /// address: 0x600041e0
        /// GPIO input function configuration register
        pub const FUNC35_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1e0);

        /// address: 0x600041e4
        /// GPIO input function configuration register
        pub const FUNC36_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1e4);

        /// address: 0x600041e8
        /// GPIO input function configuration register
        pub const FUNC37_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1e8);

        /// address: 0x600041ec
        /// GPIO input function configuration register
        pub const FUNC38_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1ec);

        /// address: 0x600041f0
        /// GPIO input function configuration register
        pub const FUNC39_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1f0);

        /// address: 0x600041f4
        /// GPIO input function configuration register
        pub const FUNC40_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1f4);

        /// address: 0x600041f8
        /// GPIO input function configuration register
        pub const FUNC41_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1f8);

        /// address: 0x600041fc
        /// GPIO input function configuration register
        pub const FUNC42_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1fc);

        /// address: 0x60004200
        /// GPIO input function configuration register
        pub const FUNC43_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x200);

        /// address: 0x60004204
        /// GPIO input function configuration register
        pub const FUNC44_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x204);

        /// address: 0x60004208
        /// GPIO input function configuration register
        pub const FUNC45_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x208);

        /// address: 0x6000420c
        /// GPIO input function configuration register
        pub const FUNC46_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x20c);

        /// address: 0x60004210
        /// GPIO input function configuration register
        pub const FUNC47_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x210);

        /// address: 0x60004214
        /// GPIO input function configuration register
        pub const FUNC48_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x214);

        /// address: 0x60004218
        /// GPIO input function configuration register
        pub const FUNC49_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x218);

        /// address: 0x6000421c
        /// GPIO input function configuration register
        pub const FUNC50_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x21c);

        /// address: 0x60004220
        /// GPIO input function configuration register
        pub const FUNC51_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x220);

        /// address: 0x60004224
        /// GPIO input function configuration register
        pub const FUNC52_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x224);

        /// address: 0x60004228
        /// GPIO input function configuration register
        pub const FUNC53_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x228);

        /// address: 0x6000422c
        /// GPIO input function configuration register
        pub const FUNC54_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x22c);

        /// address: 0x60004230
        /// GPIO input function configuration register
        pub const FUNC55_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x230);

        /// address: 0x60004234
        /// GPIO input function configuration register
        pub const FUNC56_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x234);

        /// address: 0x60004238
        /// GPIO input function configuration register
        pub const FUNC57_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x238);

        /// address: 0x6000423c
        /// GPIO input function configuration register
        pub const FUNC58_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x23c);

        /// address: 0x60004240
        /// GPIO input function configuration register
        pub const FUNC59_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x240);

        /// address: 0x60004244
        /// GPIO input function configuration register
        pub const FUNC60_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x244);

        /// address: 0x60004248
        /// GPIO input function configuration register
        pub const FUNC61_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x248);

        /// address: 0x6000424c
        /// GPIO input function configuration register
        pub const FUNC62_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x24c);

        /// address: 0x60004250
        /// GPIO input function configuration register
        pub const FUNC63_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x250);

        /// address: 0x60004254
        /// GPIO input function configuration register
        pub const FUNC64_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x254);

        /// address: 0x60004258
        /// GPIO input function configuration register
        pub const FUNC65_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x258);

        /// address: 0x6000425c
        /// GPIO input function configuration register
        pub const FUNC66_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x25c);

        /// address: 0x60004260
        /// GPIO input function configuration register
        pub const FUNC67_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x260);

        /// address: 0x60004264
        /// GPIO input function configuration register
        pub const FUNC68_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x264);

        /// address: 0x60004268
        /// GPIO input function configuration register
        pub const FUNC69_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x268);

        /// address: 0x6000426c
        /// GPIO input function configuration register
        pub const FUNC70_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x26c);

        /// address: 0x60004270
        /// GPIO input function configuration register
        pub const FUNC71_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x270);

        /// address: 0x60004274
        /// GPIO input function configuration register
        pub const FUNC72_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x274);

        /// address: 0x60004278
        /// GPIO input function configuration register
        pub const FUNC73_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x278);

        /// address: 0x6000427c
        /// GPIO input function configuration register
        pub const FUNC74_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x27c);

        /// address: 0x60004280
        /// GPIO input function configuration register
        pub const FUNC75_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x280);

        /// address: 0x60004284
        /// GPIO input function configuration register
        pub const FUNC76_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x284);

        /// address: 0x60004288
        /// GPIO input function configuration register
        pub const FUNC77_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x288);

        /// address: 0x6000428c
        /// GPIO input function configuration register
        pub const FUNC78_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x28c);

        /// address: 0x60004290
        /// GPIO input function configuration register
        pub const FUNC79_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x290);

        /// address: 0x60004294
        /// GPIO input function configuration register
        pub const FUNC80_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x294);

        /// address: 0x60004298
        /// GPIO input function configuration register
        pub const FUNC81_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x298);

        /// address: 0x6000429c
        /// GPIO input function configuration register
        pub const FUNC82_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x29c);

        /// address: 0x600042a0
        /// GPIO input function configuration register
        pub const FUNC83_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2a0);

        /// address: 0x600042a4
        /// GPIO input function configuration register
        pub const FUNC84_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2a4);

        /// address: 0x600042a8
        /// GPIO input function configuration register
        pub const FUNC85_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2a8);

        /// address: 0x600042ac
        /// GPIO input function configuration register
        pub const FUNC86_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2ac);

        /// address: 0x600042b0
        /// GPIO input function configuration register
        pub const FUNC87_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2b0);

        /// address: 0x600042b4
        /// GPIO input function configuration register
        pub const FUNC88_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2b4);

        /// address: 0x600042b8
        /// GPIO input function configuration register
        pub const FUNC89_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2b8);

        /// address: 0x600042bc
        /// GPIO input function configuration register
        pub const FUNC90_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2bc);

        /// address: 0x600042c0
        /// GPIO input function configuration register
        pub const FUNC91_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2c0);

        /// address: 0x600042c4
        /// GPIO input function configuration register
        pub const FUNC92_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2c4);

        /// address: 0x600042c8
        /// GPIO input function configuration register
        pub const FUNC93_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2c8);

        /// address: 0x600042cc
        /// GPIO input function configuration register
        pub const FUNC94_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2cc);

        /// address: 0x600042d0
        /// GPIO input function configuration register
        pub const FUNC95_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2d0);

        /// address: 0x600042d4
        /// GPIO input function configuration register
        pub const FUNC96_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2d4);

        /// address: 0x600042d8
        /// GPIO input function configuration register
        pub const FUNC97_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2d8);

        /// address: 0x600042dc
        /// GPIO input function configuration register
        pub const FUNC98_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2dc);

        /// address: 0x600042e0
        /// GPIO input function configuration register
        pub const FUNC99_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2e0);

        /// address: 0x600042e4
        /// GPIO input function configuration register
        pub const FUNC100_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2e4);

        /// address: 0x600042e8
        /// GPIO input function configuration register
        pub const FUNC101_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2e8);

        /// address: 0x600042ec
        /// GPIO input function configuration register
        pub const FUNC102_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2ec);

        /// address: 0x600042f0
        /// GPIO input function configuration register
        pub const FUNC103_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2f0);

        /// address: 0x600042f4
        /// GPIO input function configuration register
        pub const FUNC104_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2f4);

        /// address: 0x600042f8
        /// GPIO input function configuration register
        pub const FUNC105_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2f8);

        /// address: 0x600042fc
        /// GPIO input function configuration register
        pub const FUNC106_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2fc);

        /// address: 0x60004300
        /// GPIO input function configuration register
        pub const FUNC107_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x300);

        /// address: 0x60004304
        /// GPIO input function configuration register
        pub const FUNC108_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x304);

        /// address: 0x60004308
        /// GPIO input function configuration register
        pub const FUNC109_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x308);

        /// address: 0x6000430c
        /// GPIO input function configuration register
        pub const FUNC110_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x30c);

        /// address: 0x60004310
        /// GPIO input function configuration register
        pub const FUNC111_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x310);

        /// address: 0x60004314
        /// GPIO input function configuration register
        pub const FUNC112_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x314);

        /// address: 0x60004318
        /// GPIO input function configuration register
        pub const FUNC113_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x318);

        /// address: 0x6000431c
        /// GPIO input function configuration register
        pub const FUNC114_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x31c);

        /// address: 0x60004320
        /// GPIO input function configuration register
        pub const FUNC115_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x320);

        /// address: 0x60004324
        /// GPIO input function configuration register
        pub const FUNC116_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x324);

        /// address: 0x60004328
        /// GPIO input function configuration register
        pub const FUNC117_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x328);

        /// address: 0x6000432c
        /// GPIO input function configuration register
        pub const FUNC118_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x32c);

        /// address: 0x60004330
        /// GPIO input function configuration register
        pub const FUNC119_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x330);

        /// address: 0x60004334
        /// GPIO input function configuration register
        pub const FUNC120_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x334);

        /// address: 0x60004338
        /// GPIO input function configuration register
        pub const FUNC121_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x338);

        /// address: 0x6000433c
        /// GPIO input function configuration register
        pub const FUNC122_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x33c);

        /// address: 0x60004340
        /// GPIO input function configuration register
        pub const FUNC123_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x340);

        /// address: 0x60004344
        /// GPIO input function configuration register
        pub const FUNC124_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x344);

        /// address: 0x60004348
        /// GPIO input function configuration register
        pub const FUNC125_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x348);

        /// address: 0x6000434c
        /// GPIO input function configuration register
        pub const FUNC126_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x34c);

        /// address: 0x60004350
        /// GPIO input function configuration register
        pub const FUNC127_IN_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this value: s=-53: connect GPIO[s] to this port. s=x38: set this port always
            /// high level. s=x3C: set this port always low level.
            IN_SEL: u5,
            /// set this bit to invert input signal. 1:invert. :not invert.
            IN_INV_SEL: u1,
            /// set this bit to bypass GPIO. 1:do not bypass GPIO. :bypass GPIO.
            SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x350);

        /// address: 0x60004554
        /// GPIO output function select register
        pub const FUNC0_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x554);

        /// address: 0x60004558
        /// GPIO output function select register
        pub const FUNC1_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x558);

        /// address: 0x6000455c
        /// GPIO output function select register
        pub const FUNC2_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x55c);

        /// address: 0x60004560
        /// GPIO output function select register
        pub const FUNC3_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x560);

        /// address: 0x60004564
        /// GPIO output function select register
        pub const FUNC4_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x564);

        /// address: 0x60004568
        /// GPIO output function select register
        pub const FUNC5_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x568);

        /// address: 0x6000456c
        /// GPIO output function select register
        pub const FUNC6_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x56c);

        /// address: 0x60004570
        /// GPIO output function select register
        pub const FUNC7_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x570);

        /// address: 0x60004574
        /// GPIO output function select register
        pub const FUNC8_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x574);

        /// address: 0x60004578
        /// GPIO output function select register
        pub const FUNC9_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x578);

        /// address: 0x6000457c
        /// GPIO output function select register
        pub const FUNC10_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x57c);

        /// address: 0x60004580
        /// GPIO output function select register
        pub const FUNC11_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x580);

        /// address: 0x60004584
        /// GPIO output function select register
        pub const FUNC12_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x584);

        /// address: 0x60004588
        /// GPIO output function select register
        pub const FUNC13_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x588);

        /// address: 0x6000458c
        /// GPIO output function select register
        pub const FUNC14_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x58c);

        /// address: 0x60004590
        /// GPIO output function select register
        pub const FUNC15_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x590);

        /// address: 0x60004594
        /// GPIO output function select register
        pub const FUNC16_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x594);

        /// address: 0x60004598
        /// GPIO output function select register
        pub const FUNC17_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x598);

        /// address: 0x6000459c
        /// GPIO output function select register
        pub const FUNC18_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x59c);

        /// address: 0x600045a0
        /// GPIO output function select register
        pub const FUNC19_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x5a0);

        /// address: 0x600045a4
        /// GPIO output function select register
        pub const FUNC20_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x5a4);

        /// address: 0x600045a8
        /// GPIO output function select register
        pub const FUNC21_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x5a8);

        /// address: 0x600045ac
        /// GPIO output function select register
        pub const FUNC22_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x5ac);

        /// address: 0x600045b0
        /// GPIO output function select register
        pub const FUNC23_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x5b0);

        /// address: 0x600045b4
        /// GPIO output function select register
        pub const FUNC24_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x5b4);

        /// address: 0x600045b8
        /// GPIO output function select register
        pub const FUNC25_OUT_SEL_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of the bits: <=s<=256. Set the value to select output signal. s=-255:
            /// output of GPIO[n] equals input of peripheral[s]. s=256: output of GPIO[n] equals
            /// GPIO_OUT_REG[n].
            OUT_SEL: u8,
            /// set this bit to invert output signal.1:invert.:not invert.
            INV_SEL: u1,
            /// set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n] as output
            /// enable signal.:use peripheral output enable signal.
            OEN_SEL: u1,
            /// set this bit to invert output enable signal.1:invert.:not invert.
            OEN_INV_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x5b8);

        /// address: 0x6000462c
        /// GPIO clock gate register
        pub const CLOCK_GATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this bit to enable GPIO clock gate
            CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x62c);

        /// address: 0x600046fc
        /// GPIO version register
        pub const REG_DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0x6fc);
    };

    /// Sigma-Delta Modulation
    pub const GPIOSD = struct {
        pub const base_address = 0x60004f00;

        /// address: 0x60004f00
        /// Duty Cycle Configure Register of SDM%s
        pub const SIGMADELTA0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This field is used to configure the duty cycle of sigma delta modulation output.
            SD0_IN: u8,
            /// This field is used to set a divider value to divide APB clock.
            SD0_PRESCALE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x60004f04
        /// Duty Cycle Configure Register of SDM%s
        pub const SIGMADELTA1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This field is used to configure the duty cycle of sigma delta modulation output.
            SD0_IN: u8,
            /// This field is used to set a divider value to divide APB clock.
            SD0_PRESCALE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x60004f08
        /// Duty Cycle Configure Register of SDM%s
        pub const SIGMADELTA2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This field is used to configure the duty cycle of sigma delta modulation output.
            SD0_IN: u8,
            /// This field is used to set a divider value to divide APB clock.
            SD0_PRESCALE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x60004f0c
        /// Duty Cycle Configure Register of SDM%s
        pub const SIGMADELTA3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This field is used to configure the duty cycle of sigma delta modulation output.
            SD0_IN: u8,
            /// This field is used to set a divider value to divide APB clock.
            SD0_PRESCALE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x60004f20
        /// Clock Gating Configure Register
        pub const SIGMADELTA_CG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// Clock enable bit of configuration registers for sigma delta modulation.
            CLK_EN: u1,
        }), base_address + 0x20);

        /// address: 0x60004f24
        /// MISC Register
        pub const SIGMADELTA_MISC = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            /// Clock enable bit of sigma delta modulation.
            FUNCTION_CLK_EN: u1,
            /// Reserved.
            SPI_SWAP: u1,
        }), base_address + 0x24);

        /// address: 0x60004f28
        /// Version Control Register
        pub const SIGMADELTA_VERSION = @intToPtr(*volatile Mmio(32, packed struct {
            /// Version control register.
            GPIO_SD_DATE: u28,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x28);
    };

    /// HMAC (Hash-based Message Authentication Code) Accelerator
    pub const HMAC = struct {
        pub const base_address = 0x6003e000;

        /// address: 0x6003e040
        /// Process control register 0.
        pub const SET_START = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x40);

        /// address: 0x6003e044
        /// Configure purpose.
        pub const SET_PARA_PURPOSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set hmac parameter purpose.
            PURPOSE_SET: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x44);

        /// address: 0x6003e048
        /// Configure key.
        pub const SET_PARA_KEY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set hmac parameter key.
            KEY_SET: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x48);

        /// address: 0x6003e04c
        /// Finish initial configuration.
        pub const SET_PARA_FINISH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Finish hmac configuration.
            SET_PARA_END: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x4c);

        /// address: 0x6003e050
        /// Process control register 1.
        pub const SET_MESSAGE_ONE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Call SHA to calculate one message block.
            SET_TEXT_ONE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x50);

        /// address: 0x6003e054
        /// Process control register 2.
        pub const SET_MESSAGE_ING = @intToPtr(*volatile Mmio(32, packed struct {
            /// Continue typical hmac.
            SET_TEXT_ING: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x54);

        /// address: 0x6003e058
        /// Process control register 3.
        pub const SET_MESSAGE_END = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start hardware padding.
            SET_TEXT_END: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x58);

        /// address: 0x6003e05c
        /// Process control register 4.
        pub const SET_RESULT_FINISH = @intToPtr(*volatile Mmio(32, packed struct {
            /// After read result from upstream, then let hmac back to idle.
            SET_RESULT_END: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x5c);

        /// address: 0x6003e060
        /// Invalidate register 0.
        pub const SET_INVALIDATE_JTAG = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x60);

        /// address: 0x6003e064
        /// Invalidate register 1.
        pub const SET_INVALIDATE_DS = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x64);

        /// address: 0x6003e068
        /// Error register.
        pub const QUERY_ERROR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Hmac configuration state. 0: key are agree with purpose. 1: error
            QUREY_CHECK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x68);

        /// address: 0x6003e06c
        /// Busy register.
        pub const QUERY_BUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Hmac state. 1'b0: idle. 1'b1: busy
            BUSY_STATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x6c);

        /// address: 0x6003e080
        /// Message block memory.
        pub const WR_MESSAGE_MEM = @intToPtr(*volatile [64]u8, base_address + 0x80);

        /// address: 0x6003e0c0
        /// Result from upstream.
        pub const RD_RESULT_MEM = @intToPtr(*volatile [32]u8, base_address + 0xc0);

        /// address: 0x6003e0f0
        /// Process control register 5.
        pub const SET_MESSAGE_PAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Start software padding.
            SET_TEXT_PAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xf0);

        /// address: 0x6003e0f4
        /// Process control register 6.
        pub const ONE_BLOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Don't have to do padding.
            SET_ONE_BLOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xf4);

        /// address: 0x6003e0f8
        /// Jtag register 0.
        pub const SOFT_JTAG_CTRL = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xf8);

        /// address: 0x6003e0fc
        /// Jtag register 1.
        pub const WR_JTAG = @intToPtr(*volatile u32, base_address + 0xfc);
    };

    /// I2C (Inter-Integrated Circuit) Controller
    pub const I2C0 = struct {
        pub const base_address = 0x60013000;

        /// address: 0x60013000
        /// I2C_SCL_LOW_PERIOD_REG
        pub const SCL_LOW_PERIOD = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x0);

        /// address: 0x60013004
        /// I2C_CTR_REG
        pub const CTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_sda_force_out
            SDA_FORCE_OUT: u1,
            /// reg_scl_force_out
            SCL_FORCE_OUT: u1,
            /// reg_sample_scl_level
            SAMPLE_SCL_LEVEL: u1,
            /// reg_rx_full_ack_level
            RX_FULL_ACK_LEVEL: u1,
            /// reg_ms_mode
            MS_MODE: u1,
            /// reg_trans_start
            TRANS_START: u1,
            /// reg_tx_lsb_first
            TX_LSB_FIRST: u1,
            /// reg_rx_lsb_first
            RX_LSB_FIRST: u1,
            /// reg_clk_en
            CLK_EN: u1,
            /// reg_arbitration_en
            ARBITRATION_EN: u1,
            /// reg_fsm_rst
            FSM_RST: u1,
            /// reg_conf_upgate
            CONF_UPGATE: u1,
            /// reg_slv_tx_auto_start_en
            SLV_TX_AUTO_START_EN: u1,
            /// reg_addr_10bit_rw_check_en
            ADDR_10BIT_RW_CHECK_EN: u1,
            /// reg_addr_broadcasting_en
            ADDR_BROADCASTING_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x60013008
        /// I2C_SR_REG
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_resp_rec
            RESP_REC: u1,
            /// reg_slave_rw
            SLAVE_RW: u1,
            reserved0: u1,
            /// reg_arb_lost
            ARB_LOST: u1,
            /// reg_bus_busy
            BUS_BUSY: u1,
            /// reg_slave_addressed
            SLAVE_ADDRESSED: u1,
            reserved1: u1,
            reserved2: u1,
            /// reg_rxfifo_cnt
            RXFIFO_CNT: u6,
            /// reg_stretch_cause
            STRETCH_CAUSE: u2,
            reserved3: u1,
            reserved4: u1,
            /// reg_txfifo_cnt
            TXFIFO_CNT: u6,
            /// reg_scl_main_state_last
            SCL_MAIN_STATE_LAST: u3,
            reserved5: u1,
            /// reg_scl_state_last
            SCL_STATE_LAST: u3,
            padding0: u1,
        }), base_address + 0x8);

        /// address: 0x6001300c
        /// I2C_TO_REG
        pub const TO = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_time_out_value
            TIME_OUT_VALUE: u5,
            /// reg_time_out_en
            TIME_OUT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x60013010
        /// I2C_SLAVE_ADDR_REG
        pub const SLAVE_ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_slave_addr
            SLAVE_ADDR: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// reg_addr_10bit_en
            ADDR_10BIT_EN: u1,
        }), base_address + 0x10);

        /// address: 0x60013014
        /// I2C_FIFO_ST_REG
        pub const FIFO_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rxfifo_raddr
            RXFIFO_RADDR: u5,
            /// reg_rxfifo_waddr
            RXFIFO_WADDR: u5,
            /// reg_txfifo_raddr
            TXFIFO_RADDR: u5,
            /// reg_txfifo_waddr
            TXFIFO_WADDR: u5,
            reserved0: u1,
            reserved1: u1,
            /// reg_slave_rw_point
            SLAVE_RW_POINT: u8,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x60013018
        /// I2C_FIFO_CONF_REG
        pub const FIFO_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rxfifo_wm_thrhd
            RXFIFO_WM_THRHD: u5,
            /// reg_txfifo_wm_thrhd
            TXFIFO_WM_THRHD: u5,
            /// reg_nonfifo_en
            NONFIFO_EN: u1,
            /// reg_fifo_addr_cfg_en
            FIFO_ADDR_CFG_EN: u1,
            /// reg_rx_fifo_rst
            RX_FIFO_RST: u1,
            /// reg_tx_fifo_rst
            TX_FIFO_RST: u1,
            /// reg_fifo_prt_en
            FIFO_PRT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x6001301c
        /// I2C_FIFO_DATA_REG
        pub const DATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_fifo_rdata
            FIFO_RDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x60013020
        /// I2C_INT_RAW_REG
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rxfifo_wm_int_raw
            RXFIFO_WM_INT_RAW: u1,
            /// reg_txfifo_wm_int_raw
            TXFIFO_WM_INT_RAW: u1,
            /// reg_rxfifo_ovf_int_raw
            RXFIFO_OVF_INT_RAW: u1,
            /// reg_end_detect_int_raw
            END_DETECT_INT_RAW: u1,
            /// reg_byte_trans_done_int_raw
            BYTE_TRANS_DONE_INT_RAW: u1,
            /// reg_arbitration_lost_int_raw
            ARBITRATION_LOST_INT_RAW: u1,
            /// reg_mst_txfifo_udf_int_raw
            MST_TXFIFO_UDF_INT_RAW: u1,
            /// reg_trans_complete_int_raw
            TRANS_COMPLETE_INT_RAW: u1,
            /// reg_time_out_int_raw
            TIME_OUT_INT_RAW: u1,
            /// reg_trans_start_int_raw
            TRANS_START_INT_RAW: u1,
            /// reg_nack_int_raw
            NACK_INT_RAW: u1,
            /// reg_txfifo_ovf_int_raw
            TXFIFO_OVF_INT_RAW: u1,
            /// reg_rxfifo_udf_int_raw
            RXFIFO_UDF_INT_RAW: u1,
            /// reg_scl_st_to_int_raw
            SCL_ST_TO_INT_RAW: u1,
            /// reg_scl_main_st_to_int_raw
            SCL_MAIN_ST_TO_INT_RAW: u1,
            /// reg_det_start_int_raw
            DET_START_INT_RAW: u1,
            /// reg_slave_stretch_int_raw
            SLAVE_STRETCH_INT_RAW: u1,
            /// reg_general_call_int_raw
            GENERAL_CALL_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x20);

        /// address: 0x60013024
        /// I2C_INT_CLR_REG
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rxfifo_wm_int_clr
            RXFIFO_WM_INT_CLR: u1,
            /// reg_txfifo_wm_int_clr
            TXFIFO_WM_INT_CLR: u1,
            /// reg_rxfifo_ovf_int_clr
            RXFIFO_OVF_INT_CLR: u1,
            /// reg_end_detect_int_clr
            END_DETECT_INT_CLR: u1,
            /// reg_byte_trans_done_int_clr
            BYTE_TRANS_DONE_INT_CLR: u1,
            /// reg_arbitration_lost_int_clr
            ARBITRATION_LOST_INT_CLR: u1,
            /// reg_mst_txfifo_udf_int_clr
            MST_TXFIFO_UDF_INT_CLR: u1,
            /// reg_trans_complete_int_clr
            TRANS_COMPLETE_INT_CLR: u1,
            /// reg_time_out_int_clr
            TIME_OUT_INT_CLR: u1,
            /// reg_trans_start_int_clr
            TRANS_START_INT_CLR: u1,
            /// reg_nack_int_clr
            NACK_INT_CLR: u1,
            /// reg_txfifo_ovf_int_clr
            TXFIFO_OVF_INT_CLR: u1,
            /// reg_rxfifo_udf_int_clr
            RXFIFO_UDF_INT_CLR: u1,
            /// reg_scl_st_to_int_clr
            SCL_ST_TO_INT_CLR: u1,
            /// reg_scl_main_st_to_int_clr
            SCL_MAIN_ST_TO_INT_CLR: u1,
            /// reg_det_start_int_clr
            DET_START_INT_CLR: u1,
            /// reg_slave_stretch_int_clr
            SLAVE_STRETCH_INT_CLR: u1,
            /// reg_general_call_int_clr
            GENERAL_CALL_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x24);

        /// address: 0x60013028
        /// I2C_INT_ENA_REG
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rxfifo_wm_int_ena
            RXFIFO_WM_INT_ENA: u1,
            /// reg_txfifo_wm_int_ena
            TXFIFO_WM_INT_ENA: u1,
            /// reg_rxfifo_ovf_int_ena
            RXFIFO_OVF_INT_ENA: u1,
            /// reg_end_detect_int_ena
            END_DETECT_INT_ENA: u1,
            /// reg_byte_trans_done_int_ena
            BYTE_TRANS_DONE_INT_ENA: u1,
            /// reg_arbitration_lost_int_ena
            ARBITRATION_LOST_INT_ENA: u1,
            /// reg_mst_txfifo_udf_int_ena
            MST_TXFIFO_UDF_INT_ENA: u1,
            /// reg_trans_complete_int_ena
            TRANS_COMPLETE_INT_ENA: u1,
            /// reg_time_out_int_ena
            TIME_OUT_INT_ENA: u1,
            /// reg_trans_start_int_ena
            TRANS_START_INT_ENA: u1,
            /// reg_nack_int_ena
            NACK_INT_ENA: u1,
            /// reg_txfifo_ovf_int_ena
            TXFIFO_OVF_INT_ENA: u1,
            /// reg_rxfifo_udf_int_ena
            RXFIFO_UDF_INT_ENA: u1,
            /// reg_scl_st_to_int_ena
            SCL_ST_TO_INT_ENA: u1,
            /// reg_scl_main_st_to_int_ena
            SCL_MAIN_ST_TO_INT_ENA: u1,
            /// reg_det_start_int_ena
            DET_START_INT_ENA: u1,
            /// reg_slave_stretch_int_ena
            SLAVE_STRETCH_INT_ENA: u1,
            /// reg_general_call_int_ena
            GENERAL_CALL_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x28);

        /// address: 0x6001302c
        /// I2C_INT_STATUS_REG
        pub const INT_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rxfifo_wm_int_st
            RXFIFO_WM_INT_ST: u1,
            /// reg_txfifo_wm_int_st
            TXFIFO_WM_INT_ST: u1,
            /// reg_rxfifo_ovf_int_st
            RXFIFO_OVF_INT_ST: u1,
            /// reg_end_detect_int_st
            END_DETECT_INT_ST: u1,
            /// reg_byte_trans_done_int_st
            BYTE_TRANS_DONE_INT_ST: u1,
            /// reg_arbitration_lost_int_st
            ARBITRATION_LOST_INT_ST: u1,
            /// reg_mst_txfifo_udf_int_st
            MST_TXFIFO_UDF_INT_ST: u1,
            /// reg_trans_complete_int_st
            TRANS_COMPLETE_INT_ST: u1,
            /// reg_time_out_int_st
            TIME_OUT_INT_ST: u1,
            /// reg_trans_start_int_st
            TRANS_START_INT_ST: u1,
            /// reg_nack_int_st
            NACK_INT_ST: u1,
            /// reg_txfifo_ovf_int_st
            TXFIFO_OVF_INT_ST: u1,
            /// reg_rxfifo_udf_int_st
            RXFIFO_UDF_INT_ST: u1,
            /// reg_scl_st_to_int_st
            SCL_ST_TO_INT_ST: u1,
            /// reg_scl_main_st_to_int_st
            SCL_MAIN_ST_TO_INT_ST: u1,
            /// reg_det_start_int_st
            DET_START_INT_ST: u1,
            /// reg_slave_stretch_int_st
            SLAVE_STRETCH_INT_ST: u1,
            /// reg_general_call_int_st
            GENERAL_CALL_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x2c);

        /// address: 0x60013030
        /// I2C_SDA_HOLD_REG
        pub const SDA_HOLD = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_sda_hold_time
            TIME: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x30);

        /// address: 0x60013034
        /// I2C_SDA_SAMPLE_REG
        pub const SDA_SAMPLE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_sda_sample_time
            TIME: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x34);

        /// address: 0x60013038
        /// I2C_SCL_HIGH_PERIOD_REG
        pub const SCL_HIGH_PERIOD = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_scl_high_period
            SCL_HIGH_PERIOD: u9,
            /// reg_scl_wait_high_period
            SCL_WAIT_HIGH_PERIOD: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x60013040
        /// I2C_SCL_START_HOLD_REG
        pub const SCL_START_HOLD = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_scl_start_hold_time
            TIME: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x40);

        /// address: 0x60013044
        /// I2C_SCL_RSTART_SETUP_REG
        pub const SCL_RSTART_SETUP = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_scl_rstart_setup_time
            TIME: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x44);

        /// address: 0x60013048
        /// I2C_SCL_STOP_HOLD_REG
        pub const SCL_STOP_HOLD = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_scl_stop_hold_time
            TIME: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x48);

        /// address: 0x6001304c
        /// I2C_SCL_STOP_SETUP_REG
        pub const SCL_STOP_SETUP = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_scl_stop_setup_time
            TIME: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x4c);

        /// address: 0x60013050
        /// I2C_FILTER_CFG_REG
        pub const FILTER_CFG = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_scl_filter_thres
            SCL_FILTER_THRES: u4,
            /// reg_sda_filter_thres
            SDA_FILTER_THRES: u4,
            /// reg_scl_filter_en
            SCL_FILTER_EN: u1,
            /// reg_sda_filter_en
            SDA_FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x50);

        /// address: 0x60013054
        /// I2C_CLK_CONF_REG
        pub const CLK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_sclk_div_num
            SCLK_DIV_NUM: u8,
            /// reg_sclk_div_a
            SCLK_DIV_A: u6,
            /// reg_sclk_div_b
            SCLK_DIV_B: u6,
            /// reg_sclk_sel
            SCLK_SEL: u1,
            /// reg_sclk_active
            SCLK_ACTIVE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x54);

        /// address: 0x60013058
        /// I2C_COMD%s_REG
        pub const COMD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_command
            COMMAND: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// reg_command_done
            COMMAND_DONE: u1,
        }), base_address + 0x58);

        /// address: 0x6001305c
        /// I2C_COMD%s_REG
        pub const COMD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_command
            COMMAND: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// reg_command_done
            COMMAND_DONE: u1,
        }), base_address + 0x5c);

        /// address: 0x60013060
        /// I2C_COMD%s_REG
        pub const COMD2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_command
            COMMAND: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// reg_command_done
            COMMAND_DONE: u1,
        }), base_address + 0x60);

        /// address: 0x60013064
        /// I2C_COMD%s_REG
        pub const COMD3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_command
            COMMAND: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// reg_command_done
            COMMAND_DONE: u1,
        }), base_address + 0x64);

        /// address: 0x60013068
        /// I2C_COMD%s_REG
        pub const COMD4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_command
            COMMAND: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// reg_command_done
            COMMAND_DONE: u1,
        }), base_address + 0x68);

        /// address: 0x6001306c
        /// I2C_COMD%s_REG
        pub const COMD5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_command
            COMMAND: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// reg_command_done
            COMMAND_DONE: u1,
        }), base_address + 0x6c);

        /// address: 0x60013070
        /// I2C_COMD%s_REG
        pub const COMD6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_command
            COMMAND: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// reg_command_done
            COMMAND_DONE: u1,
        }), base_address + 0x70);

        /// address: 0x60013074
        /// I2C_COMD%s_REG
        pub const COMD7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_command
            COMMAND: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// reg_command_done
            COMMAND_DONE: u1,
        }), base_address + 0x74);

        /// address: 0x60013078
        /// I2C_SCL_ST_TIME_OUT_REG
        pub const SCL_ST_TIME_OUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_scl_st_to_regno more than 23
            SCL_ST_TO_I2C: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x78);

        /// address: 0x6001307c
        /// I2C_SCL_MAIN_ST_TIME_OUT_REG
        pub const SCL_MAIN_ST_TIME_OUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_scl_main_st_to_regno more than 23
            SCL_MAIN_ST_TO_I2C: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x7c);

        /// address: 0x60013080
        /// I2C_SCL_SP_CONF_REG
        pub const SCL_SP_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_scl_rst_slv_en
            SCL_RST_SLV_EN: u1,
            /// reg_scl_rst_slv_num
            SCL_RST_SLV_NUM: u5,
            /// reg_scl_pd_en
            SCL_PD_EN: u1,
            /// reg_sda_pd_en
            SDA_PD_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x80);

        /// address: 0x60013084
        /// I2C_SCL_STRETCH_CONF_REG
        pub const SCL_STRETCH_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_stretch_protect_num
            STRETCH_PROTECT_NUM: u10,
            /// reg_slave_scl_stretch_en
            SLAVE_SCL_STRETCH_EN: u1,
            /// reg_slave_scl_stretch_clr
            SLAVE_SCL_STRETCH_CLR: u1,
            /// reg_slave_byte_ack_ctl_en
            SLAVE_BYTE_ACK_CTL_EN: u1,
            /// reg_slave_byte_ack_lvl
            SLAVE_BYTE_ACK_LVL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x84);

        /// address: 0x600130f8
        /// I2C_DATE_REG
        pub const DATE = @intToPtr(*volatile u32, base_address + 0xf8);

        /// address: 0x60013100
        /// I2C_TXFIFO_START_ADDR_REG
        pub const TXFIFO_START_ADDR = @intToPtr(*volatile u32, base_address + 0x100);

        /// address: 0x60013180
        /// I2C_RXFIFO_START_ADDR_REG
        pub const RXFIFO_START_ADDR = @intToPtr(*volatile u32, base_address + 0x180);
    };

    /// I2S (Inter-IC Sound) Controller
    pub const I2S = struct {
        pub const base_address = 0x6002d000;

        /// address: 0x6002d00c
        /// I2S interrupt raw register, valid in level.
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw interrupt status bit for the i2s_rx_done_int interrupt
            RX_DONE_INT_RAW: u1,
            /// The raw interrupt status bit for the i2s_tx_done_int interrupt
            TX_DONE_INT_RAW: u1,
            /// The raw interrupt status bit for the i2s_rx_hung_int interrupt
            RX_HUNG_INT_RAW: u1,
            /// The raw interrupt status bit for the i2s_tx_hung_int interrupt
            TX_HUNG_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xc);

        /// address: 0x6002d010
        /// I2S interrupt status register.
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The masked interrupt status bit for the i2s_rx_done_int interrupt
            RX_DONE_INT_ST: u1,
            /// The masked interrupt status bit for the i2s_tx_done_int interrupt
            TX_DONE_INT_ST: u1,
            /// The masked interrupt status bit for the i2s_rx_hung_int interrupt
            RX_HUNG_INT_ST: u1,
            /// The masked interrupt status bit for the i2s_tx_hung_int interrupt
            TX_HUNG_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x10);

        /// address: 0x6002d014
        /// I2S interrupt enable register.
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The interrupt enable bit for the i2s_rx_done_int interrupt
            RX_DONE_INT_ENA: u1,
            /// The interrupt enable bit for the i2s_tx_done_int interrupt
            TX_DONE_INT_ENA: u1,
            /// The interrupt enable bit for the i2s_rx_hung_int interrupt
            RX_HUNG_INT_ENA: u1,
            /// The interrupt enable bit for the i2s_tx_hung_int interrupt
            TX_HUNG_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x14);

        /// address: 0x6002d018
        /// I2S interrupt clear register.
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to clear the i2s_rx_done_int interrupt
            RX_DONE_INT_CLR: u1,
            /// Set this bit to clear the i2s_tx_done_int interrupt
            TX_DONE_INT_CLR: u1,
            /// Set this bit to clear the i2s_rx_hung_int interrupt
            RX_HUNG_INT_CLR: u1,
            /// Set this bit to clear the i2s_tx_hung_int interrupt
            TX_HUNG_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x18);

        /// address: 0x6002d020
        /// I2S RX configure register
        pub const RX_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to reset receiver
            RX_RESET: u1,
            /// Set this bit to reset Rx AFIFO
            RX_FIFO_RESET: u1,
            /// Set this bit to start receiving data
            RX_START: u1,
            /// Set this bit to enable slave receiver mode
            RX_SLAVE_MOD: u1,
            reserved0: u1,
            /// Set this bit to enable receiver in mono mode
            RX_MONO: u1,
            reserved1: u1,
            /// I2S Rx byte endian, 1: low addr value to high addr. 0: low addr with low addr
            /// value.
            RX_BIG_ENDIAN: u1,
            /// Set 1 to update I2S RX registers from APB clock domain to I2S RX clock domain.
            /// This bit will be cleared by hardware after update register done.
            RX_UPDATE: u1,
            /// 1: The first channel data value is valid in I2S RX mono mode. 0: The second
            /// channel data value is valid in I2S RX mono mode.
            RX_MONO_FST_VLD: u1,
            /// I2S RX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1
            /// (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress.
            /// &
            RX_PCM_CONF: u2,
            /// Set this bit to bypass Compress/Decompress module for received data.
            RX_PCM_BYPASS: u1,
            /// 0 : I2S Rx only stop when reg_rx_start is cleared. 1: Stop when reg_rx_start is
            /// 0 or in_suc_eof is 1. 2: Stop I2S RX when reg_rx_start is 0 or RX FIFO is full.
            RX_STOP_MODE: u2,
            /// 1: I2S RX left alignment mode. 0: I2S RX right alignment mode.
            RX_LEFT_ALIGN: u1,
            /// 1: store 24 channel bits to 32 bits. 0:store 24 channel bits to 24 bits.
            RX_24_FILL_EN: u1,
            /// 0: WS should be 0 when receiving left channel data, and WS is 1in right channel.
            /// 1: WS should be 1 when receiving left channel data, and WS is 0in right channel.
            RX_WS_IDLE_POL: u1,
            /// I2S Rx bit endian. 1:small endian, the LSB is received first. 0:big endian, the
            /// MSB is received first.
            RX_BIT_ORDER: u1,
            /// 1: Enable I2S TDM Rx mode . 0: Disable.
            RX_TDM_EN: u1,
            /// 1: Enable I2S PDM Rx mode . 0: Disable.
            RX_PDM_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x6002d024
        /// I2S TX configure register
        pub const TX_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to reset transmitter
            TX_RESET: u1,
            /// Set this bit to reset Tx AFIFO
            TX_FIFO_RESET: u1,
            /// Set this bit to start transmitting data
            TX_START: u1,
            /// Set this bit to enable slave transmitter mode
            TX_SLAVE_MOD: u1,
            reserved0: u1,
            /// Set this bit to enable transmitter in mono mode
            TX_MONO: u1,
            /// 1: The value of Left channel data is equal to the value of right channel data in
            /// I2S TX mono mode or TDM channel select mode. 0: The invalid channel data is
            /// reg_i2s_single_data in I2S TX mono mode or TDM channel select mode.
            TX_CHAN_EQUAL: u1,
            /// I2S Tx byte endian, 1: low addr value to high addr. 0: low addr with low addr
            /// value.
            TX_BIG_ENDIAN: u1,
            /// Set 1 to update I2S TX registers from APB clock domain to I2S TX clock domain.
            /// This bit will be cleared by hardware after update register done.
            TX_UPDATE: u1,
            /// 1: The first channel data value is valid in I2S TX mono mode. 0: The second
            /// channel data value is valid in I2S TX mono mode.
            TX_MONO_FST_VLD: u1,
            /// I2S TX compress/decompress configuration bit. & 0 (atol): A-Law decompress, 1
            /// (ltoa) : A-Law compress, 2 (utol) : u-Law decompress, 3 (ltou) : u-Law compress.
            /// &
            TX_PCM_CONF: u2,
            /// Set this bit to bypass Compress/Decompress module for transmitted data.
            TX_PCM_BYPASS: u1,
            /// Set this bit to stop disable output BCK signal and WS signal when tx FIFO is
            /// emtpy
            TX_STOP_EN: u1,
            reserved1: u1,
            /// 1: I2S TX left alignment mode. 0: I2S TX right alignment mode.
            TX_LEFT_ALIGN: u1,
            /// 1: Sent 32 bits in 24 channel bits mode. 0: Sent 24 bits in 24 channel bits mode
            TX_24_FILL_EN: u1,
            /// 0: WS should be 0 when sending left channel data, and WS is 1in right channel.
            /// 1: WS should be 1 when sending left channel data, and WS is 0in right channel.
            TX_WS_IDLE_POL: u1,
            /// I2S Tx bit endian. 1:small endian, the LSB is sent first. 0:big endian, the MSB
            /// is sent first.
            TX_BIT_ORDER: u1,
            /// 1: Enable I2S TDM Tx mode . 0: Disable.
            TX_TDM_EN: u1,
            /// 1: Enable I2S PDM Tx mode . 0: Disable.
            TX_PDM_EN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// I2S transmitter channel mode configuration bits.
            TX_CHAN_MOD: u3,
            /// Enable signal loop back mode with transmitter module and receiver module sharing
            /// the same WS and BCK signals.
            SIG_LOOPBACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x24);

        /// address: 0x6002d028
        /// I2S RX configure register 1
        pub const RX_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The width of rx_ws_out in TDM mode is (I2S_RX_TDM_WS_WIDTH[6:0] +1) * T_bck
            RX_TDM_WS_WIDTH: u7,
            /// Bit clock configuration bits in receiver mode.
            RX_BCK_DIV_NUM: u6,
            /// Set the bits to configure the valid data bit length of I2S receiver channel. 7:
            /// all the valid channel data is in 8-bit-mode. 15: all the valid channel data is
            /// in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the
            /// valid channel data is in 32-bit-mode.
            RX_BITS_MOD: u5,
            /// I2S Rx half sample bits -1.
            RX_HALF_SAMPLE_BITS: u6,
            /// The Rx bit number for each channel minus 1in TDM mode.
            RX_TDM_CHAN_BITS: u5,
            /// Set this bit to enable receiver in Phillips standard mode
            RX_MSB_SHIFT: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x28);

        /// address: 0x6002d02c
        /// I2S TX configure register 1
        pub const TX_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The width of tx_ws_out in TDM mode is (I2S_TX_TDM_WS_WIDTH[6:0] +1) * T_bck
            TX_TDM_WS_WIDTH: u7,
            /// Bit clock configuration bits in transmitter mode.
            TX_BCK_DIV_NUM: u6,
            /// Set the bits to configure the valid data bit length of I2S transmitter channel.
            /// 7: all the valid channel data is in 8-bit-mode. 15: all the valid channel data
            /// is in 16-bit-mode. 23: all the valid channel data is in 24-bit-mode. 31:all the
            /// valid channel data is in 32-bit-mode.
            TX_BITS_MOD: u5,
            /// I2S Tx half sample bits -1.
            TX_HALF_SAMPLE_BITS: u6,
            /// The Tx bit number for each channel minus 1in TDM mode.
            TX_TDM_CHAN_BITS: u5,
            /// Set this bit to enable transmitter in Phillips standard mode
            TX_MSB_SHIFT: u1,
            /// 1: BCK is not delayed to generate pos/neg edge in master mode. 0: BCK is delayed
            /// to generate pos/neg edge in master mode.
            TX_BCK_NO_DLY: u1,
            padding0: u1,
        }), base_address + 0x2c);

        /// address: 0x6002d030
        /// I2S RX clock configure register
        pub const RX_CLKM_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integral I2S clock divider value
            RX_CLKM_DIV_NUM: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// I2S Rx module clock enable signal.
            RX_CLK_ACTIVE: u1,
            /// Select I2S Rx module source clock. 0: no clock. 1: APLL. 2: CLK160. 3:
            /// I2S_MCLK_in.
            RX_CLK_SEL: u2,
            /// 0: UseI2S Tx module clock as I2S_MCLK_OUT. 1: UseI2S Rx module clock as
            /// I2S_MCLK_OUT.
            MCLK_SEL: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x30);

        /// address: 0x6002d034
        /// I2S TX clock configure register
        pub const TX_CLKM_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a). There will
            /// be (a-b) * n-div and b * (n+1)-div. So the average combination will be: for b <=
            /// a/2, z * [x * n-div + (n+1)-div] + y * n-div. For b > a/2, z * [n-div + x *
            /// (n+1)-div] + y * (n+1)-div.
            TX_CLKM_DIV_NUM: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// I2S Tx module clock enable signal.
            TX_CLK_ACTIVE: u1,
            /// Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2: CLK160. 3:
            /// I2S_MCLK_in.
            TX_CLK_SEL: u2,
            /// Set this bit to enable clk gate
            CLK_EN: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x34);

        /// address: 0x6002d038
        /// I2S RX module clock divider configure register
        pub const RX_CLKM_DIV_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2, the value of
            /// I2S_RX_CLKM_DIV_Z is (a-b).
            RX_CLKM_DIV_Z: u9,
            /// For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For b > a/2, the value
            /// of I2S_RX_CLKM_DIV_Y is (a%(a-b)).
            RX_CLKM_DIV_Y: u9,
            /// For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the
            /// value of I2S_RX_CLKM_DIV_X is (a/(a-b)) - 1.
            RX_CLKM_DIV_X: u9,
            /// For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of
            /// I2S_RX_CLKM_DIV_YN1 is 1.
            RX_CLKM_DIV_YN1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x38);

        /// address: 0x6002d03c
        /// I2S TX module clock divider configure register
        pub const TX_CLKM_DIV_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2, the value of
            /// I2S_TX_CLKM_DIV_Z is (a-b).
            TX_CLKM_DIV_Z: u9,
            /// For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For b > a/2, the value
            /// of I2S_TX_CLKM_DIV_Y is (a%(a-b)).
            TX_CLKM_DIV_Y: u9,
            /// For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For b > a/2, the
            /// value of I2S_TX_CLKM_DIV_X is (a/(a-b)) - 1.
            TX_CLKM_DIV_X: u9,
            /// For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b > a/2, the value of
            /// I2S_TX_CLKM_DIV_YN1 is 1.
            TX_CLKM_DIV_YN1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x3c);

        /// address: 0x6002d040
        /// I2S TX PCM2PDM configuration register
        pub const TX_PCM2PDM_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S TX PDM bypass hp filter or not. The option has been removed.
            TX_PDM_HP_BYPASS: u1,
            /// I2S TX PDM OSR2 value
            TX_PDM_SINC_OSR2: u4,
            /// I2S TX PDM prescale for sigmadelta
            TX_PDM_PRESCALE: u8,
            /// I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
            TX_PDM_HP_IN_SHIFT: u2,
            /// I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
            TX_PDM_LP_IN_SHIFT: u2,
            /// I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
            TX_PDM_SINC_IN_SHIFT: u2,
            /// I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2 , 3: x4
            TX_PDM_SIGMADELTA_IN_SHIFT: u2,
            /// I2S TX PDM sigmadelta dither2 value
            TX_PDM_SIGMADELTA_DITHER2: u1,
            /// I2S TX PDM sigmadelta dither value
            TX_PDM_SIGMADELTA_DITHER: u1,
            /// I2S TX PDM dac mode enable
            TX_PDM_DAC_2OUT_EN: u1,
            /// I2S TX PDM dac 2channel enable
            TX_PDM_DAC_MODE_EN: u1,
            /// I2S TX PDM Converter enable
            PCM2PDM_CONV_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x40);

        /// address: 0x6002d044
        /// I2S TX PCM2PDM configuration register
        pub const TX_PCM2PDM_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S TX PDM Fp
            TX_PDM_FP: u10,
            /// I2S TX PDM Fs
            TX_PDM_FS: u10,
            /// The fourth parameter of PDM TX IIR_HP filter stage 2 is (504 +
            /// I2S_TX_IIR_HP_MULT12_5[2:0])
            TX_IIR_HP_MULT12_5: u3,
            /// The fourth parameter of PDM TX IIR_HP filter stage 1 is (504 +
            /// I2S_TX_IIR_HP_MULT12_0[2:0])
            TX_IIR_HP_MULT12_0: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x44);

        /// address: 0x6002d050
        /// I2S TX TDM mode control register
        pub const RX_TDM_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: Enable the valid data input of I2S RX TDM or PDM channel 0. 0: Disable, just
            /// input 0 in this channel.
            RX_TDM_PDM_CHAN0_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM or PDM channel 1. 0: Disable, just
            /// input 0 in this channel.
            RX_TDM_PDM_CHAN1_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM or PDM channel 2. 0: Disable, just
            /// input 0 in this channel.
            RX_TDM_PDM_CHAN2_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM or PDM channel 3. 0: Disable, just
            /// input 0 in this channel.
            RX_TDM_PDM_CHAN3_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM or PDM channel 4. 0: Disable, just
            /// input 0 in this channel.
            RX_TDM_PDM_CHAN4_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM or PDM channel 5. 0: Disable, just
            /// input 0 in this channel.
            RX_TDM_PDM_CHAN5_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM or PDM channel 6. 0: Disable, just
            /// input 0 in this channel.
            RX_TDM_PDM_CHAN6_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM or PDM channel 7. 0: Disable, just
            /// input 0 in this channel.
            RX_TDM_PDM_CHAN7_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM channel 8. 0: Disable, just input 0
            /// in this channel.
            RX_TDM_CHAN8_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM channel 9. 0: Disable, just input 0
            /// in this channel.
            RX_TDM_CHAN9_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM channel 10. 0: Disable, just input
            /// 0 in this channel.
            RX_TDM_CHAN10_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM channel 11. 0: Disable, just input
            /// 0 in this channel.
            RX_TDM_CHAN11_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM channel 12. 0: Disable, just input
            /// 0 in this channel.
            RX_TDM_CHAN12_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM channel 13. 0: Disable, just input
            /// 0 in this channel.
            RX_TDM_CHAN13_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM channel 14. 0: Disable, just input
            /// 0 in this channel.
            RX_TDM_CHAN14_EN: u1,
            /// 1: Enable the valid data input of I2S RX TDM channel 15. 0: Disable, just input
            /// 0 in this channel.
            RX_TDM_CHAN15_EN: u1,
            /// The total channel number of I2S TX TDM mode.
            RX_TDM_TOT_CHAN_NUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x50);

        /// address: 0x6002d054
        /// I2S TX TDM mode control register
        pub const TX_TDM_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: Enable the valid data output of I2S TX TDM channel 0. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN0_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 1. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN1_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 2. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN2_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 3. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN3_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 4. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN4_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 5. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN5_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 6. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN6_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 7. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN7_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 8. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN8_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 9. 0: Disable, just output
            /// 0 in this channel.
            TX_TDM_CHAN9_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 10. 0: Disable, just
            /// output 0 in this channel.
            TX_TDM_CHAN10_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 11. 0: Disable, just
            /// output 0 in this channel.
            TX_TDM_CHAN11_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 12. 0: Disable, just
            /// output 0 in this channel.
            TX_TDM_CHAN12_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 13. 0: Disable, just
            /// output 0 in this channel.
            TX_TDM_CHAN13_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 14. 0: Disable, just
            /// output 0 in this channel.
            TX_TDM_CHAN14_EN: u1,
            /// 1: Enable the valid data output of I2S TX TDM channel 15. 0: Disable, just
            /// output 0 in this channel.
            TX_TDM_CHAN15_EN: u1,
            /// The total channel number of I2S TX TDM mode.
            TX_TDM_TOT_CHAN_NUM: u4,
            /// When DMA TX buffer stores the data of (REG_TX_TDM_TOT_CHAN_NUM + 1) channels,
            /// and only the data of the enabled channels is sent, then this bit should be set.
            /// Clear it when all the data stored in DMA TX buffer is for enabled channels.
            TX_TDM_SKIP_MSK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x54);

        /// address: 0x6002d058
        /// I2S RX timing control register
        pub const RX_TIMING = @intToPtr(*volatile Mmio(32, packed struct {
            /// The delay mode of I2S Rx SD input signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            RX_SD_IN_DM: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// The delay mode of I2S Rx WS output signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            RX_WS_OUT_DM: u2,
            reserved14: u1,
            reserved15: u1,
            /// The delay mode of I2S Rx BCK output signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            RX_BCK_OUT_DM: u2,
            reserved16: u1,
            reserved17: u1,
            /// The delay mode of I2S Rx WS input signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            RX_WS_IN_DM: u2,
            reserved18: u1,
            reserved19: u1,
            /// The delay mode of I2S Rx BCK input signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            RX_BCK_IN_DM: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x58);

        /// address: 0x6002d05c
        /// I2S TX timing control register
        pub const TX_TIMING = @intToPtr(*volatile Mmio(32, packed struct {
            /// The delay mode of I2S TX SD output signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            TX_SD_OUT_DM: u2,
            reserved0: u1,
            reserved1: u1,
            /// The delay mode of I2S TX SD1 output signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            TX_SD1_OUT_DM: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// The delay mode of I2S TX WS output signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            TX_WS_OUT_DM: u2,
            reserved12: u1,
            reserved13: u1,
            /// The delay mode of I2S TX BCK output signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            TX_BCK_OUT_DM: u2,
            reserved14: u1,
            reserved15: u1,
            /// The delay mode of I2S TX WS input signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            TX_WS_IN_DM: u2,
            reserved16: u1,
            reserved17: u1,
            /// The delay mode of I2S TX BCK input signal. 0: bypass. 1: delay by pos edge. 2:
            /// delay by neg edge. 3: not used.
            TX_BCK_IN_DM: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x5c);

        /// address: 0x6002d060
        /// I2S HUNG configure register.
        pub const LC_HUNG_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// the i2s_tx_hung_int interrupt or the i2s_rx_hung_int interrupt will be triggered
            /// when fifo hung counter is equal to this value
            LC_FIFO_TIMEOUT: u8,
            /// The bits are used to scale tick counter threshold. The tick counter is reset
            /// when counter value >= 88000/2^i2s_lc_fifo_timeout_shift
            LC_FIFO_TIMEOUT_SHIFT: u3,
            /// The enable bit for FIFO timeout
            LC_FIFO_TIMEOUT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x60);

        /// address: 0x6002d064
        /// I2S RX data number control register.
        pub const RXEOF_NUM = @intToPtr(*volatile Mmio(32, packed struct {
            /// The receive data bit length is (I2S_RX_BITS_MOD[4:0] + 1) *
            /// (REG_RX_EOF_NUM[11:0] + 1) . It will trigger in_suc_eof interrupt in the
            /// configured DMA RX channel.
            RX_EOF_NUM: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x64);

        /// address: 0x6002d068
        /// I2S signal data register
        pub const CONF_SIGLE_DATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The configured constant channel data to be sent out.
            SINGLE_DATA: u32,
        }), base_address + 0x68);

        /// address: 0x6002d06c
        /// I2S TX status register
        pub const STATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: i2s_tx is idle state. 0: i2s_tx is working.
            TX_IDLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x6c);

        /// address: 0x6002d080
        /// Version control register
        pub const DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0x80);
    };

    /// Interrupt Core
    pub const INTERRUPT_CORE0 = struct {
        pub const base_address = 0x600c2000;

        /// address: 0x600c2000
        /// mac intr map register
        pub const MAC_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x0);

        /// address: 0x600c2004
        /// mac nmi_intr map register
        pub const MAC_NMI_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x4);

        /// address: 0x600c2008
        /// pwr intr map register
        pub const PWR_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x8);

        /// address: 0x600c200c
        /// bb intr map register
        pub const BB_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xc);

        /// address: 0x600c2010
        /// bt intr map register
        pub const BT_MAC_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x10);

        /// address: 0x600c2014
        /// bb_bt intr map register
        pub const BT_BB_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x14);

        /// address: 0x600c2018
        /// bb_bt_nmi intr map register
        pub const BT_BB_NMI_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x18);

        /// address: 0x600c201c
        /// rwbt intr map register
        pub const RWBT_IRQ_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x1c);

        /// address: 0x600c2020
        /// rwble intr map register
        pub const RWBLE_IRQ_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x20);

        /// address: 0x600c2024
        /// rwbt_nmi intr map register
        pub const RWBT_NMI_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x24);

        /// address: 0x600c2028
        /// rwble_nmi intr map register
        pub const RWBLE_NMI_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x28);

        /// address: 0x600c202c
        /// i2c intr map register
        pub const I2C_MST_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x2c);

        /// address: 0x600c2030
        /// slc0 intr map register
        pub const SLC0_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x30);

        /// address: 0x600c2034
        /// slc1 intr map register
        pub const SLC1_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x34);

        /// address: 0x600c2038
        /// apb_ctrl intr map register
        pub const APB_CTRL_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x38);

        /// address: 0x600c203c
        /// uchi0 intr map register
        pub const UHCI0_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x3c);

        /// address: 0x600c2040
        /// gpio intr map register
        pub const GPIO_INTERRUPT_PRO_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x40);

        /// address: 0x600c2044
        /// gpio_pro intr map register
        pub const GPIO_INTERRUPT_PRO_NMI_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x44);

        /// address: 0x600c2048
        /// gpio_pro_nmi intr map register
        pub const SPI_INTR_1_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x48);

        /// address: 0x600c204c
        /// spi1 intr map register
        pub const SPI_INTR_2_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x4c);

        /// address: 0x600c2050
        /// spi2 intr map register
        pub const I2S1_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x50);

        /// address: 0x600c2054
        /// i2s1 intr map register
        pub const UART_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x54);

        /// address: 0x600c2058
        /// uart1 intr map register
        pub const UART1_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x58);

        /// address: 0x600c205c
        /// ledc intr map register
        pub const LEDC_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x5c);

        /// address: 0x600c2060
        /// efuse intr map register
        pub const EFUSE_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x60);

        /// address: 0x600c2064
        /// can intr map register
        pub const CAN_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x64);

        /// address: 0x600c2068
        /// usb intr map register
        pub const USB_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x68);

        /// address: 0x600c206c
        /// rtc intr map register
        pub const RTC_CORE_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x6c);

        /// address: 0x600c2070
        /// rmt intr map register
        pub const RMT_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x70);

        /// address: 0x600c2074
        /// i2c intr map register
        pub const I2C_EXT0_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x74);

        /// address: 0x600c2078
        /// timer1 intr map register
        pub const TIMER_INT1_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x78);

        /// address: 0x600c207c
        /// timer2 intr map register
        pub const TIMER_INT2_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x7c);

        /// address: 0x600c2080
        /// tg to intr map register
        pub const TG_T0_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x80);

        /// address: 0x600c2084
        /// tg wdt intr map register
        pub const TG_WDT_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x84);

        /// address: 0x600c2088
        /// tg1 to intr map register
        pub const TG1_T0_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x88);

        /// address: 0x600c208c
        /// tg1 wdt intr map register
        pub const TG1_WDT_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x8c);

        /// address: 0x600c2090
        /// cache ia intr map register
        pub const CACHE_IA_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x90);

        /// address: 0x600c2094
        /// systimer intr map register
        pub const SYSTIMER_TARGET0_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x94);

        /// address: 0x600c2098
        /// systimer target1 intr map register
        pub const SYSTIMER_TARGET1_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x98);

        /// address: 0x600c209c
        /// systimer target2 intr map register
        pub const SYSTIMER_TARGET2_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x9c);

        /// address: 0x600c20a0
        /// spi mem reject intr map register
        pub const SPI_MEM_REJECT_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xa0);

        /// address: 0x600c20a4
        /// icache perload intr map register
        pub const ICACHE_PRELOAD_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xa4);

        /// address: 0x600c20a8
        /// icache sync intr map register
        pub const ICACHE_SYNC_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xa8);

        /// address: 0x600c20ac
        /// adc intr map register
        pub const APB_ADC_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xac);

        /// address: 0x600c20b0
        /// dma ch0 intr map register
        pub const DMA_CH0_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xb0);

        /// address: 0x600c20b4
        /// dma ch1 intr map register
        pub const DMA_CH1_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xb4);

        /// address: 0x600c20b8
        /// dma ch2 intr map register
        pub const DMA_CH2_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xb8);

        /// address: 0x600c20bc
        /// rsa intr map register
        pub const RSA_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xbc);

        /// address: 0x600c20c0
        /// aes intr map register
        pub const AES_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xc0);

        /// address: 0x600c20c4
        /// sha intr map register
        pub const SHA_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xc4);

        /// address: 0x600c20c8
        /// cpu from cpu 0 intr map register
        pub const CPU_INTR_FROM_CPU_0_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xc8);

        /// address: 0x600c20cc
        /// cpu from cpu 0 intr map register
        pub const CPU_INTR_FROM_CPU_1_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xcc);

        /// address: 0x600c20d0
        /// cpu from cpu 1 intr map register
        pub const CPU_INTR_FROM_CPU_2_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xd0);

        /// address: 0x600c20d4
        /// cpu from cpu 3 intr map register
        pub const CPU_INTR_FROM_CPU_3_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xd4);

        /// address: 0x600c20d8
        /// assist debug intr map register
        pub const ASSIST_DEBUG_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xd8);

        /// address: 0x600c20dc
        /// dma pms violatile intr map register
        pub const DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xdc);

        /// address: 0x600c20e0
        /// iram0 pms violatile intr map register
        pub const CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xe0);

        /// address: 0x600c20e4
        /// mac intr map register
        pub const CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xe4);

        /// address: 0x600c20e8
        /// mac intr map register
        pub const CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xe8);

        /// address: 0x600c20ec
        /// mac intr map register
        pub const CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xec);

        /// address: 0x600c20f0
        /// mac intr map register
        pub const BACKUP_PMS_VIOLATE_INTR_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xf0);

        /// address: 0x600c20f4
        /// mac intr map register
        pub const CACHE_CORE0_ACS_INT_MAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0xf4);

        /// address: 0x600c20f8
        /// mac intr map register
        pub const INTR_STATUS_REG_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_intr_status_0
            INTR_STATUS_0: u32,
        }), base_address + 0xf8);

        /// address: 0x600c20fc
        /// mac intr map register
        pub const INTR_STATUS_REG_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_intr_status_1
            INTR_STATUS_1: u32,
        }), base_address + 0xfc);

        /// address: 0x600c2100
        /// mac intr map register
        pub const CLOCK_GATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_reg_clk_en
            REG_CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x100);

        /// address: 0x600c2104
        /// mac intr map register
        pub const CPU_INT_ENABLE = @intToPtr(*volatile u32, base_address + 0x104);

        /// address: 0x600c2108
        /// mac intr map register
        pub const CPU_INT_TYPE = @intToPtr(*volatile u32, base_address + 0x108);

        /// address: 0x600c210c
        /// mac intr map register
        pub const CPU_INT_CLEAR = @intToPtr(*volatile u32, base_address + 0x10c);

        /// address: 0x600c2110
        /// mac intr map register
        pub const CPU_INT_EIP_STATUS = @intToPtr(*volatile u32, base_address + 0x110);

        /// address: 0x600c2114
        /// mac intr map register
        pub const CPU_INT_PRI_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_0_map
            CPU_PRI_0_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x114);

        /// address: 0x600c2118
        /// mac intr map register
        pub const CPU_INT_PRI_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_1_map
            CPU_PRI_1_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x118);

        /// address: 0x600c211c
        /// mac intr map register
        pub const CPU_INT_PRI_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_2_map
            CPU_PRI_2_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x11c);

        /// address: 0x600c2120
        /// mac intr map register
        pub const CPU_INT_PRI_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_3_map
            CPU_PRI_3_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x120);

        /// address: 0x600c2124
        /// mac intr map register
        pub const CPU_INT_PRI_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_4_map
            CPU_PRI_4_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x124);

        /// address: 0x600c2128
        /// mac intr map register
        pub const CPU_INT_PRI_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_5_map
            CPU_PRI_5_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x128);

        /// address: 0x600c212c
        /// mac intr map register
        pub const CPU_INT_PRI_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_6_map
            CPU_PRI_6_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x12c);

        /// address: 0x600c2130
        /// mac intr map register
        pub const CPU_INT_PRI_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_7_map
            CPU_PRI_7_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x130);

        /// address: 0x600c2134
        /// mac intr map register
        pub const CPU_INT_PRI_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_8_map
            CPU_PRI_8_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x134);

        /// address: 0x600c2138
        /// mac intr map register
        pub const CPU_INT_PRI_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_9_map
            CPU_PRI_9_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x138);

        /// address: 0x600c213c
        /// mac intr map register
        pub const CPU_INT_PRI_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_10_map
            CPU_PRI_10_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x13c);

        /// address: 0x600c2140
        /// mac intr map register
        pub const CPU_INT_PRI_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_11_map
            CPU_PRI_11_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x140);

        /// address: 0x600c2144
        /// mac intr map register
        pub const CPU_INT_PRI_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_12_map
            CPU_PRI_12_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x144);

        /// address: 0x600c2148
        /// mac intr map register
        pub const CPU_INT_PRI_13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_13_map
            CPU_PRI_13_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x148);

        /// address: 0x600c214c
        /// mac intr map register
        pub const CPU_INT_PRI_14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_14_map
            CPU_PRI_14_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x14c);

        /// address: 0x600c2150
        /// mac intr map register
        pub const CPU_INT_PRI_15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_15_map
            CPU_PRI_15_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x150);

        /// address: 0x600c2154
        /// mac intr map register
        pub const CPU_INT_PRI_16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_16_map
            CPU_PRI_16_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x154);

        /// address: 0x600c2158
        /// mac intr map register
        pub const CPU_INT_PRI_17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_17_map
            CPU_PRI_17_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x158);

        /// address: 0x600c215c
        /// mac intr map register
        pub const CPU_INT_PRI_18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_18_map
            CPU_PRI_18_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x15c);

        /// address: 0x600c2160
        /// mac intr map register
        pub const CPU_INT_PRI_19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_19_map
            CPU_PRI_19_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x160);

        /// address: 0x600c2164
        /// mac intr map register
        pub const CPU_INT_PRI_20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_20_map
            CPU_PRI_20_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x164);

        /// address: 0x600c2168
        /// mac intr map register
        pub const CPU_INT_PRI_21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_21_map
            CPU_PRI_21_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x168);

        /// address: 0x600c216c
        /// mac intr map register
        pub const CPU_INT_PRI_22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_22_map
            CPU_PRI_22_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x16c);

        /// address: 0x600c2170
        /// mac intr map register
        pub const CPU_INT_PRI_23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_23_map
            CPU_PRI_23_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x170);

        /// address: 0x600c2174
        /// mac intr map register
        pub const CPU_INT_PRI_24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_24_map
            CPU_PRI_24_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x174);

        /// address: 0x600c2178
        /// mac intr map register
        pub const CPU_INT_PRI_25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_25_map
            CPU_PRI_25_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x178);

        /// address: 0x600c217c
        /// mac intr map register
        pub const CPU_INT_PRI_26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_26_map
            CPU_PRI_26_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x17c);

        /// address: 0x600c2180
        /// mac intr map register
        pub const CPU_INT_PRI_27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_27_map
            CPU_PRI_27_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x180);

        /// address: 0x600c2184
        /// mac intr map register
        pub const CPU_INT_PRI_28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_28_map
            CPU_PRI_28_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x184);

        /// address: 0x600c2188
        /// mac intr map register
        pub const CPU_INT_PRI_29 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_29_map
            CPU_PRI_29_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x188);

        /// address: 0x600c218c
        /// mac intr map register
        pub const CPU_INT_PRI_30 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_30_map
            CPU_PRI_30_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x18c);

        /// address: 0x600c2190
        /// mac intr map register
        pub const CPU_INT_PRI_31 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_core0_cpu_pri_31_map
            CPU_PRI_31_MAP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x190);

        /// address: 0x600c2194
        /// mac intr map register
        pub const CPU_INT_THRESH = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x194);

        /// address: 0x600c27fc
        /// mac intr map register
        pub const INTERRUPT_REG_DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0x7fc);
    };

    /// Input/Output Multiplexer
    pub const IO_MUX = struct {
        pub const base_address = 0x60009000;

        /// address: 0x60009000
        /// Clock Output Configuration Register
        pub const PIN_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// If you want to output clock for I2S to CLK_OUT_out1, set this register to 0x0.
            /// CLK_OUT_out1 can be found in peripheral output signals.
            CLK_OUT1: u4,
            /// If you want to output clock for I2S to CLK_OUT_out2, set this register to 0x0.
            /// CLK_OUT_out2 can be found in peripheral output signals.
            CLK_OUT2: u4,
            /// If you want to output clock for I2S to CLK_OUT_out3, set this register to 0x0.
            /// CLK_OUT_out3 can be found in peripheral output signals.
            CLK_OUT3: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x60009004
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x60009008
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x6000900c
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x60009010
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x60009014
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x60009018
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x6000901c
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x60009020
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x60009024
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x60009028
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x6000902c
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x60009030
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);

        /// address: 0x60009034
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x60009038
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x6000903c
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x60009040
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x60009044
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x60009048
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x6000904c
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x60009050
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x50);

        /// address: 0x60009054
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x54);

        /// address: 0x60009058
        /// IO MUX Configure Register for pad XTAL_32K_P
        pub const GPIO21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Output enable of the pad in sleep mode. 1: output enabled; 0: output disabled.
            MCU_OE: u1,
            /// Sleep mode selection of this pad. Set to 1 to put the pad in pad mode.
            SLP_SEL: u1,
            /// Pull-down enable of the pad in sleep mode. 1: internal pull-down enabled; 0:
            /// internal pull-down disabled.
            MCU_WPD: u1,
            /// Pull-up enable of the pad during sleep mode. 1: internal pull-up enabled; 0:
            /// internal pull-up disabled.
            MCU_WPU: u1,
            /// Input enable of the pad during sleep mode. 1: input enabled; 0: input disabled.
            MCU_IE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
            /// pull-down disabled.
            FUN_WPD: u1,
            /// Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up
            /// disabled.
            FUN_WPU: u1,
            /// Input enable of the pad. 1: input enabled; 0: input disabled.
            FUN_IE: u1,
            /// Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2: ~20mA; 3: ~40mA.
            FUN_DRV: u2,
            /// Select IO MUX function for this signal. 0: Select Function 1; 1: Select Function
            /// 2; etc.
            MCU_SEL: u3,
            /// Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled.
            FILTER_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);

        /// address: 0x600090fc
        /// IO MUX Version Control Register
        pub const DATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Version control register
            REG_DATE: u28,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xfc);
    };

    /// LED Control PWM (Pulse Width Modulation)
    pub const LEDC = struct {
        pub const base_address = 0x60019000;

        /// address: 0x60019000
        /// LEDC_LSCH0_CONF0.
        pub const LSCH0_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_timer_sel_lsch0.
            TIMER_SEL_LSCH0: u2,
            /// reg_sig_out_en_lsch0.
            SIG_OUT_EN_LSCH0: u1,
            /// reg_idle_lv_lsch0.
            IDLE_LV_LSCH0: u1,
            /// reg_para_up_lsch0.
            PARA_UP_LSCH0: u1,
            /// reg_ovf_num_lsch0.
            OVF_NUM_LSCH0: u10,
            /// reg_ovf_cnt_en_lsch0.
            OVF_CNT_EN_LSCH0: u1,
            /// reg_ovf_cnt_reset_lsch0.
            OVF_CNT_RESET_LSCH0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x60019004
        /// LEDC_LSCH0_HPOINT.
        pub const LSCH0_HPOINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_hpoint_lsch0.
            HPOINT_LSCH0: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x4);

        /// address: 0x60019008
        /// LEDC_LSCH0_DUTY.
        pub const LSCH0_DUTY = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch0.
            DUTY_LSCH0: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x8);

        /// address: 0x6001900c
        /// LEDC_LSCH0_CONF1.
        pub const LSCH0_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_scale_lsch0.
            DUTY_SCALE_LSCH0: u10,
            /// reg_duty_cycle_lsch0.
            DUTY_CYCLE_LSCH0: u10,
            /// reg_duty_num_lsch0.
            DUTY_NUM_LSCH0: u10,
            /// reg_duty_inc_lsch0.
            DUTY_INC_LSCH0: u1,
            /// reg_duty_start_lsch0.
            DUTY_START_LSCH0: u1,
        }), base_address + 0xc);

        /// address: 0x60019010
        /// LEDC_LSCH0_DUTY_R.
        pub const LSCH0_DUTY_R = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch0_r.
            DUTY_LSCH0_R: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x10);

        /// address: 0x60019014
        /// LEDC_LSCH1_CONF0.
        pub const LSCH1_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_timer_sel_lsch1.
            TIMER_SEL_LSCH1: u2,
            /// reg_sig_out_en_lsch1.
            SIG_OUT_EN_LSCH1: u1,
            /// reg_idle_lv_lsch1.
            IDLE_LV_LSCH1: u1,
            /// reg_para_up_lsch1.
            PARA_UP_LSCH1: u1,
            /// reg_ovf_num_lsch1.
            OVF_NUM_LSCH1: u10,
            /// reg_ovf_cnt_en_lsch1.
            OVF_CNT_EN_LSCH1: u1,
            /// reg_ovf_cnt_reset_lsch1.
            OVF_CNT_RESET_LSCH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x14);

        /// address: 0x60019018
        /// LEDC_LSCH1_HPOINT.
        pub const LSCH1_HPOINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_hpoint_lsch1.
            HPOINT_LSCH1: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x18);

        /// address: 0x6001901c
        /// LEDC_LSCH1_DUTY.
        pub const LSCH1_DUTY = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch1.
            DUTY_LSCH1: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x1c);

        /// address: 0x60019020
        /// LEDC_LSCH1_CONF1.
        pub const LSCH1_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_scale_lsch1.
            DUTY_SCALE_LSCH1: u10,
            /// reg_duty_cycle_lsch1.
            DUTY_CYCLE_LSCH1: u10,
            /// reg_duty_num_lsch1.
            DUTY_NUM_LSCH1: u10,
            /// reg_duty_inc_lsch1.
            DUTY_INC_LSCH1: u1,
            /// reg_duty_start_lsch1.
            DUTY_START_LSCH1: u1,
        }), base_address + 0x20);

        /// address: 0x60019024
        /// LEDC_LSCH1_DUTY_R.
        pub const LSCH1_DUTY_R = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch1_r.
            DUTY_LSCH1_R: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x24);

        /// address: 0x60019028
        /// LEDC_LSCH2_CONF0.
        pub const LSCH2_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_timer_sel_lsch2.
            TIMER_SEL_LSCH2: u2,
            /// reg_sig_out_en_lsch2.
            SIG_OUT_EN_LSCH2: u1,
            /// reg_idle_lv_lsch2.
            IDLE_LV_LSCH2: u1,
            /// reg_para_up_lsch2.
            PARA_UP_LSCH2: u1,
            /// reg_ovf_num_lsch2.
            OVF_NUM_LSCH2: u10,
            /// reg_ovf_cnt_en_lsch2.
            OVF_CNT_EN_LSCH2: u1,
            /// reg_ovf_cnt_reset_lsch2.
            OVF_CNT_RESET_LSCH2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x28);

        /// address: 0x6001902c
        /// LEDC_LSCH2_HPOINT.
        pub const LSCH2_HPOINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_hpoint_lsch2.
            HPOINT_LSCH2: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x2c);

        /// address: 0x60019030
        /// LEDC_LSCH2_DUTY.
        pub const LSCH2_DUTY = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch2.
            DUTY_LSCH2: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x30);

        /// address: 0x60019034
        /// LEDC_LSCH2_CONF1.
        pub const LSCH2_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_scale_lsch2.
            DUTY_SCALE_LSCH2: u10,
            /// reg_duty_cycle_lsch2.
            DUTY_CYCLE_LSCH2: u10,
            /// reg_duty_num_lsch2.
            DUTY_NUM_LSCH2: u10,
            /// reg_duty_inc_lsch2.
            DUTY_INC_LSCH2: u1,
            /// reg_duty_start_lsch2.
            DUTY_START_LSCH2: u1,
        }), base_address + 0x34);

        /// address: 0x60019038
        /// LEDC_LSCH2_DUTY_R.
        pub const LSCH2_DUTY_R = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch2_r.
            DUTY_LSCH2_R: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x38);

        /// address: 0x6001903c
        /// LEDC_LSCH3_CONF0.
        pub const LSCH3_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_timer_sel_lsch3.
            TIMER_SEL_LSCH3: u2,
            /// reg_sig_out_en_lsch3.
            SIG_OUT_EN_LSCH3: u1,
            /// reg_idle_lv_lsch3.
            IDLE_LV_LSCH3: u1,
            /// reg_para_up_lsch3.
            PARA_UP_LSCH3: u1,
            /// reg_ovf_num_lsch3.
            OVF_NUM_LSCH3: u10,
            /// reg_ovf_cnt_en_lsch3.
            OVF_CNT_EN_LSCH3: u1,
            /// reg_ovf_cnt_reset_lsch3.
            OVF_CNT_RESET_LSCH3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x3c);

        /// address: 0x60019040
        /// LEDC_LSCH3_HPOINT.
        pub const LSCH3_HPOINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_hpoint_lsch3.
            HPOINT_LSCH3: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x40);

        /// address: 0x60019044
        /// LEDC_LSCH3_DUTY.
        pub const LSCH3_DUTY = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch3.
            DUTY_LSCH3: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x44);

        /// address: 0x60019048
        /// LEDC_LSCH3_CONF1.
        pub const LSCH3_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_scale_lsch3.
            DUTY_SCALE_LSCH3: u10,
            /// reg_duty_cycle_lsch3.
            DUTY_CYCLE_LSCH3: u10,
            /// reg_duty_num_lsch3.
            DUTY_NUM_LSCH3: u10,
            /// reg_duty_inc_lsch3.
            DUTY_INC_LSCH3: u1,
            /// reg_duty_start_lsch3.
            DUTY_START_LSCH3: u1,
        }), base_address + 0x48);

        /// address: 0x6001904c
        /// LEDC_LSCH3_DUTY_R.
        pub const LSCH3_DUTY_R = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch3_r.
            DUTY_LSCH3_R: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x4c);

        /// address: 0x60019050
        /// LEDC_LSCH4_CONF0.
        pub const LSCH4_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_timer_sel_lsch4.
            TIMER_SEL_LSCH4: u2,
            /// reg_sig_out_en_lsch4.
            SIG_OUT_EN_LSCH4: u1,
            /// reg_idle_lv_lsch4.
            IDLE_LV_LSCH4: u1,
            /// reg_para_up_lsch4.
            PARA_UP_LSCH4: u1,
            /// reg_ovf_num_lsch4.
            OVF_NUM_LSCH4: u10,
            /// reg_ovf_cnt_en_lsch4.
            OVF_CNT_EN_LSCH4: u1,
            /// reg_ovf_cnt_reset_lsch4.
            OVF_CNT_RESET_LSCH4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x50);

        /// address: 0x60019054
        /// LEDC_LSCH4_HPOINT.
        pub const LSCH4_HPOINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_hpoint_lsch4.
            HPOINT_LSCH4: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x54);

        /// address: 0x60019058
        /// LEDC_LSCH4_DUTY.
        pub const LSCH4_DUTY = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch4.
            DUTY_LSCH4: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x58);

        /// address: 0x6001905c
        /// LEDC_LSCH4_CONF1.
        pub const LSCH4_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_scale_lsch4.
            DUTY_SCALE_LSCH4: u10,
            /// reg_duty_cycle_lsch4.
            DUTY_CYCLE_LSCH4: u10,
            /// reg_duty_num_lsch4.
            DUTY_NUM_LSCH4: u10,
            /// reg_duty_inc_lsch4.
            DUTY_INC_LSCH4: u1,
            /// reg_duty_start_lsch4.
            DUTY_START_LSCH4: u1,
        }), base_address + 0x5c);

        /// address: 0x60019060
        /// LEDC_LSCH4_DUTY_R.
        pub const LSCH4_DUTY_R = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch4_r.
            DUTY_LSCH4_R: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x60);

        /// address: 0x60019064
        /// LEDC_LSCH5_CONF0.
        pub const LSCH5_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_timer_sel_lsch5.
            TIMER_SEL_LSCH5: u2,
            /// reg_sig_out_en_lsch5.
            SIG_OUT_EN_LSCH5: u1,
            /// reg_idle_lv_lsch5.
            IDLE_LV_LSCH5: u1,
            /// reg_para_up_lsch5.
            PARA_UP_LSCH5: u1,
            /// reg_ovf_num_lsch5.
            OVF_NUM_LSCH5: u10,
            /// reg_ovf_cnt_en_lsch5.
            OVF_CNT_EN_LSCH5: u1,
            /// reg_ovf_cnt_reset_lsch5.
            OVF_CNT_RESET_LSCH5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x64);

        /// address: 0x60019068
        /// LEDC_LSCH5_HPOINT.
        pub const LSCH5_HPOINT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_hpoint_lsch5.
            HPOINT_LSCH5: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x68);

        /// address: 0x6001906c
        /// LEDC_LSCH5_DUTY.
        pub const LSCH5_DUTY = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch5.
            DUTY_LSCH5: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x6c);

        /// address: 0x60019070
        /// LEDC_LSCH5_CONF1.
        pub const LSCH5_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_scale_lsch5.
            DUTY_SCALE_LSCH5: u10,
            /// reg_duty_cycle_lsch5.
            DUTY_CYCLE_LSCH5: u10,
            /// reg_duty_num_lsch5.
            DUTY_NUM_LSCH5: u10,
            /// reg_duty_inc_lsch5.
            DUTY_INC_LSCH5: u1,
            /// reg_duty_start_lsch5.
            DUTY_START_LSCH5: u1,
        }), base_address + 0x70);

        /// address: 0x60019074
        /// LEDC_LSCH5_DUTY_R.
        pub const LSCH5_DUTY_R = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_duty_lsch5_r.
            DUTY_LSCH5_R: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x74);

        /// address: 0x600190a0
        /// LEDC_LSTIMER0_CONF.
        pub const LSTIMER0_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer0_duty_res.
            LSTIMER0_DUTY_RES: u4,
            /// reg_clk_div_lstimer0.
            CLK_DIV_LSTIMER0: u18,
            /// reg_lstimer0_pause.
            LSTIMER0_PAUSE: u1,
            /// reg_lstimer0_rst.
            LSTIMER0_RST: u1,
            /// reg_tick_sel_lstimer0.
            TICK_SEL_LSTIMER0: u1,
            /// reg_lstimer0_para_up.
            LSTIMER0_PARA_UP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xa0);

        /// address: 0x600190a4
        /// LEDC_LSTIMER0_VALUE.
        pub const LSTIMER0_VALUE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer0_cnt.
            LSTIMER0_CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xa4);

        /// address: 0x600190a8
        /// LEDC_LSTIMER1_CONF.
        pub const LSTIMER1_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer1_duty_res.
            LSTIMER1_DUTY_RES: u4,
            /// reg_clk_div_lstimer1.
            CLK_DIV_LSTIMER1: u18,
            /// reg_lstimer1_pause.
            LSTIMER1_PAUSE: u1,
            /// reg_lstimer1_rst.
            LSTIMER1_RST: u1,
            /// reg_tick_sel_lstimer1.
            TICK_SEL_LSTIMER1: u1,
            /// reg_lstimer1_para_up.
            LSTIMER1_PARA_UP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xa8);

        /// address: 0x600190ac
        /// LEDC_LSTIMER1_VALUE.
        pub const LSTIMER1_VALUE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer1_cnt.
            LSTIMER1_CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xac);

        /// address: 0x600190b0
        /// LEDC_LSTIMER2_CONF.
        pub const LSTIMER2_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer2_duty_res.
            LSTIMER2_DUTY_RES: u4,
            /// reg_clk_div_lstimer2.
            CLK_DIV_LSTIMER2: u18,
            /// reg_lstimer2_pause.
            LSTIMER2_PAUSE: u1,
            /// reg_lstimer2_rst.
            LSTIMER2_RST: u1,
            /// reg_tick_sel_lstimer2.
            TICK_SEL_LSTIMER2: u1,
            /// reg_lstimer2_para_up.
            LSTIMER2_PARA_UP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xb0);

        /// address: 0x600190b4
        /// LEDC_LSTIMER2_VALUE.
        pub const LSTIMER2_VALUE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer2_cnt.
            LSTIMER2_CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xb4);

        /// address: 0x600190b8
        /// LEDC_LSTIMER3_CONF.
        pub const LSTIMER3_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer3_duty_res.
            LSTIMER3_DUTY_RES: u4,
            /// reg_clk_div_lstimer3.
            CLK_DIV_LSTIMER3: u18,
            /// reg_lstimer3_pause.
            LSTIMER3_PAUSE: u1,
            /// reg_lstimer3_rst.
            LSTIMER3_RST: u1,
            /// reg_tick_sel_lstimer3.
            TICK_SEL_LSTIMER3: u1,
            /// reg_lstimer3_para_up.
            LSTIMER3_PARA_UP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0xb8);

        /// address: 0x600190bc
        /// LEDC_LSTIMER3_VALUE.
        pub const LSTIMER3_VALUE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer3_cnt.
            LSTIMER3_CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xbc);

        /// address: 0x600190c0
        /// LEDC_INT_RAW.
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer0_ovf_int_raw.
            LSTIMER0_OVF_INT_RAW: u1,
            /// reg_lstimer1_ovf_int_raw.
            LSTIMER1_OVF_INT_RAW: u1,
            /// reg_lstimer2_ovf_int_raw.
            LSTIMER2_OVF_INT_RAW: u1,
            /// reg_lstimer3_ovf_int_raw.
            LSTIMER3_OVF_INT_RAW: u1,
            /// reg_duty_chng_end_lsch0_int_raw.
            DUTY_CHNG_END_LSCH0_INT_RAW: u1,
            /// reg_duty_chng_end_lsch1_int_raw.
            DUTY_CHNG_END_LSCH1_INT_RAW: u1,
            /// reg_duty_chng_end_lsch2_int_raw.
            DUTY_CHNG_END_LSCH2_INT_RAW: u1,
            /// reg_duty_chng_end_lsch3_int_raw.
            DUTY_CHNG_END_LSCH3_INT_RAW: u1,
            /// reg_duty_chng_end_lsch4_int_raw.
            DUTY_CHNG_END_LSCH4_INT_RAW: u1,
            /// reg_duty_chng_end_lsch5_int_raw.
            DUTY_CHNG_END_LSCH5_INT_RAW: u1,
            /// reg_ovf_cnt_lsch0_int_raw.
            OVF_CNT_LSCH0_INT_RAW: u1,
            /// reg_ovf_cnt_lsch1_int_raw.
            OVF_CNT_LSCH1_INT_RAW: u1,
            /// reg_ovf_cnt_lsch2_int_raw.
            OVF_CNT_LSCH2_INT_RAW: u1,
            /// reg_ovf_cnt_lsch3_int_raw.
            OVF_CNT_LSCH3_INT_RAW: u1,
            /// reg_ovf_cnt_lsch4_int_raw.
            OVF_CNT_LSCH4_INT_RAW: u1,
            /// reg_ovf_cnt_lsch5_int_raw.
            OVF_CNT_LSCH5_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc0);

        /// address: 0x600190c4
        /// LEDC_INT_ST.
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer0_ovf_int_st.
            LSTIMER0_OVF_INT_ST: u1,
            /// reg_lstimer1_ovf_int_st.
            LSTIMER1_OVF_INT_ST: u1,
            /// reg_lstimer2_ovf_int_st.
            LSTIMER2_OVF_INT_ST: u1,
            /// reg_lstimer3_ovf_int_st.
            LSTIMER3_OVF_INT_ST: u1,
            /// reg_duty_chng_end_lsch0_int_st.
            DUTY_CHNG_END_LSCH0_INT_ST: u1,
            /// reg_duty_chng_end_lsch1_int_st.
            DUTY_CHNG_END_LSCH1_INT_ST: u1,
            /// reg_duty_chng_end_lsch2_int_st.
            DUTY_CHNG_END_LSCH2_INT_ST: u1,
            /// reg_duty_chng_end_lsch3_int_st.
            DUTY_CHNG_END_LSCH3_INT_ST: u1,
            /// reg_duty_chng_end_lsch4_int_st.
            DUTY_CHNG_END_LSCH4_INT_ST: u1,
            /// reg_duty_chng_end_lsch5_int_st.
            DUTY_CHNG_END_LSCH5_INT_ST: u1,
            /// reg_ovf_cnt_lsch0_int_st.
            OVF_CNT_LSCH0_INT_ST: u1,
            /// reg_ovf_cnt_lsch1_int_st.
            OVF_CNT_LSCH1_INT_ST: u1,
            /// reg_ovf_cnt_lsch2_int_st.
            OVF_CNT_LSCH2_INT_ST: u1,
            /// reg_ovf_cnt_lsch3_int_st.
            OVF_CNT_LSCH3_INT_ST: u1,
            /// reg_ovf_cnt_lsch4_int_st.
            OVF_CNT_LSCH4_INT_ST: u1,
            /// reg_ovf_cnt_lsch5_int_st.
            OVF_CNT_LSCH5_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc4);

        /// address: 0x600190c8
        /// LEDC_INT_ENA.
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer0_ovf_int_ena.
            LSTIMER0_OVF_INT_ENA: u1,
            /// reg_lstimer1_ovf_int_ena.
            LSTIMER1_OVF_INT_ENA: u1,
            /// reg_lstimer2_ovf_int_ena.
            LSTIMER2_OVF_INT_ENA: u1,
            /// reg_lstimer3_ovf_int_ena.
            LSTIMER3_OVF_INT_ENA: u1,
            /// reg_duty_chng_end_lsch0_int_ena.
            DUTY_CHNG_END_LSCH0_INT_ENA: u1,
            /// reg_duty_chng_end_lsch1_int_ena.
            DUTY_CHNG_END_LSCH1_INT_ENA: u1,
            /// reg_duty_chng_end_lsch2_int_ena.
            DUTY_CHNG_END_LSCH2_INT_ENA: u1,
            /// reg_duty_chng_end_lsch3_int_ena.
            DUTY_CHNG_END_LSCH3_INT_ENA: u1,
            /// reg_duty_chng_end_lsch4_int_ena.
            DUTY_CHNG_END_LSCH4_INT_ENA: u1,
            /// reg_duty_chng_end_lsch5_int_ena.
            DUTY_CHNG_END_LSCH5_INT_ENA: u1,
            /// reg_ovf_cnt_lsch0_int_ena.
            OVF_CNT_LSCH0_INT_ENA: u1,
            /// reg_ovf_cnt_lsch1_int_ena.
            OVF_CNT_LSCH1_INT_ENA: u1,
            /// reg_ovf_cnt_lsch2_int_ena.
            OVF_CNT_LSCH2_INT_ENA: u1,
            /// reg_ovf_cnt_lsch3_int_ena.
            OVF_CNT_LSCH3_INT_ENA: u1,
            /// reg_ovf_cnt_lsch4_int_ena.
            OVF_CNT_LSCH4_INT_ENA: u1,
            /// reg_ovf_cnt_lsch5_int_ena.
            OVF_CNT_LSCH5_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc8);

        /// address: 0x600190cc
        /// LEDC_INT_CLR.
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lstimer0_ovf_int_clr.
            LSTIMER0_OVF_INT_CLR: u1,
            /// reg_lstimer1_ovf_int_clr.
            LSTIMER1_OVF_INT_CLR: u1,
            /// reg_lstimer2_ovf_int_clr.
            LSTIMER2_OVF_INT_CLR: u1,
            /// reg_lstimer3_ovf_int_clr.
            LSTIMER3_OVF_INT_CLR: u1,
            /// reg_duty_chng_end_lsch0_int_clr.
            DUTY_CHNG_END_LSCH0_INT_CLR: u1,
            /// reg_duty_chng_end_lsch1_int_clr.
            DUTY_CHNG_END_LSCH1_INT_CLR: u1,
            /// reg_duty_chng_end_lsch2_int_clr.
            DUTY_CHNG_END_LSCH2_INT_CLR: u1,
            /// reg_duty_chng_end_lsch3_int_clr.
            DUTY_CHNG_END_LSCH3_INT_CLR: u1,
            /// reg_duty_chng_end_lsch4_int_clr.
            DUTY_CHNG_END_LSCH4_INT_CLR: u1,
            /// reg_duty_chng_end_lsch5_int_clr.
            DUTY_CHNG_END_LSCH5_INT_CLR: u1,
            /// reg_ovf_cnt_lsch0_int_clr.
            OVF_CNT_LSCH0_INT_CLR: u1,
            /// reg_ovf_cnt_lsch1_int_clr.
            OVF_CNT_LSCH1_INT_CLR: u1,
            /// reg_ovf_cnt_lsch2_int_clr.
            OVF_CNT_LSCH2_INT_CLR: u1,
            /// reg_ovf_cnt_lsch3_int_clr.
            OVF_CNT_LSCH3_INT_CLR: u1,
            /// reg_ovf_cnt_lsch4_int_clr.
            OVF_CNT_LSCH4_INT_CLR: u1,
            /// reg_ovf_cnt_lsch5_int_clr.
            OVF_CNT_LSCH5_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xcc);

        /// address: 0x600190d0
        /// LEDC_CONF.
        pub const CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_apb_clk_sel.
            APB_CLK_SEL: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// reg_clk_en.
            CLK_EN: u1,
        }), base_address + 0xd0);

        /// address: 0x600190fc
        /// LEDC_DATE.
        pub const DATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_ledc_date.
            LEDC_DATE: u32,
        }), base_address + 0xfc);
    };

    /// Remote Control Peripheral
    pub const RMT = struct {
        pub const base_address = 0x60016000;

        /// address: 0x60016000
        /// RMT_CH0DATA_REG.
        pub const CH0DATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            DATA: u32,
        }), base_address + 0x0);

        /// address: 0x60016004
        /// RMT_CH1DATA_REG.
        pub const CH1DATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            DATA: u32,
        }), base_address + 0x4);

        /// address: 0x60016008
        /// RMT_CH2DATA_REG.
        pub const CH2DATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            DATA: u32,
        }), base_address + 0x8);

        /// address: 0x6001600c
        /// RMT_CH3DATA_REG.
        pub const CH3DATA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reserved.
            DATA: u32,
        }), base_address + 0xc);

        /// address: 0x60016010
        /// RMT_CH%sCONF%s_REG.
        pub const CH0_TX_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_tx_start_ch0.
            TX_START: u1,
            /// reg_mem_rd_rst_ch0.
            MEM_RD_RST: u1,
            /// reg_apb_mem_rst_ch0.
            APB_MEM_RST: u1,
            /// reg_tx_conti_mode_ch0.
            TX_CONTI_MODE: u1,
            /// reg_mem_tx_wrap_en_ch0.
            MEM_TX_WRAP_EN: u1,
            /// reg_idle_out_lv_ch0.
            IDLE_OUT_LV: u1,
            /// reg_idle_out_en_ch0.
            IDLE_OUT_EN: u1,
            /// reg_tx_stop_ch0.
            TX_STOP: u1,
            /// reg_div_cnt_ch0.
            DIV_CNT: u8,
            /// reg_mem_size_ch0.
            MEM_SIZE: u3,
            reserved0: u1,
            /// reg_carrier_eff_en_ch0.
            CARRIER_EFF_EN: u1,
            /// reg_carrier_en_ch0.
            CARRIER_EN: u1,
            /// reg_carrier_out_lv_ch0.
            CARRIER_OUT_LV: u1,
            /// reg_afifo_rst_ch0.
            AFIFO_RST: u1,
            /// reg_reg_conf_update_ch0.
            CONF_UPDATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x10);

        /// address: 0x60016014
        /// RMT_CH%sCONF%s_REG.
        pub const CH1_TX_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_tx_start_ch0.
            TX_START: u1,
            /// reg_mem_rd_rst_ch0.
            MEM_RD_RST: u1,
            /// reg_apb_mem_rst_ch0.
            APB_MEM_RST: u1,
            /// reg_tx_conti_mode_ch0.
            TX_CONTI_MODE: u1,
            /// reg_mem_tx_wrap_en_ch0.
            MEM_TX_WRAP_EN: u1,
            /// reg_idle_out_lv_ch0.
            IDLE_OUT_LV: u1,
            /// reg_idle_out_en_ch0.
            IDLE_OUT_EN: u1,
            /// reg_tx_stop_ch0.
            TX_STOP: u1,
            /// reg_div_cnt_ch0.
            DIV_CNT: u8,
            /// reg_mem_size_ch0.
            MEM_SIZE: u3,
            reserved0: u1,
            /// reg_carrier_eff_en_ch0.
            CARRIER_EFF_EN: u1,
            /// reg_carrier_en_ch0.
            CARRIER_EN: u1,
            /// reg_carrier_out_lv_ch0.
            CARRIER_OUT_LV: u1,
            /// reg_afifo_rst_ch0.
            AFIFO_RST: u1,
            /// reg_reg_conf_update_ch0.
            CONF_UPDATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x14);

        /// address: 0x60016018
        /// RMT_CH2CONF0_REG.
        pub const CH2_RX_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_div_cnt_ch2.
            DIV_CNT: u8,
            /// reg_idle_thres_ch2.
            IDLE_THRES: u15,
            /// reg_mem_size_ch2.
            MEM_SIZE: u3,
            reserved0: u1,
            reserved1: u1,
            /// reg_carrier_en_ch2.
            CARRIER_EN: u1,
            /// reg_carrier_out_lv_ch2.
            CARRIER_OUT_LV: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x18);

        /// address: 0x60016020
        /// RMT_CH2CONF0_REG.
        pub const CH3_RX_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_div_cnt_ch2.
            DIV_CNT: u8,
            /// reg_idle_thres_ch2.
            IDLE_THRES: u15,
            /// reg_mem_size_ch2.
            MEM_SIZE: u3,
            reserved0: u1,
            reserved1: u1,
            /// reg_carrier_en_ch2.
            CARRIER_EN: u1,
            /// reg_carrier_out_lv_ch2.
            CARRIER_OUT_LV: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x6001601c
        /// RMT_CH2CONF1_REG.
        pub const CH2CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rx_en_ch2.
            RX_EN: u1,
            /// reg_mem_wr_rst_ch2.
            MEM_WR_RST: u1,
            /// reg_apb_mem_rst_ch2.
            APB_MEM_RST: u1,
            /// reg_mem_owner_ch2.
            MEM_OWNER: u1,
            /// reg_rx_filter_en_ch2.
            RX_FILTER_EN: u1,
            /// reg_rx_filter_thres_ch2.
            RX_FILTER_THRES: u8,
            /// reg_mem_rx_wrap_en_ch2.
            MEM_RX_WRAP_EN: u1,
            /// reg_afifo_rst_ch2.
            AFIFO_RST: u1,
            /// reg_conf_update_ch2.
            CONF_UPDATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x60016024
        /// RMT_CH3CONF1_REG.
        pub const CH3CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rx_en_ch3.
            RX_EN: u1,
            /// reg_mem_wr_rst_ch3.
            MEM_WR_RST: u1,
            /// reg_apb_mem_rst_ch3.
            APB_MEM_RST: u1,
            /// reg_mem_owner_ch3.
            MEM_OWNER: u1,
            /// reg_rx_filter_en_ch3.
            RX_FILTER_EN: u1,
            /// reg_rx_filter_thres_ch3.
            RX_FILTER_THRES: u8,
            /// reg_mem_rx_wrap_en_ch3.
            MEM_RX_WRAP_EN: u1,
            /// reg_afifo_rst_ch3.
            AFIFO_RST: u1,
            /// reg_conf_update_ch3.
            CONF_UPDATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x60016028
        /// RMT_CH0STATUS_REG.
        pub const CH0STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_mem_raddr_ex_ch0.
            MEM_RADDR_EX: u9,
            /// reg_state_ch0.
            STATE: u3,
            /// reg_apb_mem_waddr_ch0.
            APB_MEM_WADDR: u9,
            /// reg_apb_mem_rd_err_ch0.
            APB_MEM_RD_ERR: u1,
            /// reg_mem_empty_ch0.
            MEM_EMPTY: u1,
            /// reg_apb_mem_wr_err_ch0.
            APB_MEM_WR_ERR: u1,
            /// reg_apb_mem_raddr_ch0.
            APB_MEM_RADDR: u8,
        }), base_address + 0x28);

        /// address: 0x6001602c
        /// RMT_CH1STATUS_REG.
        pub const CH1STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_mem_raddr_ex_ch1.
            MEM_RADDR_EX: u9,
            /// reg_state_ch1.
            STATE: u3,
            /// reg_apb_mem_waddr_ch1.
            APB_MEM_WADDR: u9,
            /// reg_apb_mem_rd_err_ch1.
            APB_MEM_RD_ERR: u1,
            /// reg_mem_empty_ch1.
            MEM_EMPTY: u1,
            /// reg_apb_mem_wr_err_ch1.
            APB_MEM_WR_ERR: u1,
            /// reg_apb_mem_raddr_ch1.
            APB_MEM_RADDR: u8,
        }), base_address + 0x2c);

        /// address: 0x60016030
        /// RMT_CH2STATUS_REG.
        pub const CH2STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_mem_waddr_ex_ch2.
            MEM_WADDR_EX: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// reg_apb_mem_raddr_ch2.
            APB_MEM_RADDR: u9,
            reserved3: u1,
            /// reg_state_ch2.
            STATE: u3,
            /// reg_mem_owner_err_ch2.
            MEM_OWNER_ERR: u1,
            /// reg_mem_full_ch2.
            MEM_FULL: u1,
            /// reg_apb_mem_rd_err_ch2.
            APB_MEM_RD_ERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x30);

        /// address: 0x60016034
        /// RMT_CH3STATUS_REG.
        pub const CH3STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_mem_waddr_ex_ch3.
            MEM_WADDR_EX: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// reg_apb_mem_raddr_ch3.
            APB_MEM_RADDR: u9,
            reserved3: u1,
            /// reg_state_ch3.
            STATE: u3,
            /// reg_mem_owner_err_ch3.
            MEM_OWNER_ERR: u1,
            /// reg_mem_full_ch3.
            MEM_FULL: u1,
            /// reg_apb_mem_rd_err_ch3.
            APB_MEM_RD_ERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x34);

        /// address: 0x60016038
        /// RMT_INT_RAW_REG.
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            CH0_TX_END_INT_RAW: u1,
            CH1_TX_END_INT_RAW: u1,
            CH2_RX_END_INT_RAW: u1,
            CH3_RX_END_INT_RAW: u1,
            CH0_TX_ERR_INT_RAW: u1,
            CH1_TX_ERR_INT_RAW: u1,
            CH2_RX_ERR_INT_RAW: u1,
            CH3_RX_ERR_INT_RAW: u1,
            CH0_TX_THR_EVENT_INT_RAW: u1,
            CH1_TX_THR_EVENT_INT_RAW: u1,
            /// reg_ch2_rx_thr_event_int_raw.
            CH2_RX_THR_EVENT_INT_RAW: u1,
            /// reg_ch3_rx_thr_event_int_raw.
            CH3_RX_THR_EVENT_INT_RAW: u1,
            CH0_TX_LOOP_INT_RAW: u1,
            CH1_TX_LOOP_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x38);

        /// address: 0x6001603c
        /// RMT_INT_ST_REG.
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            CH0_TX_END_INT_ST: u1,
            CH1_TX_END_INT_ST: u1,
            CH2_RX_END_INT_ST: u1,
            CH3_RX_END_INT_ST: u1,
            CH0_TX_ERR_INT_ST: u1,
            CH1_TX_ERR_INT_ST: u1,
            CH2_RX_ERR_INT_ST: u1,
            CH3_RX_ERR_INT_ST: u1,
            CH0_TX_THR_EVENT_INT_ST: u1,
            CH1_TX_THR_EVENT_INT_ST: u1,
            /// reg_ch2_rx_thr_event_int_st.
            CH2_RX_THR_EVENT_INT_ST: u1,
            /// reg_ch3_rx_thr_event_int_st.
            CH3_RX_THR_EVENT_INT_ST: u1,
            CH0_TX_LOOP_INT_ST: u1,
            CH1_TX_LOOP_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x3c);

        /// address: 0x60016040
        /// RMT_INT_ENA_REG.
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            CH0_TX_END_INT_ENA: u1,
            CH1_TX_END_INT_ENA: u1,
            CH2_RX_END_INT_ENA: u1,
            CH3_RX_END_INT_ENA: u1,
            CH0_TX_ERR_INT_ENA: u1,
            CH1_TX_ERR_INT_ENA: u1,
            CH2_RX_ERR_INT_ENA: u1,
            CH3_RX_ERR_INT_ENA: u1,
            CH0_TX_THR_EVENT_INT_ENA: u1,
            CH1_TX_THR_EVENT_INT_ENA: u1,
            /// reg_ch2_rx_thr_event_int_ena.
            CH2_RX_THR_EVENT_INT_ENA: u1,
            /// reg_ch3_rx_thr_event_int_ena.
            CH3_RX_THR_EVENT_INT_ENA: u1,
            CH0_TX_LOOP_INT_ENA: u1,
            CH1_TX_LOOP_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x40);

        /// address: 0x60016044
        /// RMT_INT_CLR_REG.
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            CH0_TX_END_INT_CLR: u1,
            CH1_TX_END_INT_CLR: u1,
            CH2_RX_END_INT_CLR: u1,
            CH3_RX_END_INT_CLR: u1,
            CH0_TX_ERR_INT_CLR: u1,
            CH1_TX_ERR_INT_CLR: u1,
            CH2_RX_ERR_INT_CLR: u1,
            CH3_RX_ERR_INT_CLR: u1,
            CH0_TX_THR_EVENT_INT_CLR: u1,
            CH1_TX_THR_EVENT_INT_CLR: u1,
            /// reg_ch2_rx_thr_event_int_clr.
            CH2_RX_THR_EVENT_INT_CLR: u1,
            /// reg_ch3_rx_thr_event_int_clr.
            CH3_RX_THR_EVENT_INT_CLR: u1,
            CH0_TX_LOOP_INT_CLR: u1,
            CH1_TX_LOOP_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x44);

        /// address: 0x60016048
        /// RMT_CH0CARRIER_DUTY_REG.
        pub const CH0CARRIER_DUTY = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_carrier_low_ch0.
            CARRIER_LOW: u16,
            /// reg_carrier_high_ch0.
            CARRIER_HIGH: u16,
        }), base_address + 0x48);

        /// address: 0x6001604c
        /// RMT_CH1CARRIER_DUTY_REG.
        pub const CH1CARRIER_DUTY = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_carrier_low_ch1.
            CARRIER_LOW: u16,
            /// reg_carrier_high_ch1.
            CARRIER_HIGH: u16,
        }), base_address + 0x4c);

        /// address: 0x60016050
        /// RMT_CH2_RX_CARRIER_RM_REG.
        pub const CH2_RX_CARRIER_RM = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_carrier_low_thres_ch2.
            CARRIER_LOW_THRES: u16,
            /// reg_carrier_high_thres_ch2.
            CARRIER_HIGH_THRES: u16,
        }), base_address + 0x50);

        /// address: 0x60016054
        /// RMT_CH3_RX_CARRIER_RM_REG.
        pub const CH3_RX_CARRIER_RM = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_carrier_low_thres_ch3.
            CARRIER_LOW_THRES: u16,
            /// reg_carrier_high_thres_ch3.
            CARRIER_HIGH_THRES: u16,
        }), base_address + 0x54);

        /// address: 0x60016058
        /// RMT_CH%s_TX_LIM_REG.
        pub const CH0_TX_LIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rmt_tx_lim_ch0.
            TX_LIM: u9,
            /// reg_rmt_tx_loop_num_ch0.
            TX_LOOP_NUM: u10,
            /// reg_rmt_tx_loop_cnt_en_ch0.
            TX_LOOP_CNT_EN: u1,
            /// reg_loop_count_reset_ch0.
            LOOP_COUNT_RESET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x58);

        /// address: 0x6001605c
        /// RMT_CH%s_TX_LIM_REG.
        pub const CH1_TX_LIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rmt_tx_lim_ch0.
            TX_LIM: u9,
            /// reg_rmt_tx_loop_num_ch0.
            TX_LOOP_NUM: u10,
            /// reg_rmt_tx_loop_cnt_en_ch0.
            TX_LOOP_CNT_EN: u1,
            /// reg_loop_count_reset_ch0.
            LOOP_COUNT_RESET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x5c);

        /// address: 0x60016060
        /// RMT_CH2_RX_LIM_REG.
        pub const CH2_RX_LIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rmt_rx_lim_ch2.
            RX_LIM: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x60);

        /// address: 0x60016064
        /// RMT_CH2_RX_LIM_REG.
        pub const CH3_RX_LIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rmt_rx_lim_ch2.
            RX_LIM: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x64);

        /// address: 0x60016068
        /// RMT_SYS_CONF_REG.
        pub const SYS_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_apb_fifo_mask.
            APB_FIFO_MASK: u1,
            /// reg_mem_clk_force_on.
            MEM_CLK_FORCE_ON: u1,
            /// reg_rmt_mem_force_pd.
            MEM_FORCE_PD: u1,
            /// reg_rmt_mem_force_pu.
            MEM_FORCE_PU: u1,
            /// reg_rmt_sclk_div_num.
            SCLK_DIV_NUM: u8,
            /// reg_rmt_sclk_div_a.
            SCLK_DIV_A: u6,
            /// reg_rmt_sclk_div_b.
            SCLK_DIV_B: u6,
            /// reg_rmt_sclk_sel.
            SCLK_SEL: u2,
            /// reg_rmt_sclk_active.
            SCLK_ACTIVE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// reg_clk_en.
            CLK_EN: u1,
        }), base_address + 0x68);

        /// address: 0x6001606c
        /// RMT_TX_SIM_REG.
        pub const TX_SIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rmt_tx_sim_ch0.
            TX_SIM_CH0: u1,
            /// reg_rmt_tx_sim_ch1.
            TX_SIM_CH1: u1,
            /// reg_rmt_tx_sim_en.
            TX_SIM_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x6c);

        /// address: 0x60016070
        /// RMT_REF_CNT_RST_REG.
        pub const REF_CNT_RST = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_ref_cnt_rst_ch0.
            CH0: u1,
            /// reg_ref_cnt_rst_ch1.
            CH1: u1,
            /// reg_ref_cnt_rst_ch2.
            CH2: u1,
            /// reg_ref_cnt_rst_ch3.
            CH3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x70);

        /// address: 0x600160cc
        /// RMT_DATE_REG.
        pub const DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0xcc);
    };

    /// Hardware random number generator
    pub const RNG = struct {
        pub const base_address = 0x60026000;

        /// address: 0x600260b0
        /// Random number data
        pub const DATA = @intToPtr(*volatile u32, base_address + 0xb0);
    };

    /// RSA (Rivest Shamir Adleman) Accelerator
    pub const RSA = struct {
        pub const base_address = 0x6003c000;

        /// address: 0x6003c000
        /// The memory that stores M
        pub const M_MEM = @intToPtr(*volatile [16]u8, base_address + 0x0);

        /// address: 0x6003c200
        /// The memory that stores Z
        pub const Z_MEM = @intToPtr(*volatile [16]u8, base_address + 0x200);

        /// address: 0x6003c400
        /// The memory that stores Y
        pub const Y_MEM = @intToPtr(*volatile [16]u8, base_address + 0x400);

        /// address: 0x6003c600
        /// The memory that stores X
        pub const X_MEM = @intToPtr(*volatile [16]u8, base_address + 0x600);

        /// address: 0x6003c800
        /// RSA M_prime register
        pub const M_PRIME = @intToPtr(*volatile u32, base_address + 0x800);

        /// address: 0x6003c804
        /// RSA mode register
        pub const MODE = @intToPtr(*volatile MmioInt(32, u7), base_address + 0x804);

        /// address: 0x6003c808
        /// RSA query clean register
        pub const QUERY_CLEAN = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x808);

        /// address: 0x6003c80c
        /// RSA modular exponentiation trigger register.
        pub const SET_START_MODEXP = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x80c);

        /// address: 0x6003c810
        /// RSA modular multiplication trigger register.
        pub const SET_START_MODMULT = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x810);

        /// address: 0x6003c814
        /// RSA normal multiplication trigger register.
        pub const SET_START_MULT = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x814);

        /// address: 0x6003c818
        /// RSA query idle register
        pub const QUERY_IDLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x818);

        /// address: 0x6003c81c
        /// RSA interrupt clear register
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// set this bit to clear RSA interrupt.
            CLEAR_INTERRUPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x81c);

        /// address: 0x6003c820
        /// RSA constant time option register
        pub const CONSTANT_TIME = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x820);

        /// address: 0x6003c824
        /// RSA search option
        pub const SEARCH_ENABLE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x824);

        /// address: 0x6003c828
        /// RSA search position configure register
        pub const SEARCH_POS = @intToPtr(*volatile MmioInt(32, u12), base_address + 0x828);

        /// address: 0x6003c82c
        /// RSA interrupt enable register
        pub const INT_ENA = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x82c);

        /// address: 0x6003c830
        /// RSA version control register
        pub const DATE = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x830);
    };

    /// Real-Time Clock Control
    pub const RTC_CNTL = struct {
        pub const base_address = 0x60008000;

        /// address: 0x60008000
        /// rtc configure register
        pub const OPTIONS0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// {reg_sw_stall_appcpu_c1[5:0], reg_sw_stall_appcpu_c0[1:0]} == 0x86 will stall
            /// APP CPU
            SW_STALL_APPCPU_C0: u2,
            /// {reg_sw_stall_procpu_c1[5:0], reg_sw_stall_procpu_c0[1:0]} == 0x86 will stall
            /// PRO CPU
            SW_STALL_PROCPU_C0: u2,
            /// APP CPU SW reset
            SW_APPCPU_RST: u1,
            /// PRO CPU SW reset
            SW_PROCPU_RST: u1,
            /// BB_I2C force power down
            BB_I2C_FORCE_PD: u1,
            /// BB_I2C force power up
            BB_I2C_FORCE_PU: u1,
            /// BB_PLL _I2C force power down
            BBPLL_I2C_FORCE_PD: u1,
            /// BB_PLL_I2C force power up
            BBPLL_I2C_FORCE_PU: u1,
            /// BB_PLL force power down
            BBPLL_FORCE_PD: u1,
            /// BB_PLL force power up
            BBPLL_FORCE_PU: u1,
            /// crystall force power down
            XTL_FORCE_PD: u1,
            /// crystall force power up
            XTL_FORCE_PU: u1,
            /// wait bias_sleep and current source wakeup
            XTL_EN_WAIT: u4,
            reserved0: u1,
            reserved1: u1,
            /// analog configure
            XTL_EXT_CTR_SEL: u3,
            /// analog configure
            XTL_FORCE_ISO: u1,
            /// analog configure
            PLL_FORCE_ISO: u1,
            /// analog configure
            ANALOG_FORCE_ISO: u1,
            /// analog configure
            XTL_FORCE_NOISO: u1,
            /// analog configure
            PLL_FORCE_NOISO: u1,
            /// analog configure
            ANALOG_FORCE_NOISO: u1,
            /// digital wrap force reset in deep sleep
            DG_WRAP_FORCE_RST: u1,
            /// digital core force no reset in deep sleep
            DG_WRAP_FORCE_NORST: u1,
            /// SW system reset
            SW_SYS_RST: u1,
        }), base_address + 0x0);

        /// address: 0x60008004
        /// rtc configure register
        pub const SLP_TIMER0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// configure the sleep time
            SLP_VAL_LO: u32,
        }), base_address + 0x4);

        /// address: 0x60008008
        /// rtc configure register
        pub const SLP_TIMER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC sleep timer high 16 bits
            SLP_VAL_HI: u16,
            /// timer alarm enable bit
            RTC_MAIN_TIMER_ALARM_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x6000800c
        /// rtc configure register
        pub const TIME_UPDATE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            /// Enable to record system stall time
            TIMER_SYS_STALL: u1,
            /// Enable to record 40M XTAL OFF time
            TIMER_XTL_OFF: u1,
            /// enable to record system reset time
            TIMER_SYS_RST: u1,
            reserved27: u1,
            /// Set 1: to update register with RTC timer
            RTC_TIME_UPDATE: u1,
        }), base_address + 0xc);

        /// address: 0x60008010
        /// rtc configure register
        pub const TIME_LOW0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC timer low 32 bits
            RTC_TIMER_VALUE0_LOW: u32,
        }), base_address + 0x10);

        /// address: 0x60008014
        /// rtc configure register
        pub const TIME_HIGH0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC timer high 16 bits
            RTC_TIMER_VALUE0_HIGH: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x60008018
        /// rtc configure register
        pub const STATE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// rtc software interrupt to main cpu
            RTC_SW_CPU_INT: u1,
            /// clear rtc sleep reject cause
            RTC_SLP_REJECT_CAUSE_CLR: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// 1: APB to RTC using bridge
            APB2RTC_BRIDGE_SEL: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            /// SDIO active indication
            SDIO_ACTIVE_IND: u1,
            /// leep wakeup bit
            SLP_WAKEUP: u1,
            /// leep reject bit
            SLP_REJECT: u1,
            /// sleep enable bit
            SLEEP_EN: u1,
        }), base_address + 0x18);

        /// address: 0x6000801c
        /// rtc configure register
        pub const TIMER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CPU stall enable bit
            CPU_STALL_EN: u1,
            /// CPU stall wait cycles in fast_clk_rtc
            CPU_STALL_WAIT: u5,
            /// CK8M wait cycles in slow_clk_rtc
            CK8M_WAIT: u8,
            /// XTAL wait cycles in slow_clk_rtc
            XTL_BUF_WAIT: u10,
            /// PLL wait cycles in slow_clk_rtc
            PLL_BUF_WAIT: u8,
        }), base_address + 0x1c);

        /// address: 0x60008020
        /// rtc configure register
        pub const TIMER2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// minimal cycles in slow_clk_rtc for CK8M in power down state
            MIN_TIME_CK8M_OFF: u8,
        }), base_address + 0x20);

        /// address: 0x60008024
        /// rtc configure register
        pub const TIMER3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// wifi power domain wakeup time
            WIFI_WAIT_TIMER: u9,
            /// wifi power domain power on time
            WIFI_POWERUP_TIMER: u7,
            /// bt power domain wakeup time
            BT_WAIT_TIMER: u9,
            /// bt power domain power on time
            BT_POWERUP_TIMER: u7,
        }), base_address + 0x24);

        /// address: 0x60008028
        /// rtc configure register
        pub const TIMER4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// cpu top power domain wakeup time
            CPU_TOP_WAIT_TIMER: u9,
            /// cpu top power domain power on time
            CPU_TOP_POWERUP_TIMER: u7,
            /// digital wrap power domain wakeup time
            DG_WRAP_WAIT_TIMER: u9,
            /// digital wrap power domain power on time
            DG_WRAP_POWERUP_TIMER: u7,
        }), base_address + 0x28);

        /// address: 0x6000802c
        /// rtc configure register
        pub const TIMER5 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// minimal sleep cycles in slow_clk_rtc
            MIN_SLP_VAL: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x60008030
        /// rtc configure register
        pub const TIMER6 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// digital peri power domain wakeup time
            DG_PERI_WAIT_TIMER: u9,
            /// digital peri power domain power on time
            DG_PERI_POWERUP_TIMER: u7,
        }), base_address + 0x30);

        /// address: 0x60008034
        /// rtc configure register
        pub const ANA_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// force no bypass i2c power on reset
            RESET_POR_FORCE_PD: u1,
            /// force bypass i2c power on reset
            RESET_POR_FORCE_PU: u1,
            /// enable glitch reset
            GLITCH_RST_EN: u1,
            reserved18: u1,
            /// PLLA force power up
            SAR_I2C_PU: u1,
            /// PLLA force power down
            PLLA_FORCE_PD: u1,
            /// PLLA force power up
            PLLA_FORCE_PU: u1,
            /// start BBPLL calibration during sleep
            BBPLL_CAL_SLP_START: u1,
            /// 1: PVTMON power up
            PVTMON_PU: u1,
            /// 1: TXRF_I2C power up
            TXRF_I2C_PU: u1,
            /// 1: RFRX_PBUS power up
            RFRX_PBUS_PU: u1,
            reserved19: u1,
            /// 1: CKGEN_I2C power up
            CKGEN_I2C_PU: u1,
            /// power up pll i2c
            PLL_I2C_PU: u1,
        }), base_address + 0x34);

        /// address: 0x60008038
        /// rtc configure register
        pub const RESET_STATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reset cause of PRO CPU
            RESET_CAUSE_PROCPU: u6,
            /// reset cause of APP CPU
            RESET_CAUSE_APPCPU: u6,
            /// APP CPU state vector sel
            STAT_VECTOR_SEL_APPCPU: u1,
            /// PRO CPU state vector sel
            STAT_VECTOR_SEL_PROCPU: u1,
            /// PRO CPU reset_flag
            ALL_RESET_FLAG_PROCPU: u1,
            /// APP CPU reset flag
            ALL_RESET_FLAG_APPCPU: u1,
            /// clear PRO CPU reset_flag
            ALL_RESET_FLAG_CLR_PROCPU: u1,
            /// clear APP CPU reset flag
            ALL_RESET_FLAG_CLR_APPCPU: u1,
            /// APPCPU OcdHaltOnReset
            OCD_HALT_ON_RESET_APPCPU: u1,
            /// PROCPU OcdHaltOnReset
            OCD_HALT_ON_RESET_PROCPU: u1,
            /// configure jtag reset configure
            JTAG_RESET_FLAG_PROCPU: u1,
            /// configure jtag reset configure
            JTAG_RESET_FLAG_APPCPU: u1,
            /// configure jtag reset configure
            JTAG_RESET_FLAG_CLR_PROCPU: u1,
            /// configure jtag reset configure
            JTAG_RESET_FLAG_CLR_APPCPU: u1,
            /// configure dreset configure
            RTC_DRESET_MASK_APPCPU: u1,
            /// configure dreset configure
            RTC_DRESET_MASK_PROCPU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x38);

        /// address: 0x6000803c
        /// rtc configure register
        pub const WAKEUP_STATE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// wakeup enable bitmap
            RTC_WAKEUP_ENA: u17,
        }), base_address + 0x3c);

        /// address: 0x60008040
        /// rtc configure register
        pub const INT_ENA_RTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// enable sleep wakeup interrupt
            SLP_WAKEUP_INT_ENA: u1,
            /// enable sleep reject interrupt
            SLP_REJECT_INT_ENA: u1,
            reserved0: u1,
            /// enable RTC WDT interrupt
            RTC_WDT_INT_ENA: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// enable brown out interrupt
            RTC_BROWN_OUT_INT_ENA: u1,
            /// enable RTC main timer interrupt
            RTC_MAIN_TIMER_INT_ENA: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// enable super watch dog interrupt
            RTC_SWD_INT_ENA: u1,
            /// enable xtal32k_dead interrupt
            RTC_XTAL32K_DEAD_INT_ENA: u1,
            reserved10: u1,
            reserved11: u1,
            /// enbale gitch det interrupt
            RTC_GLITCH_DET_INT_ENA: u1,
            /// enbale bbpll cal end interrupt
            RTC_BBPLL_CAL_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x40);

        /// address: 0x60008044
        /// rtc configure register
        pub const INT_RAW_RTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// sleep wakeup interrupt raw
            SLP_WAKEUP_INT_RAW: u1,
            /// sleep reject interrupt raw
            SLP_REJECT_INT_RAW: u1,
            reserved0: u1,
            /// RTC WDT interrupt raw
            RTC_WDT_INT_RAW: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// brown out interrupt raw
            RTC_BROWN_OUT_INT_RAW: u1,
            /// RTC main timer interrupt raw
            RTC_MAIN_TIMER_INT_RAW: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// super watch dog interrupt raw
            RTC_SWD_INT_RAW: u1,
            /// xtal32k dead detection interrupt raw
            RTC_XTAL32K_DEAD_INT_RAW: u1,
            reserved10: u1,
            reserved11: u1,
            /// glitch_det_interrupt_raw
            RTC_GLITCH_DET_INT_RAW: u1,
            /// bbpll cal end interrupt state
            RTC_BBPLL_CAL_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x44);

        /// address: 0x60008048
        /// rtc configure register
        pub const INT_ST_RTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// sleep wakeup interrupt state
            SLP_WAKEUP_INT_ST: u1,
            /// sleep reject interrupt state
            SLP_REJECT_INT_ST: u1,
            reserved0: u1,
            /// RTC WDT interrupt state
            RTC_WDT_INT_ST: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// brown out interrupt state
            RTC_BROWN_OUT_INT_ST: u1,
            /// RTC main timer interrupt state
            RTC_MAIN_TIMER_INT_ST: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// super watch dog interrupt state
            RTC_SWD_INT_ST: u1,
            /// xtal32k dead detection interrupt state
            RTC_XTAL32K_DEAD_INT_ST: u1,
            reserved10: u1,
            reserved11: u1,
            /// glitch_det_interrupt state
            RTC_GLITCH_DET_INT_ST: u1,
            /// bbpll cal end interrupt state
            RTC_BBPLL_CAL_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x48);

        /// address: 0x6000804c
        /// rtc configure register
        pub const INT_CLR_RTC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear sleep wakeup interrupt state
            SLP_WAKEUP_INT_CLR: u1,
            /// Clear sleep reject interrupt state
            SLP_REJECT_INT_CLR: u1,
            reserved0: u1,
            /// Clear RTC WDT interrupt state
            RTC_WDT_INT_CLR: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Clear brown out interrupt state
            RTC_BROWN_OUT_INT_CLR: u1,
            /// Clear RTC main timer interrupt state
            RTC_MAIN_TIMER_INT_CLR: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Clear super watch dog interrupt state
            RTC_SWD_INT_CLR: u1,
            /// Clear RTC WDT interrupt state
            RTC_XTAL32K_DEAD_INT_CLR: u1,
            reserved10: u1,
            reserved11: u1,
            /// Clear glitch det interrupt state
            RTC_GLITCH_DET_INT_CLR: u1,
            /// clear bbpll cal end interrupt state
            RTC_BBPLL_CAL_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x4c);

        /// address: 0x60008050
        /// rtc configure register
        pub const STORE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reserved register
            RTC_SCRATCH0: u32,
        }), base_address + 0x50);

        /// address: 0x60008054
        /// rtc configure register
        pub const STORE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reserved register
            RTC_SCRATCH1: u32,
        }), base_address + 0x54);

        /// address: 0x60008058
        /// rtc configure register
        pub const STORE2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reserved register
            RTC_SCRATCH2: u32,
        }), base_address + 0x58);

        /// address: 0x6000805c
        /// rtc configure register
        pub const STORE3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reserved register
            RTC_SCRATCH3: u32,
        }), base_address + 0x5c);

        /// address: 0x60008060
        /// rtc configure register
        pub const EXT_XTL_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// xtal 32k watch dog enable
            XTAL32K_WDT_EN: u1,
            /// xtal 32k watch dog clock force on
            XTAL32K_WDT_CLK_FO: u1,
            /// xtal 32k watch dog sw reset
            XTAL32K_WDT_RESET: u1,
            /// xtal 32k external xtal clock force on
            XTAL32K_EXT_CLK_FO: u1,
            /// xtal 32k switch to back up clock when xtal is dead
            XTAL32K_AUTO_BACKUP: u1,
            /// xtal 32k restart xtal when xtal is dead
            XTAL32K_AUTO_RESTART: u1,
            /// xtal 32k switch back xtal when xtal is restarted
            XTAL32K_AUTO_RETURN: u1,
            /// Xtal 32k xpd control by sw or fsm
            XTAL32K_XPD_FORCE: u1,
            /// apply an internal clock to help xtal 32k to start
            ENCKINIT_XTAL_32K: u1,
            /// 0: single-end buffer 1: differential buffer
            DBUF_XTAL_32K: u1,
            /// xtal_32k gm control
            DGM_XTAL_32K: u3,
            /// DRES_XTAL_32K
            DRES_XTAL_32K: u3,
            /// XPD_XTAL_32K
            XPD_XTAL_32K: u1,
            /// DAC_XTAL_32K
            DAC_XTAL_32K: u3,
            /// state of 32k_wdt
            RTC_WDT_STATE: u3,
            /// XTAL_32K sel. 0: external XTAL_32K
            RTC_XTAL32K_GPIO_SEL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// 0: power down XTAL at high level
            XTL_EXT_CTR_LV: u1,
            /// enable gpio configure xtal power on
            XTL_EXT_CTR_EN: u1,
        }), base_address + 0x60);

        /// address: 0x60008064
        /// rtc configure register
        pub const EXT_WAKEUP_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// enable filter for gpio wakeup event
            GPIO_WAKEUP_FILTER: u1,
        }), base_address + 0x64);

        /// address: 0x60008068
        /// rtc configure register
        pub const SLP_REJECT_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// sleep reject enable
            RTC_SLEEP_REJECT_ENA: u18,
            /// enable reject for light sleep
            LIGHT_SLP_REJECT_EN: u1,
            /// enable reject for deep sleep
            DEEP_SLP_REJECT_EN: u1,
        }), base_address + 0x68);

        /// address: 0x6000806c
        /// rtc configure register
        pub const CPU_PERIOD_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// CPU sel option
            RTC_CPUSEL_CONF: u1,
            /// CPU clk sel option
            RTC_CPUPERIOD_SEL: u2,
        }), base_address + 0x6c);

        /// address: 0x60008070
        /// rtc configure register
        pub const CLK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// efuse_clk_force_gating
            EFUSE_CLK_FORCE_GATING: u1,
            /// efuse_clk_force_nogating
            EFUSE_CLK_FORCE_NOGATING: u1,
            /// used to sync reg_ck8m_div_sel bus. Clear vld before set reg_ck8m_div_sel
            CK8M_DIV_SEL_VLD: u1,
            /// CK8M_D256_OUT divider. 00: div128
            CK8M_DIV: u2,
            /// disable CK8M and CK8M_D256_OUT
            ENB_CK8M: u1,
            /// 1: CK8M_D256_OUT is actually CK8M
            ENB_CK8M_DIV: u1,
            /// enable CK_XTAL_32K for digital core (no relationship with RTC core)
            DIG_XTAL32K_EN: u1,
            /// enable CK8M_D256_OUT for digital core (no relationship with RTC core)
            DIG_CLK8M_D256_EN: u1,
            /// enable CK8M for digital core (no relationship with RTC core)
            DIG_CLK8M_EN: u1,
            reserved1: u1,
            /// divider = reg_ck8m_div_sel + 1
            CK8M_DIV_SEL: u3,
            /// XTAL force no gating during sleep
            XTAL_FORCE_NOGATING: u1,
            /// CK8M force no gating during sleep
            CK8M_FORCE_NOGATING: u1,
            /// CK8M_DFREQ
            CK8M_DFREQ: u8,
            /// CK8M force power down
            CK8M_FORCE_PD: u1,
            /// CK8M force power up
            CK8M_FORCE_PU: u1,
            /// force enable xtal clk gating
            XTAL_GLOBAL_FORCE_GATING: u1,
            /// force bypass xtal clk gating
            XTAL_GLOBAL_FORCE_NOGATING: u1,
            /// fast_clk_rtc sel. 0: XTAL div 4
            FAST_CLK_RTC_SEL: u1,
            /// slelect rtc slow clk
            ANA_CLK_RTC_SEL: u2,
        }), base_address + 0x70);

        /// address: 0x60008074
        /// rtc configure register
        pub const SLOW_CLK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// used to sync div bus. clear vld before set reg_rtc_ana_clk_div
            RTC_ANA_CLK_DIV_VLD: u1,
            /// the clk divider num of RTC_CLK
            RTC_ANA_CLK_DIV: u8,
            /// flag rtc_slow_clk_next_edge
            RTC_SLOW_CLK_NEXT_EDGE: u1,
        }), base_address + 0x74);

        /// address: 0x60008078
        /// rtc configure register
        pub const SDIO_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer count to apply reg_sdio_dcap after sdio power on
            SDIO_TIMER_TARGET: u8,
            reserved0: u1,
            /// Tieh = 1 mode drive ability. Initially set to 0 to limit charge current
            SDIO_DTHDRV: u2,
            /// ability to prevent LDO from overshoot
            SDIO_DCAP: u2,
            /// add resistor from ldo output to ground. 0: no res
            SDIO_INITI: u2,
            /// 0 to set init[1:0]=0
            SDIO_EN_INITI: u1,
            /// tune current limit threshold when tieh = 0. About 800mA/(8+d)
            SDIO_DCURLIM: u3,
            /// select current limit mode
            SDIO_MODECURLIM: u1,
            /// enable current limit
            SDIO_ENCURLIM: u1,
            /// power down SDIO_REG in sleep. Only active when reg_sdio_force = 0
            SDIO_REG_PD_EN: u1,
            /// 1: use SW option to control SDIO_REG
            SDIO_FORCE: u1,
            /// SW option for SDIO_TIEH. Only active when reg_sdio_force = 1
            SDIO_TIEH: u1,
            /// read only register for REG1P8_READY
            _1P8_READY: u1,
            /// SW option for DREFL_SDIO. Only active when reg_sdio_force = 1
            DREFL_SDIO: u2,
            /// SW option for DREFM_SDIO. Only active when reg_sdio_force = 1
            DREFM_SDIO: u2,
            /// SW option for DREFH_SDIO. Only active when reg_sdio_force = 1
            DREFH_SDIO: u2,
            XPD_SDIO: u1,
        }), base_address + 0x78);

        /// address: 0x6000807c
        /// rtc configure register
        pub const BIAS_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            DG_VDD_DRV_B_SLP: u8,
            DG_VDD_DRV_B_SLP_EN: u1,
            reserved0: u1,
            /// bias buf when rtc in normal work state
            BIAS_BUF_IDLE: u1,
            /// bias buf when rtc in wakeup state
            BIAS_BUF_WAKE: u1,
            /// bias buf when rtc in sleep state
            BIAS_BUF_DEEP_SLP: u1,
            /// bias buf when rtc in monitor state
            BIAS_BUF_MONITOR: u1,
            /// xpd cur when rtc in sleep_state
            PD_CUR_DEEP_SLP: u1,
            /// xpd cur when rtc in monitor state
            PD_CUR_MONITOR: u1,
            /// bias_sleep when rtc in sleep_state
            BIAS_SLEEP_DEEP_SLP: u1,
            /// bias_sleep when rtc in monitor state
            BIAS_SLEEP_MONITOR: u1,
            /// DBG_ATTEN when rtc in sleep state
            DBG_ATTEN_DEEP_SLP: u4,
            /// DBG_ATTEN when rtc in monitor state
            DBG_ATTEN_MONITOR: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x7c);

        /// address: 0x60008080
        /// rtc configure register
        pub const RTC_CNTL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// software enable digital regulator cali
            DIG_REG_CAL_EN: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// SCK_DCAP
            SCK_DCAP: u8,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// RTC_DBOOST force power down
            DBOOST_FORCE_PD: u1,
            /// RTC_DBOOST force power up
            DBOOST_FORCE_PU: u1,
            /// RTC_REG force power down (for RTC_REG power down means decrease the voltage to
            /// 0.8v or lower )
            REGULATOR_FORCE_PD: u1,
            /// RTC_REG force power up
            REGULATOR_FORCE_PU: u1,
        }), base_address + 0x80);

        /// address: 0x60008084
        /// rtc configure register
        pub const PWC = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// rtc pad force hold
            RTC_PAD_FORCE_HOLD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x84);

        /// address: 0x60008088
        /// rtc configure register
        pub const DIG_PWC = @intToPtr(*volatile Mmio(32, packed struct {
            /// vdd_spi drv's software value
            VDD_SPI_PWR_DRV: u2,
            /// vdd_spi drv use software value
            VDD_SPI_PWR_FORCE: u1,
            /// memories in digital core force PD in sleep
            LSLP_MEM_FORCE_PD: u1,
            /// memories in digital core force PU in sleep
            LSLP_MEM_FORCE_PU: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// bt force power down
            BT_FORCE_PD: u1,
            /// bt force power up
            BT_FORCE_PU: u1,
            /// digital peri force power down
            DG_PERI_FORCE_PD: u1,
            /// digital peri force power up
            DG_PERI_FORCE_PU: u1,
            /// fastmemory retention mode in sleep
            RTC_FASTMEM_FORCE_LPD: u1,
            /// fastmemory donlt entry retention mode in sleep
            RTC_FASTMEM_FORCE_LPU: u1,
            /// wifi force power down
            WIFI_FORCE_PD: u1,
            /// wifi force power up
            WIFI_FORCE_PU: u1,
            /// digital core force power down
            DG_WRAP_FORCE_PD: u1,
            /// digital core force power up
            DG_WRAP_FORCE_PU: u1,
            /// cpu core force power down
            CPU_TOP_FORCE_PD: u1,
            /// cpu force power up
            CPU_TOP_FORCE_PU: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// enable power down bt in sleep
            BT_PD_EN: u1,
            /// enable power down digital peri in sleep
            DG_PERI_PD_EN: u1,
            /// enable power down cpu in sleep
            CPU_TOP_PD_EN: u1,
            /// enable power down wifi in sleep
            WIFI_PD_EN: u1,
            /// enable power down digital wrap in sleep
            DG_WRAP_PD_EN: u1,
        }), base_address + 0x88);

        /// address: 0x6000808c
        /// rtc configure register
        pub const DIG_ISO = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// DIG_ISO force off
            FORCE_OFF: u1,
            /// DIG_ISO force on
            FORCE_ON: u1,
            /// read only register to indicate digital pad auto-hold status
            DG_PAD_AUTOHOLD: u1,
            /// wtite only register to clear digital pad auto-hold
            CLR_DG_PAD_AUTOHOLD: u1,
            /// digital pad enable auto-hold
            DG_PAD_AUTOHOLD_EN: u1,
            /// digital pad force no ISO
            DG_PAD_FORCE_NOISO: u1,
            /// digital pad force ISO
            DG_PAD_FORCE_ISO: u1,
            /// digital pad force un-hold
            DG_PAD_FORCE_UNHOLD: u1,
            /// digital pad force hold
            DG_PAD_FORCE_HOLD: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// bt force ISO
            BT_FORCE_ISO: u1,
            /// bt force no ISO
            BT_FORCE_NOISO: u1,
            /// Digital peri force ISO
            DG_PERI_FORCE_ISO: u1,
            /// digital peri force no ISO
            DG_PERI_FORCE_NOISO: u1,
            /// cpu force ISO
            CPU_TOP_FORCE_ISO: u1,
            /// cpu force no ISO
            CPU_TOP_FORCE_NOISO: u1,
            /// wifi force ISO
            WIFI_FORCE_ISO: u1,
            /// wifi force no ISO
            WIFI_FORCE_NOISO: u1,
            /// digital core force ISO
            DG_WRAP_FORCE_ISO: u1,
            /// digital core force no ISO
            DG_WRAP_FORCE_NOISO: u1,
        }), base_address + 0x8c);

        /// address: 0x60008090
        /// rtc configure register
        pub const WDTCONFIG0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// chip reset siginal pulse width
            WDT_CHIP_RESET_WIDTH: u8,
            /// wdt reset whole chip enable
            WDT_CHIP_RESET_EN: u1,
            /// pause WDT in sleep
            WDT_PAUSE_IN_SLP: u1,
            /// enable WDT reset APP CPU
            WDT_APPCPU_RESET_EN: u1,
            /// enable WDT reset PRO CPU
            WDT_PROCPU_RESET_EN: u1,
            /// enable WDT in flash boot
            WDT_FLASHBOOT_MOD_EN: u1,
            /// system reset counter length
            WDT_SYS_RESET_LENGTH: u3,
            /// CPU reset counter length
            WDT_CPU_RESET_LENGTH: u3,
            /// 1: interrupt stage en
            WDT_STG3: u3,
            /// 1: interrupt stage en
            WDT_STG2: u3,
            /// 1: interrupt stage en
            WDT_STG1: u3,
            /// 1: interrupt stage en
            WDT_STG0: u3,
            /// enable rtc wdt
            WDT_EN: u1,
        }), base_address + 0x90);

        /// address: 0x60008094
        /// rtc configure register
        pub const WDTCONFIG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// the hold time of stage0
            WDT_STG0_HOLD: u32,
        }), base_address + 0x94);

        /// address: 0x60008098
        /// rtc configure register
        pub const WDTCONFIG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// the hold time of stage1
            WDT_STG1_HOLD: u32,
        }), base_address + 0x98);

        /// address: 0x6000809c
        /// rtc configure register
        pub const WDTCONFIG3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// the hold time of stage2
            WDT_STG2_HOLD: u32,
        }), base_address + 0x9c);

        /// address: 0x600080a0
        /// rtc configure register
        pub const WDTCONFIG4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// the hold time of stage3
            WDT_STG3_HOLD: u32,
        }), base_address + 0xa0);

        /// address: 0x600080a4
        /// rtc configure register
        pub const WDTFEED = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// sw feed rtc wdt
            RTC_WDT_FEED: u1,
        }), base_address + 0xa4);

        /// address: 0x600080a8
        /// rtc configure register
        pub const WDTWPROTECT = @intToPtr(*volatile Mmio(32, packed struct {
            /// the key of rtc wdt
            WDT_WKEY: u32,
        }), base_address + 0xa8);

        /// address: 0x600080ac
        /// rtc configure register
        pub const SWD_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// swd reset flag
            SWD_RESET_FLAG: u1,
            /// swd interrupt for feeding
            SWD_FEED_INT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Bypass swd rst
            SWD_BYPASS_RST: u1,
            /// adjust signal width send to swd
            SWD_SIGNAL_WIDTH: u10,
            /// reset swd reset flag
            SWD_RST_FLAG_CLR: u1,
            /// Sw feed swd
            SWD_FEED: u1,
            /// disabel SWD
            SWD_DISABLE: u1,
            /// automatically feed swd when int comes
            SWD_AUTO_FEED_EN: u1,
        }), base_address + 0xac);

        /// address: 0x600080b0
        /// rtc configure register
        pub const SWD_WPROTECT = @intToPtr(*volatile Mmio(32, packed struct {
            /// the key of super wdt
            SWD_WKEY: u32,
        }), base_address + 0xb0);

        /// address: 0x600080b4
        /// rtc configure register
        pub const SW_CPU_STALL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// {reg_sw_stall_appcpu_c1[5:0]
            SW_STALL_APPCPU_C1: u6,
            /// stall cpu by software
            SW_STALL_PROCPU_C1: u6,
        }), base_address + 0xb4);

        /// address: 0x600080b8
        /// rtc configure register
        pub const STORE4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reserved register
            RTC_SCRATCH4: u32,
        }), base_address + 0xb8);

        /// address: 0x600080bc
        /// rtc configure register
        pub const STORE5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reserved register
            RTC_SCRATCH5: u32,
        }), base_address + 0xbc);

        /// address: 0x600080c0
        /// rtc configure register
        pub const STORE6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reserved register
            RTC_SCRATCH6: u32,
        }), base_address + 0xc0);

        /// address: 0x600080c4
        /// rtc configure register
        pub const STORE7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reserved register
            RTC_SCRATCH7: u32,
        }), base_address + 0xc4);

        /// address: 0x600080c8
        /// rtc configure register
        pub const LOW_POWER_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// rom0 power down
            XPD_ROM0: u1,
            reserved0: u1,
            /// External DCDC power down
            XPD_DIG_DCDC: u1,
            /// rtc peripheral iso
            RTC_PERI_ISO: u1,
            /// rtc peripheral power down
            XPD_RTC_PERI: u1,
            /// wifi iso
            WIFI_ISO: u1,
            /// wifi wrap power down
            XPD_WIFI: u1,
            /// digital wrap iso
            DIG_ISO: u1,
            /// digital wrap power down
            XPD_DIG: u1,
            /// touch should start to work
            RTC_TOUCH_STATE_START: u1,
            /// touch is about to working. Switch rtc main state
            RTC_TOUCH_STATE_SWITCH: u1,
            /// touch is in sleep state
            RTC_TOUCH_STATE_SLP: u1,
            /// touch is done
            RTC_TOUCH_STATE_DONE: u1,
            /// ulp/cocpu should start to work
            RTC_COCPU_STATE_START: u1,
            /// ulp/cocpu is about to working. Switch rtc main state
            RTC_COCPU_STATE_SWITCH: u1,
            /// ulp/cocpu is in sleep state
            RTC_COCPU_STATE_SLP: u1,
            /// ulp/cocpu is done
            RTC_COCPU_STATE_DONE: u1,
            /// no use any more
            RTC_MAIN_STATE_XTAL_ISO: u1,
            /// rtc main state machine is in states that pll should be running
            RTC_MAIN_STATE_PLL_ON: u1,
            /// rtc is ready to receive wake up trigger from wake up source
            RTC_RDY_FOR_WAKEUP: u1,
            /// rtc main state machine has been waited for some cycles
            RTC_MAIN_STATE_WAIT_END: u1,
            /// rtc main state machine is in the states of wakeup process
            RTC_IN_WAKEUP_STATE: u1,
            /// rtc main state machine is in the states of low power
            RTC_IN_LOW_POWER_STATE: u1,
            /// rtc main state machine is in wait 8m state
            RTC_MAIN_STATE_IN_WAIT_8M: u1,
            /// rtc main state machine is in wait pll state
            RTC_MAIN_STATE_IN_WAIT_PLL: u1,
            /// rtc main state machine is in wait xtal state
            RTC_MAIN_STATE_IN_WAIT_XTL: u1,
            /// rtc main state machine is in sleep state
            RTC_MAIN_STATE_IN_SLP: u1,
            /// rtc main state machine is in idle state
            RTC_MAIN_STATE_IN_IDLE: u1,
            /// rtc main state machine status
            RTC_MAIN_STATE: u4,
        }), base_address + 0xc8);

        /// address: 0x600080cc
        /// rtc configure register
        pub const DIAG0 = @intToPtr(*volatile Mmio(32, packed struct {
            RTC_LOW_POWER_DIAG1: u32,
        }), base_address + 0xcc);

        /// address: 0x600080d0
        /// rtc configure register
        pub const PAD_HOLD = @intToPtr(*volatile Mmio(32, packed struct {
            /// the hold configure of rtc gpio0
            RTC_GPIO_PIN0_HOLD: u1,
            /// the hold configure of rtc gpio1
            RTC_GPIO_PIN1_HOLD: u1,
            /// the hold configure of rtc gpio2
            RTC_GPIO_PIN2_HOLD: u1,
            /// the hold configure of rtc gpio3
            RTC_GPIO_PIN3_HOLD: u1,
            /// the hold configure of rtc gpio4
            RTC_GPIO_PIN4_HOLD: u1,
            /// the hold configure of rtc gpio5
            RTC_GPIO_PIN5_HOLD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xd0);

        /// address: 0x600080d4
        /// rtc configure register
        pub const DIG_PAD_HOLD = @intToPtr(*volatile u32, base_address + 0xd4);

        /// address: 0x600080d8
        /// rtc configure register
        pub const BROWN_OUT = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// brown out interrupt wait cycles
            INT_WAIT: u10,
            /// enable close flash when brown out happens
            CLOSE_FLASH_ENA: u1,
            /// enable power down RF when brown out happens
            PD_RF_ENA: u1,
            /// brown out reset wait cycles
            RST_WAIT: u10,
            /// enable brown out reset
            RST_ENA: u1,
            /// 1: 4-pos reset
            RST_SEL: u1,
            /// brown_out origin reset enable
            ANA_RST_EN: u1,
            /// clear brown out counter
            CNT_CLR: u1,
            /// enable brown out
            ENA: u1,
            /// the flag of brown det from analog
            DET: u1,
        }), base_address + 0xd8);

        /// address: 0x600080dc
        /// rtc configure register
        pub const TIME_LOW1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC timer low 32 bits
            RTC_TIMER_VALUE1_LOW: u32,
        }), base_address + 0xdc);

        /// address: 0x600080e0
        /// rtc configure register
        pub const TIME_HIGH1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC timer high 16 bits
            RTC_TIMER_VALUE1_HIGH: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xe0);

        /// address: 0x600080e4
        /// rtc configure register
        pub const XTAL32K_CLK_FACTOR = @intToPtr(*volatile u32, base_address + 0xe4);

        /// address: 0x600080e8
        /// rtc configure register
        pub const XTAL32K_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// cycles to wait to return noral xtal 32k
            XTAL32K_RETURN_WAIT: u4,
            /// cycles to wait to repower on xtal 32k
            XTAL32K_RESTART_WAIT: u16,
            /// If no clock detected for this amount of time
            XTAL32K_WDT_TIMEOUT: u8,
            /// if restarted xtal32k period is smaller than this
            XTAL32K_STABLE_THRES: u4,
        }), base_address + 0xe8);

        /// address: 0x600080ec
        /// rtc configure register
        pub const USB_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// disable io_mux reset
            IO_MUX_RESET_DISABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xec);

        /// address: 0x600080f0
        /// RTC_CNTL_RTC_SLP_REJECT_CAUSE_REG
        pub const SLP_REJECT_CAUSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// sleep reject cause
            REJECT_CAUSE: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0xf0);

        /// address: 0x600080f4
        /// rtc configure register
        pub const OPTION1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// force chip entry download mode
            FORCE_DOWNLOAD_BOOT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xf4);

        /// address: 0x600080f8
        /// RTC_CNTL_RTC_SLP_WAKEUP_CAUSE_REG
        pub const SLP_WAKEUP_CAUSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// sleep wakeup cause
            WAKEUP_CAUSE: u17,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xf8);

        /// address: 0x600080fc
        /// rtc configure register
        pub const ULP_CP_TIMER_1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// sleep cycles for ULP-coprocessor timer
            ULP_CP_TIMER_SLP_CYCLE: u24,
        }), base_address + 0xfc);

        /// address: 0x60008100
        /// rtc configure register
        pub const INT_ENA_RTC_W1TS = @intToPtr(*volatile Mmio(32, packed struct {
            /// enable sleep wakeup interrupt
            SLP_WAKEUP_INT_ENA_W1TS: u1,
            /// enable sleep reject interrupt
            SLP_REJECT_INT_ENA_W1TS: u1,
            reserved0: u1,
            /// enable RTC WDT interrupt
            RTC_WDT_INT_ENA_W1TS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// enable brown out interrupt
            RTC_BROWN_OUT_INT_ENA_W1TS: u1,
            /// enable RTC main timer interrupt
            RTC_MAIN_TIMER_INT_ENA_W1TS: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// enable super watch dog interrupt
            RTC_SWD_INT_ENA_W1TS: u1,
            /// enable xtal32k_dead interrupt
            RTC_XTAL32K_DEAD_INT_ENA_W1TS: u1,
            reserved10: u1,
            reserved11: u1,
            /// enbale gitch det interrupt
            RTC_GLITCH_DET_INT_ENA_W1TS: u1,
            /// enbale bbpll cal interrupt
            RTC_BBPLL_CAL_INT_ENA_W1TS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x100);

        /// address: 0x60008104
        /// rtc configure register
        pub const INT_ENA_RTC_W1TC = @intToPtr(*volatile Mmio(32, packed struct {
            /// clear sleep wakeup interrupt enable
            SLP_WAKEUP_INT_ENA_W1TC: u1,
            /// clear sleep reject interrupt enable
            SLP_REJECT_INT_ENA_W1TC: u1,
            reserved0: u1,
            /// clear RTC WDT interrupt enable
            RTC_WDT_INT_ENA_W1TC: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// clear brown out interrupt enable
            RTC_BROWN_OUT_INT_ENA_W1TC: u1,
            /// Clear RTC main timer interrupt enable
            RTC_MAIN_TIMER_INT_ENA_W1TC: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// clear super watch dog interrupt enable
            RTC_SWD_INT_ENA_W1TC: u1,
            /// clear xtal32k_dead interrupt enable
            RTC_XTAL32K_DEAD_INT_ENA_W1TC: u1,
            reserved10: u1,
            reserved11: u1,
            /// clear gitch det interrupt enable
            RTC_GLITCH_DET_INT_ENA_W1TC: u1,
            /// clear bbpll cal interrupt enable
            RTC_BBPLL_CAL_INT_ENA_W1TC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x104);

        /// address: 0x60008108
        /// rtc configure register
        pub const RETENTION_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Retention clk sel
            RETENTION_CLK_SEL: u1,
            /// Retention done wait time
            RETENTION_DONE_WAIT: u3,
            /// Retention clkoff wait time
            RETENTION_CLKOFF_WAIT: u4,
            /// enable cpu retention when light sleep
            RETENTION_EN: u1,
            /// wait cycles for rention operation
            RETENTION_WAIT: u5,
        }), base_address + 0x108);

        /// address: 0x6000810c
        /// rtc configure register
        pub const FIB_SEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// select use analog fib signal
            RTC_FIB_SEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x10c);

        /// address: 0x60008110
        /// rtc configure register
        pub const GPIO_WAKEUP = @intToPtr(*volatile Mmio(32, packed struct {
            /// rtc gpio wakeup flag
            RTC_GPIO_WAKEUP_STATUS: u6,
            /// clear rtc gpio wakeup flag
            RTC_GPIO_WAKEUP_STATUS_CLR: u1,
            /// enable rtc io clk gate
            RTC_GPIO_PIN_CLK_GATE: u1,
            /// configure gpio wakeup type
            RTC_GPIO_PIN5_INT_TYPE: u3,
            /// configure gpio wakeup type
            RTC_GPIO_PIN4_INT_TYPE: u3,
            /// configure gpio wakeup type
            RTC_GPIO_PIN3_INT_TYPE: u3,
            /// configure gpio wakeup type
            RTC_GPIO_PIN2_INT_TYPE: u3,
            /// configure gpio wakeup type
            RTC_GPIO_PIN1_INT_TYPE: u3,
            /// configure gpio wakeup type
            RTC_GPIO_PIN0_INT_TYPE: u3,
            /// enable wakeup from rtc gpio5
            RTC_GPIO_PIN5_WAKEUP_ENABLE: u1,
            /// enable wakeup from rtc gpio4
            RTC_GPIO_PIN4_WAKEUP_ENABLE: u1,
            /// enable wakeup from rtc gpio3
            RTC_GPIO_PIN3_WAKEUP_ENABLE: u1,
            /// enable wakeup from rtc gpio2
            RTC_GPIO_PIN2_WAKEUP_ENABLE: u1,
            /// enable wakeup from rtc gpio1
            RTC_GPIO_PIN1_WAKEUP_ENABLE: u1,
            /// enable wakeup from rtc gpio0
            RTC_GPIO_PIN0_WAKEUP_ENABLE: u1,
        }), base_address + 0x110);

        /// address: 0x60008114
        /// rtc configure register
        pub const DBG_SEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// use for debug
            RTC_DEBUG_12M_NO_GATING: u1,
            /// use for debug
            RTC_DEBUG_BIT_SEL: u5,
            /// use for debug
            RTC_DEBUG_SEL0: u5,
            /// use for debug
            RTC_DEBUG_SEL1: u5,
            /// use for debug
            RTC_DEBUG_SEL2: u5,
            /// use for debug
            RTC_DEBUG_SEL3: u5,
            /// use for debug
            RTC_DEBUG_SEL4: u5,
        }), base_address + 0x114);

        /// address: 0x60008118
        /// rtc configure register
        pub const DBG_MAP = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// use for debug
            RTC_GPIO_PIN5_MUX_SEL: u1,
            /// use for debug
            RTC_GPIO_PIN4_MUX_SEL: u1,
            /// use for debug
            RTC_GPIO_PIN3_MUX_SEL: u1,
            /// use for debug
            RTC_GPIO_PIN2_MUX_SEL: u1,
            /// use for debug
            RTC_GPIO_PIN1_MUX_SEL: u1,
            /// use for debug
            RTC_GPIO_PIN0_MUX_SEL: u1,
            /// use for debug
            RTC_GPIO_PIN5_FUN_SEL: u4,
            /// use for debug
            RTC_GPIO_PIN4_FUN_SEL: u4,
            /// use for debug
            RTC_GPIO_PIN3_FUN_SEL: u4,
            /// use for debug
            RTC_GPIO_PIN2_FUN_SEL: u4,
            /// use for debug
            RTC_GPIO_PIN1_FUN_SEL: u4,
            /// use for debug
            RTC_GPIO_PIN0_FUN_SEL: u4,
        }), base_address + 0x118);

        /// address: 0x6000811c
        /// rtc configure register
        pub const SENSOR_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            /// reg_sar2_pwdet_cct
            SAR2_PWDET_CCT: u3,
            /// force power up SAR
            FORCE_XPD_SAR: u2,
        }), base_address + 0x11c);

        /// address: 0x60008120
        /// rtc configure register
        pub const DBG_SAR_SEL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            /// use for debug
            SAR_DEBUG_SEL: u5,
        }), base_address + 0x120);

        /// address: 0x60008124
        /// rtc configure register
        pub const PG_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// power glitch desense
            POWER_GLITCH_DSENSE: u2,
            /// force disable power glitch
            POWER_GLITCH_FORCE_PD: u1,
            /// force enable power glitch
            POWER_GLITCH_FORCE_PU: u1,
            /// use efuse value control power glitch enable
            POWER_GLITCH_EFUSE_SEL: u1,
            /// enable power glitch
            POWER_GLITCH_EN: u1,
        }), base_address + 0x124);

        /// address: 0x600081fc
        /// rtc configure register
        pub const DATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// verision
            RTC_CNTL_DATE: u28,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x1fc);
    };

    /// Sensitive
    pub const SENSITIVE = struct {
        pub const base_address = 0x600c1000;

        /// address: 0x600c1000
        /// SENSITIVE_ROM_TABLE_LOCK_REG
        pub const ROM_TABLE_LOCK = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x0);

        /// address: 0x600c1004
        /// SENSITIVE_ROM_TABLE_REG
        pub const ROM_TABLE = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x600c1008
        /// SENSITIVE_PRIVILEGE_MODE_SEL_LOCK_REG
        pub const PRIVILEGE_MODE_SEL_LOCK = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x8);

        /// address: 0x600c100c
        /// SENSITIVE_PRIVILEGE_MODE_SEL_REG
        pub const PRIVILEGE_MODE_SEL = @intToPtr(*volatile MmioInt(32, u1), base_address + 0xc);

        /// address: 0x600c1010
        /// SENSITIVE_APB_PERIPHERAL_ACCESS_0_REG
        pub const APB_PERIPHERAL_ACCESS_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// apb_peripheral_access_lock
            APB_PERIPHERAL_ACCESS_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x600c1014
        /// SENSITIVE_APB_PERIPHERAL_ACCESS_1_REG
        pub const APB_PERIPHERAL_ACCESS_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// apb_peripheral_access_split_burst
            APB_PERIPHERAL_ACCESS_SPLIT_BURST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x600c1018
        /// SENSITIVE_INTERNAL_SRAM_USAGE_0_REG
        pub const INTERNAL_SRAM_USAGE_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// internal_sram_usage_lock
            INTERNAL_SRAM_USAGE_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x18);

        /// address: 0x600c101c
        /// SENSITIVE_INTERNAL_SRAM_USAGE_1_REG
        pub const INTERNAL_SRAM_USAGE_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// internal_sram_usage_cpu_cache
            INTERNAL_SRAM_USAGE_CPU_CACHE: u1,
            /// internal_sram_usage_cpu_sram
            INTERNAL_SRAM_USAGE_CPU_SRAM: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x1c);

        /// address: 0x600c1020
        /// SENSITIVE_INTERNAL_SRAM_USAGE_3_REG
        pub const INTERNAL_SRAM_USAGE_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// internal_sram_usage_mac_dump_sram
            INTERNAL_SRAM_USAGE_MAC_DUMP_SRAM: u3,
            /// internal_sram_alloc_mac_dump
            INTERNAL_SRAM_ALLOC_MAC_DUMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x600c1024
        /// SENSITIVE_INTERNAL_SRAM_USAGE_4_REG
        pub const INTERNAL_SRAM_USAGE_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// internal_sram_usage_log_sram
            INTERNAL_SRAM_USAGE_LOG_SRAM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x24);

        /// address: 0x600c1028
        /// SENSITIVE_CACHE_TAG_ACCESS_0_REG
        pub const CACHE_TAG_ACCESS_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// cache_tag_access_lock
            CACHE_TAG_ACCESS_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x28);

        /// address: 0x600c102c
        /// SENSITIVE_CACHE_TAG_ACCESS_1_REG
        pub const CACHE_TAG_ACCESS_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// pro_i_tag_rd_acs
            PRO_I_TAG_RD_ACS: u1,
            /// pro_i_tag_wr_acs
            PRO_I_TAG_WR_ACS: u1,
            /// pro_d_tag_rd_acs
            PRO_D_TAG_RD_ACS: u1,
            /// pro_d_tag_wr_acs
            PRO_D_TAG_WR_ACS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x2c);

        /// address: 0x600c1030
        /// SENSITIVE_CACHE_MMU_ACCESS_0_REG
        pub const CACHE_MMU_ACCESS_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// cache_mmu_access_lock
            CACHE_MMU_ACCESS_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x30);

        /// address: 0x600c1034
        /// SENSITIVE_CACHE_MMU_ACCESS_1_REG
        pub const CACHE_MMU_ACCESS_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// pro_mmu_rd_acs
            PRO_MMU_RD_ACS: u1,
            /// pro_mmu_wr_acs
            PRO_MMU_WR_ACS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x34);

        /// address: 0x600c1038
        /// SENSITIVE_DMA_APBPERI_SPI2_PMS_CONSTRAIN_0_REG
        pub const DMA_APBPERI_SPI2_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_spi2_pms_constrain_lock
            DMA_APBPERI_SPI2_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x38);

        /// address: 0x600c103c
        /// SENSITIVE_DMA_APBPERI_SPI2_PMS_CONSTRAIN_1_REG
        pub const DMA_APBPERI_SPI2_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_spi2_pms_constrain_sram_world_0_pms_0
            DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// dma_apbperi_spi2_pms_constrain_sram_world_0_pms_1
            DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// dma_apbperi_spi2_pms_constrain_sram_world_0_pms_2
            DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// dma_apbperi_spi2_pms_constrain_sram_world_0_pms_3
            DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// dma_apbperi_spi2_pms_constrain_sram_world_1_pms_0
            DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// dma_apbperi_spi2_pms_constrain_sram_world_1_pms_1
            DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// dma_apbperi_spi2_pms_constrain_sram_world_1_pms_2
            DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// dma_apbperi_spi2_pms_constrain_sram_world_1_pms_3
            DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x3c);

        /// address: 0x600c1040
        /// SENSITIVE_DMA_APBPERI_UCHI0_PMS_CONSTRAIN_0_REG
        pub const DMA_APBPERI_UCHI0_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_uchi0_pms_constrain_lock
            DMA_APBPERI_UCHI0_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x40);

        /// address: 0x600c1044
        /// SENSITIVE_DMA_APBPERI_UCHI0_PMS_CONSTRAIN_1_REG
        pub const DMA_APBPERI_UCHI0_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_uchi0_pms_constrain_sram_world_0_pms_0
            DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// dma_apbperi_uchi0_pms_constrain_sram_world_0_pms_1
            DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// dma_apbperi_uchi0_pms_constrain_sram_world_0_pms_2
            DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// dma_apbperi_uchi0_pms_constrain_sram_world_0_pms_3
            DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// dma_apbperi_uchi0_pms_constrain_sram_world_1_pms_0
            DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// dma_apbperi_uchi0_pms_constrain_sram_world_1_pms_1
            DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// dma_apbperi_uchi0_pms_constrain_sram_world_1_pms_2
            DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// dma_apbperi_uchi0_pms_constrain_sram_world_1_pms_3
            DMA_APBPERI_UCHI0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x44);

        /// address: 0x600c1048
        /// SENSITIVE_DMA_APBPERI_I2S0_PMS_CONSTRAIN_0_REG
        pub const DMA_APBPERI_I2S0_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_i2s0_pms_constrain_lock
            DMA_APBPERI_I2S0_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x48);

        /// address: 0x600c104c
        /// SENSITIVE_DMA_APBPERI_I2S0_PMS_CONSTRAIN_1_REG
        pub const DMA_APBPERI_I2S0_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_i2s0_pms_constrain_sram_world_0_pms_0
            DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// dma_apbperi_i2s0_pms_constrain_sram_world_0_pms_1
            DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// dma_apbperi_i2s0_pms_constrain_sram_world_0_pms_2
            DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// dma_apbperi_i2s0_pms_constrain_sram_world_0_pms_3
            DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// dma_apbperi_i2s0_pms_constrain_sram_world_1_pms_0
            DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// dma_apbperi_i2s0_pms_constrain_sram_world_1_pms_1
            DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// dma_apbperi_i2s0_pms_constrain_sram_world_1_pms_2
            DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// dma_apbperi_i2s0_pms_constrain_sram_world_1_pms_3
            DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4c);

        /// address: 0x600c1050
        /// SENSITIVE_DMA_APBPERI_MAC_PMS_CONSTRAIN_0_REG
        pub const DMA_APBPERI_MAC_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_mac_pms_constrain_lock
            DMA_APBPERI_MAC_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x50);

        /// address: 0x600c1054
        /// SENSITIVE_DMA_APBPERI_MAC_PMS_CONSTRAIN_1_REG
        pub const DMA_APBPERI_MAC_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_mac_pms_constrain_sram_world_0_pms_0
            DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// dma_apbperi_mac_pms_constrain_sram_world_0_pms_1
            DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// dma_apbperi_mac_pms_constrain_sram_world_0_pms_2
            DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// dma_apbperi_mac_pms_constrain_sram_world_0_pms_3
            DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// dma_apbperi_mac_pms_constrain_sram_world_1_pms_0
            DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// dma_apbperi_mac_pms_constrain_sram_world_1_pms_1
            DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// dma_apbperi_mac_pms_constrain_sram_world_1_pms_2
            DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// dma_apbperi_mac_pms_constrain_sram_world_1_pms_3
            DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x54);

        /// address: 0x600c1058
        /// SENSITIVE_DMA_APBPERI_BACKUP_PMS_CONSTRAIN_0_REG
        pub const DMA_APBPERI_BACKUP_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_backup_pms_constrain_lock
            DMA_APBPERI_BACKUP_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x58);

        /// address: 0x600c105c
        /// SENSITIVE_DMA_APBPERI_BACKUP_PMS_CONSTRAIN_1_REG
        pub const DMA_APBPERI_BACKUP_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_backup_pms_constrain_sram_world_0_pms_0
            DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// dma_apbperi_backup_pms_constrain_sram_world_0_pms_1
            DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// dma_apbperi_backup_pms_constrain_sram_world_0_pms_2
            DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// dma_apbperi_backup_pms_constrain_sram_world_0_pms_3
            DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// dma_apbperi_backup_pms_constrain_sram_world_1_pms_0
            DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// dma_apbperi_backup_pms_constrain_sram_world_1_pms_1
            DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// dma_apbperi_backup_pms_constrain_sram_world_1_pms_2
            DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// dma_apbperi_backup_pms_constrain_sram_world_1_pms_3
            DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x5c);

        /// address: 0x600c1060
        /// SENSITIVE_DMA_APBPERI_LC_PMS_CONSTRAIN_0_REG
        pub const DMA_APBPERI_LC_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_lc_pms_constrain_lock
            DMA_APBPERI_LC_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x60);

        /// address: 0x600c1064
        /// SENSITIVE_DMA_APBPERI_LC_PMS_CONSTRAIN_1_REG
        pub const DMA_APBPERI_LC_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_lc_pms_constrain_sram_world_0_pms_0
            DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// dma_apbperi_lc_pms_constrain_sram_world_0_pms_1
            DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// dma_apbperi_lc_pms_constrain_sram_world_0_pms_2
            DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// dma_apbperi_lc_pms_constrain_sram_world_0_pms_3
            DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// dma_apbperi_lc_pms_constrain_sram_world_1_pms_0
            DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// dma_apbperi_lc_pms_constrain_sram_world_1_pms_1
            DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// dma_apbperi_lc_pms_constrain_sram_world_1_pms_2
            DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// dma_apbperi_lc_pms_constrain_sram_world_1_pms_3
            DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x64);

        /// address: 0x600c1068
        /// SENSITIVE_DMA_APBPERI_AES_PMS_CONSTRAIN_0_REG
        pub const DMA_APBPERI_AES_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_aes_pms_constrain_lock
            DMA_APBPERI_AES_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x68);

        /// address: 0x600c106c
        /// SENSITIVE_DMA_APBPERI_AES_PMS_CONSTRAIN_1_REG
        pub const DMA_APBPERI_AES_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_aes_pms_constrain_sram_world_0_pms_0
            DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// dma_apbperi_aes_pms_constrain_sram_world_0_pms_1
            DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// dma_apbperi_aes_pms_constrain_sram_world_0_pms_2
            DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// dma_apbperi_aes_pms_constrain_sram_world_0_pms_3
            DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// dma_apbperi_aes_pms_constrain_sram_world_1_pms_0
            DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// dma_apbperi_aes_pms_constrain_sram_world_1_pms_1
            DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// dma_apbperi_aes_pms_constrain_sram_world_1_pms_2
            DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// dma_apbperi_aes_pms_constrain_sram_world_1_pms_3
            DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x6c);

        /// address: 0x600c1070
        /// SENSITIVE_DMA_APBPERI_SHA_PMS_CONSTRAIN_0_REG
        pub const DMA_APBPERI_SHA_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_sha_pms_constrain_lock
            DMA_APBPERI_SHA_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x70);

        /// address: 0x600c1074
        /// SENSITIVE_DMA_APBPERI_SHA_PMS_CONSTRAIN_1_REG
        pub const DMA_APBPERI_SHA_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_sha_pms_constrain_sram_world_0_pms_0
            DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// dma_apbperi_sha_pms_constrain_sram_world_0_pms_1
            DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// dma_apbperi_sha_pms_constrain_sram_world_0_pms_2
            DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// dma_apbperi_sha_pms_constrain_sram_world_0_pms_3
            DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// dma_apbperi_sha_pms_constrain_sram_world_1_pms_0
            DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// dma_apbperi_sha_pms_constrain_sram_world_1_pms_1
            DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// dma_apbperi_sha_pms_constrain_sram_world_1_pms_2
            DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// dma_apbperi_sha_pms_constrain_sram_world_1_pms_3
            DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x74);

        /// address: 0x600c1078
        /// SENSITIVE_DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_0_REG
        pub const DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_adc_dac_pms_constrain_lock
            DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x78);

        /// address: 0x600c107c
        /// SENSITIVE_DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_1_REG
        pub const DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_adc_dac_pms_constrain_sram_world_0_pms_0
            DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// dma_apbperi_adc_dac_pms_constrain_sram_world_0_pms_1
            DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// dma_apbperi_adc_dac_pms_constrain_sram_world_0_pms_2
            DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// dma_apbperi_adc_dac_pms_constrain_sram_world_0_pms_3
            DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// dma_apbperi_adc_dac_pms_constrain_sram_world_1_pms_0
            DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// dma_apbperi_adc_dac_pms_constrain_sram_world_1_pms_1
            DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// dma_apbperi_adc_dac_pms_constrain_sram_world_1_pms_2
            DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// dma_apbperi_adc_dac_pms_constrain_sram_world_1_pms_3
            DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x7c);

        /// address: 0x600c1080
        /// SENSITIVE_DMA_APBPERI_PMS_MONITOR_0_REG
        pub const DMA_APBPERI_PMS_MONITOR_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_pms_monitor_lock
            DMA_APBPERI_PMS_MONITOR_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x80);

        /// address: 0x600c1084
        /// SENSITIVE_DMA_APBPERI_PMS_MONITOR_1_REG
        pub const DMA_APBPERI_PMS_MONITOR_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_pms_monitor_violate_clr
            DMA_APBPERI_PMS_MONITOR_VIOLATE_CLR: u1,
            /// dma_apbperi_pms_monitor_violate_en
            DMA_APBPERI_PMS_MONITOR_VIOLATE_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x84);

        /// address: 0x600c1088
        /// SENSITIVE_DMA_APBPERI_PMS_MONITOR_2_REG
        pub const DMA_APBPERI_PMS_MONITOR_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_pms_monitor_violate_intr
            DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR: u1,
            /// dma_apbperi_pms_monitor_violate_status_world
            DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_WORLD: u2,
            /// dma_apbperi_pms_monitor_violate_status_addr
            DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_ADDR: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x88);

        /// address: 0x600c108c
        /// SENSITIVE_DMA_APBPERI_PMS_MONITOR_3_REG
        pub const DMA_APBPERI_PMS_MONITOR_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// dma_apbperi_pms_monitor_violate_status_wr
            DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_WR: u1,
            /// dma_apbperi_pms_monitor_violate_status_byteen
            DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_BYTEEN: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x8c);

        /// address: 0x600c1090
        /// SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0_REG
        pub const CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_iram0_dram0_dma_split_line_constrain_lock
            CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x90);

        /// address: 0x600c1094
        /// SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1_REG
        pub const CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_iram0_dram0_dma_sram_category_0
            CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_0: u2,
            /// core_x_iram0_dram0_dma_sram_category_1
            CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_1: u2,
            /// core_x_iram0_dram0_dma_sram_category_2
            CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_2: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// core_x_iram0_dram0_dma_sram_splitaddr
            CORE_X_IRAM0_DRAM0_DMA_SRAM_SPLITADDR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x94);

        /// address: 0x600c1098
        /// SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2_REG
        pub const CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_iram0_sram_line_0_category_0
            CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_0: u2,
            /// core_x_iram0_sram_line_0_category_1
            CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_1: u2,
            /// core_x_iram0_sram_line_0_category_2
            CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_2: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// core_x_iram0_sram_line_0_splitaddr
            CORE_X_IRAM0_SRAM_LINE_0_SPLITADDR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x98);

        /// address: 0x600c109c
        /// SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3_REG
        pub const CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_iram0_sram_line_1_category_0
            CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_0: u2,
            /// core_x_iram0_sram_line_1_category_1
            CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_1: u2,
            /// core_x_iram0_sram_line_1_category_2
            CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_2: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// core_x_iram0_sram_line_1_splitaddr
            CORE_X_IRAM0_SRAM_LINE_1_SPLITADDR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x9c);

        /// address: 0x600c10a0
        /// SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4_REG
        pub const CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_dram0_dma_sram_line_0_category_0
            CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_0: u2,
            /// core_x_dram0_dma_sram_line_0_category_1
            CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_1: u2,
            /// core_x_dram0_dma_sram_line_0_category_2
            CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_2: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// core_x_dram0_dma_sram_line_0_splitaddr
            CORE_X_DRAM0_DMA_SRAM_LINE_0_SPLITADDR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0xa0);

        /// address: 0x600c10a4
        /// SENSITIVE_CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5_REG
        pub const CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_dram0_dma_sram_line_1_category_0
            CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_0: u2,
            /// core_x_dram0_dma_sram_line_1_category_1
            CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_1: u2,
            /// core_x_dram0_dma_sram_line_1_category_2
            CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_2: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// core_x_dram0_dma_sram_line_1_splitaddr
            CORE_X_DRAM0_DMA_SRAM_LINE_1_SPLITADDR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0xa4);

        /// address: 0x600c10a8
        /// SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_0_REG
        pub const CORE_X_IRAM0_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_iram0_pms_constrain_lock
            CORE_X_IRAM0_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xa8);

        /// address: 0x600c10ac
        /// SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_1_REG
        pub const CORE_X_IRAM0_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_iram0_pms_constrain_sram_world_1_pms_0
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u3,
            /// core_x_iram0_pms_constrain_sram_world_1_pms_1
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u3,
            /// core_x_iram0_pms_constrain_sram_world_1_pms_2
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u3,
            /// core_x_iram0_pms_constrain_sram_world_1_pms_3
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u3,
            /// core_x_iram0_pms_constrain_sram_world_1_cachedataarray_pms_0
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_0: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// core_x_iram0_pms_constrain_rom_world_1_pms
            CORE_X_IRAM0_PMS_CONSTRAIN_ROM_WORLD_1_PMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0xac);

        /// address: 0x600c10b0
        /// SENSITIVE_CORE_X_IRAM0_PMS_CONSTRAIN_2_REG
        pub const CORE_X_IRAM0_PMS_CONSTRAIN_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_iram0_pms_constrain_sram_world_0_pms_0
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u3,
            /// core_x_iram0_pms_constrain_sram_world_0_pms_1
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u3,
            /// core_x_iram0_pms_constrain_sram_world_0_pms_2
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u3,
            /// core_x_iram0_pms_constrain_sram_world_0_pms_3
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u3,
            /// core_x_iram0_pms_constrain_sram_world_0_cachedataarray_pms_0
            CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// core_x_iram0_pms_constrain_rom_world_0_pms
            CORE_X_IRAM0_PMS_CONSTRAIN_ROM_WORLD_0_PMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0xb0);

        /// address: 0x600c10b4
        /// SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_0_REG
        pub const CORE_0_IRAM0_PMS_MONITOR_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_iram0_pms_monitor_lock
            CORE_0_IRAM0_PMS_MONITOR_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xb4);

        /// address: 0x600c10b8
        /// SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_1_REG
        pub const CORE_0_IRAM0_PMS_MONITOR_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_iram0_pms_monitor_violate_clr
            CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR: u1,
            /// core_0_iram0_pms_monitor_violate_en
            CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xb8);

        /// address: 0x600c10bc
        /// SENSITIVE_CORE_0_IRAM0_PMS_MONITOR_2_REG
        pub const CORE_0_IRAM0_PMS_MONITOR_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_iram0_pms_monitor_violate_intr
            CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR: u1,
            /// core_0_iram0_pms_monitor_violate_status_wr
            CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WR: u1,
            /// core_0_iram0_pms_monitor_violate_status_loadstore
            CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_LOADSTORE: u1,
            /// core_0_iram0_pms_monitor_violate_status_world
            CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD: u2,
            /// core_0_iram0_pms_monitor_violate_status_addr
            CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xbc);

        /// address: 0x600c10c0
        /// SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_0_REG
        pub const CORE_X_DRAM0_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_dram0_pms_constrain_lock
            CORE_X_DRAM0_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xc0);

        /// address: 0x600c10c4
        /// SENSITIVE_CORE_X_DRAM0_PMS_CONSTRAIN_1_REG
        pub const CORE_X_DRAM0_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_x_dram0_pms_constrain_sram_world_0_pms_0
            CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0: u2,
            /// core_x_dram0_pms_constrain_sram_world_0_pms_1
            CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1: u2,
            /// core_x_dram0_pms_constrain_sram_world_0_pms_2
            CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2: u2,
            /// core_x_dram0_pms_constrain_sram_world_0_pms_3
            CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// core_x_dram0_pms_constrain_sram_world_1_pms_0
            CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0: u2,
            /// core_x_dram0_pms_constrain_sram_world_1_pms_1
            CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1: u2,
            /// core_x_dram0_pms_constrain_sram_world_1_pms_2
            CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2: u2,
            /// core_x_dram0_pms_constrain_sram_world_1_pms_3
            CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// core_x_dram0_pms_constrain_rom_world_0_pms
            CORE_X_DRAM0_PMS_CONSTRAIN_ROM_WORLD_0_PMS: u2,
            /// core_x_dram0_pms_constrain_rom_world_1_pms
            CORE_X_DRAM0_PMS_CONSTRAIN_ROM_WORLD_1_PMS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xc4);

        /// address: 0x600c10c8
        /// SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_0_REG
        pub const CORE_0_DRAM0_PMS_MONITOR_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_dram0_pms_monitor_lock
            CORE_0_DRAM0_PMS_MONITOR_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xc8);

        /// address: 0x600c10cc
        /// SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_1_REG
        pub const CORE_0_DRAM0_PMS_MONITOR_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_dram0_pms_monitor_violate_clr
            CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR: u1,
            /// core_0_dram0_pms_monitor_violate_en
            CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xcc);

        /// address: 0x600c10d0
        /// SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_2_REG
        pub const CORE_0_DRAM0_PMS_MONITOR_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_dram0_pms_monitor_violate_intr
            CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR: u1,
            /// core_0_dram0_pms_monitor_violate_status_lock
            CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_LOCK: u1,
            /// core_0_dram0_pms_monitor_violate_status_world
            CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD: u2,
            /// core_0_dram0_pms_monitor_violate_status_addr
            CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xd0);

        /// address: 0x600c10d4
        /// SENSITIVE_CORE_0_DRAM0_PMS_MONITOR_3_REG
        pub const CORE_0_DRAM0_PMS_MONITOR_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_dram0_pms_monitor_violate_status_wr
            CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WR: u1,
            /// core_0_dram0_pms_monitor_violate_status_byteen
            CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_BYTEEN: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xd4);

        /// address: 0x600c10d8
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_0_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_constrain_lock
            CORE_0_PIF_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xd8);

        /// address: 0x600c10dc
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_1_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_constrain_world_0_uart
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART: u2,
            /// core_0_pif_pms_constrain_world_0_g0spi_1
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_1: u2,
            /// core_0_pif_pms_constrain_world_0_g0spi_0
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_0: u2,
            /// core_0_pif_pms_constrain_world_0_gpio
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_GPIO: u2,
            /// core_0_pif_pms_constrain_world_0_fe2
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_FE2: u2,
            /// core_0_pif_pms_constrain_world_0_fe
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_FE: u2,
            /// core_0_pif_pms_constrain_world_0_timer
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMER: u2,
            /// core_0_pif_pms_constrain_world_0_rtc
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RTC: u2,
            /// core_0_pif_pms_constrain_world_0_io_mux
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_IO_MUX: u2,
            /// core_0_pif_pms_constrain_world_0_wdg
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WDG: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// core_0_pif_pms_constrain_world_0_misc
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_MISC: u2,
            /// core_0_pif_pms_constrain_world_0_i2c
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C: u2,
            reserved4: u1,
            reserved5: u1,
            /// core_0_pif_pms_constrain_world_0_uart1
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART1: u2,
        }), base_address + 0xdc);

        /// address: 0x600c10e0
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_2_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_constrain_world_0_bt
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BT: u2,
            reserved0: u1,
            reserved1: u1,
            /// core_0_pif_pms_constrain_world_0_i2c_ext0
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT0: u2,
            /// core_0_pif_pms_constrain_world_0_uhci0
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UHCI0: u2,
            reserved2: u1,
            reserved3: u1,
            /// core_0_pif_pms_constrain_world_0_rmt
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RMT: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// core_0_pif_pms_constrain_world_0_ledc
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_LEDC: u2,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// core_0_pif_pms_constrain_world_0_bb
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BB: u2,
            reserved12: u1,
            reserved13: u1,
            /// core_0_pif_pms_constrain_world_0_timergroup
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP: u2,
            /// core_0_pif_pms_constrain_world_0_timergroup1
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP1: u2,
            /// core_0_pif_pms_constrain_world_0_systimer
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SYSTIMER: u2,
        }), base_address + 0xe0);

        /// address: 0x600c10e4
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_3_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_constrain_world_0_spi_2
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SPI_2: u2,
            reserved0: u1,
            reserved1: u1,
            /// core_0_pif_pms_constrain_world_0_apb_ctrl
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_APB_CTRL: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// core_0_pif_pms_constrain_world_0_can
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CAN: u2,
            reserved6: u1,
            reserved7: u1,
            /// core_0_pif_pms_constrain_world_0_i2s1
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2S1: u2,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// core_0_pif_pms_constrain_world_0_rwbt
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RWBT: u2,
            reserved14: u1,
            reserved15: u1,
            /// core_0_pif_pms_constrain_world_0_wifimac
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WIFIMAC: u2,
            /// core_0_pif_pms_constrain_world_0_pwr
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PWR: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xe4);

        /// address: 0x600c10e8
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_4_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_4 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// core_0_pif_pms_constrain_world_0_usb_wrap
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB_WRAP: u2,
            /// core_0_pif_pms_constrain_world_0_crypto_peri
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_PERI: u2,
            /// core_0_pif_pms_constrain_world_0_crypto_dma
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_DMA: u2,
            /// core_0_pif_pms_constrain_world_0_apb_adc
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_APB_ADC: u2,
            reserved2: u1,
            reserved3: u1,
            /// core_0_pif_pms_constrain_world_0_bt_pwr
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BT_PWR: u2,
            /// core_0_pif_pms_constrain_world_0_usb_device
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB_DEVICE: u2,
            /// core_0_pif_pms_constrain_world_0_system
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SYSTEM: u2,
            /// core_0_pif_pms_constrain_world_0_sensitive
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SENSITIVE: u2,
            /// core_0_pif_pms_constrain_world_0_interrupt
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_INTERRUPT: u2,
            /// core_0_pif_pms_constrain_world_0_dma_copy
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_DMA_COPY: u2,
            /// core_0_pif_pms_constrain_world_0_cache_config
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CACHE_CONFIG: u2,
            /// core_0_pif_pms_constrain_world_0_ad
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_AD: u2,
            /// core_0_pif_pms_constrain_world_0_dio
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_DIO: u2,
            /// core_0_pif_pms_constrain_world_0_world_controller
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WORLD_CONTROLLER: u2,
        }), base_address + 0xe8);

        /// address: 0x600c10ec
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_5_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_constrain_world_1_uart
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART: u2,
            /// core_0_pif_pms_constrain_world_1_g0spi_1
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_1: u2,
            /// core_0_pif_pms_constrain_world_1_g0spi_0
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_0: u2,
            /// core_0_pif_pms_constrain_world_1_gpio
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_GPIO: u2,
            /// core_0_pif_pms_constrain_world_1_fe2
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_FE2: u2,
            /// core_0_pif_pms_constrain_world_1_fe
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_FE: u2,
            /// core_0_pif_pms_constrain_world_1_timer
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMER: u2,
            /// core_0_pif_pms_constrain_world_1_rtc
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RTC: u2,
            /// core_0_pif_pms_constrain_world_1_io_mux
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_IO_MUX: u2,
            /// core_0_pif_pms_constrain_world_1_wdg
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WDG: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// core_0_pif_pms_constrain_world_1_misc
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_MISC: u2,
            /// core_0_pif_pms_constrain_world_1_i2c
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C: u2,
            reserved4: u1,
            reserved5: u1,
            /// core_0_pif_pms_constrain_world_1_uart1
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART1: u2,
        }), base_address + 0xec);

        /// address: 0x600c10f0
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_6_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_constrain_world_1_bt
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BT: u2,
            reserved0: u1,
            reserved1: u1,
            /// core_0_pif_pms_constrain_world_1_i2c_ext0
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT0: u2,
            /// core_0_pif_pms_constrain_world_1_uhci0
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UHCI0: u2,
            reserved2: u1,
            reserved3: u1,
            /// core_0_pif_pms_constrain_world_1_rmt
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RMT: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// core_0_pif_pms_constrain_world_1_ledc
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_LEDC: u2,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// core_0_pif_pms_constrain_world_1_bb
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BB: u2,
            reserved12: u1,
            reserved13: u1,
            /// core_0_pif_pms_constrain_world_1_timergroup
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP: u2,
            /// core_0_pif_pms_constrain_world_1_timergroup1
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP1: u2,
            /// core_0_pif_pms_constrain_world_1_systimer
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SYSTIMER: u2,
        }), base_address + 0xf0);

        /// address: 0x600c10f4
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_7_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_constrain_world_1_spi_2
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SPI_2: u2,
            reserved0: u1,
            reserved1: u1,
            /// core_0_pif_pms_constrain_world_1_apb_ctrl
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_APB_CTRL: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// core_0_pif_pms_constrain_world_1_can
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CAN: u2,
            reserved6: u1,
            reserved7: u1,
            /// core_0_pif_pms_constrain_world_1_i2s1
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2S1: u2,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// core_0_pif_pms_constrain_world_1_rwbt
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RWBT: u2,
            reserved14: u1,
            reserved15: u1,
            /// core_0_pif_pms_constrain_world_1_wifimac
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WIFIMAC: u2,
            /// core_0_pif_pms_constrain_world_1_pwr
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PWR: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0xf4);

        /// address: 0x600c10f8
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_8_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_8 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// core_0_pif_pms_constrain_world_1_usb_wrap
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB_WRAP: u2,
            /// core_0_pif_pms_constrain_world_1_crypto_peri
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_PERI: u2,
            /// core_0_pif_pms_constrain_world_1_crypto_dma
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_DMA: u2,
            /// core_0_pif_pms_constrain_world_1_apb_adc
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_APB_ADC: u2,
            reserved2: u1,
            reserved3: u1,
            /// core_0_pif_pms_constrain_world_1_bt_pwr
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BT_PWR: u2,
            /// core_0_pif_pms_constrain_world_1_usb_device
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB_DEVICE: u2,
            /// core_0_pif_pms_constrain_world_1_system
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SYSTEM: u2,
            /// core_0_pif_pms_constrain_world_1_sensitive
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SENSITIVE: u2,
            /// core_0_pif_pms_constrain_world_1_interrupt
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_INTERRUPT: u2,
            /// core_0_pif_pms_constrain_world_1_dma_copy
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_DMA_COPY: u2,
            /// core_0_pif_pms_constrain_world_1_cache_config
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CACHE_CONFIG: u2,
            /// core_0_pif_pms_constrain_world_1_ad
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_AD: u2,
            /// core_0_pif_pms_constrain_world_1_dio
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_DIO: u2,
            /// core_0_pif_pms_constrain_world_1_world_controller
            CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WORLD_CONTROLLER: u2,
        }), base_address + 0xf8);

        /// address: 0x600c10fc
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_9_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_constrain_rtcfast_spltaddr_world_0
            CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0: u11,
            /// core_0_pif_pms_constrain_rtcfast_spltaddr_world_1
            CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0xfc);

        /// address: 0x600c1100
        /// SENSITIVE_CORE_0_PIF_PMS_CONSTRAIN_10_REG
        pub const CORE_0_PIF_PMS_CONSTRAIN_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_constrain_rtcfast_world_0_l
            CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L: u3,
            /// core_0_pif_pms_constrain_rtcfast_world_0_h
            CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H: u3,
            /// core_0_pif_pms_constrain_rtcfast_world_1_l
            CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L: u3,
            /// core_0_pif_pms_constrain_rtcfast_world_1_h
            CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x100);

        /// address: 0x600c1104
        /// SENSITIVE_REGION_PMS_CONSTRAIN_0_REG
        pub const REGION_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_lock
            REGION_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x104);

        /// address: 0x600c1108
        /// SENSITIVE_REGION_PMS_CONSTRAIN_1_REG
        pub const REGION_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_world_0_area_0
            REGION_PMS_CONSTRAIN_WORLD_0_AREA_0: u2,
            /// region_pms_constrain_world_0_area_1
            REGION_PMS_CONSTRAIN_WORLD_0_AREA_1: u2,
            /// region_pms_constrain_world_0_area_2
            REGION_PMS_CONSTRAIN_WORLD_0_AREA_2: u2,
            /// region_pms_constrain_world_0_area_3
            REGION_PMS_CONSTRAIN_WORLD_0_AREA_3: u2,
            /// region_pms_constrain_world_0_area_4
            REGION_PMS_CONSTRAIN_WORLD_0_AREA_4: u2,
            /// region_pms_constrain_world_0_area_5
            REGION_PMS_CONSTRAIN_WORLD_0_AREA_5: u2,
            /// region_pms_constrain_world_0_area_6
            REGION_PMS_CONSTRAIN_WORLD_0_AREA_6: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x108);

        /// address: 0x600c110c
        /// SENSITIVE_REGION_PMS_CONSTRAIN_2_REG
        pub const REGION_PMS_CONSTRAIN_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_world_1_area_0
            REGION_PMS_CONSTRAIN_WORLD_1_AREA_0: u2,
            /// region_pms_constrain_world_1_area_1
            REGION_PMS_CONSTRAIN_WORLD_1_AREA_1: u2,
            /// region_pms_constrain_world_1_area_2
            REGION_PMS_CONSTRAIN_WORLD_1_AREA_2: u2,
            /// region_pms_constrain_world_1_area_3
            REGION_PMS_CONSTRAIN_WORLD_1_AREA_3: u2,
            /// region_pms_constrain_world_1_area_4
            REGION_PMS_CONSTRAIN_WORLD_1_AREA_4: u2,
            /// region_pms_constrain_world_1_area_5
            REGION_PMS_CONSTRAIN_WORLD_1_AREA_5: u2,
            /// region_pms_constrain_world_1_area_6
            REGION_PMS_CONSTRAIN_WORLD_1_AREA_6: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x10c);

        /// address: 0x600c1110
        /// SENSITIVE_REGION_PMS_CONSTRAIN_3_REG
        pub const REGION_PMS_CONSTRAIN_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_addr_0
            REGION_PMS_CONSTRAIN_ADDR_0: u30,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x110);

        /// address: 0x600c1114
        /// SENSITIVE_REGION_PMS_CONSTRAIN_4_REG
        pub const REGION_PMS_CONSTRAIN_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_addr_1
            REGION_PMS_CONSTRAIN_ADDR_1: u30,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x114);

        /// address: 0x600c1118
        /// SENSITIVE_REGION_PMS_CONSTRAIN_5_REG
        pub const REGION_PMS_CONSTRAIN_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_addr_2
            REGION_PMS_CONSTRAIN_ADDR_2: u30,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x118);

        /// address: 0x600c111c
        /// SENSITIVE_REGION_PMS_CONSTRAIN_6_REG
        pub const REGION_PMS_CONSTRAIN_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_addr_3
            REGION_PMS_CONSTRAIN_ADDR_3: u30,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x11c);

        /// address: 0x600c1120
        /// SENSITIVE_REGION_PMS_CONSTRAIN_7_REG
        pub const REGION_PMS_CONSTRAIN_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_addr_4
            REGION_PMS_CONSTRAIN_ADDR_4: u30,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x120);

        /// address: 0x600c1124
        /// SENSITIVE_REGION_PMS_CONSTRAIN_8_REG
        pub const REGION_PMS_CONSTRAIN_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_addr_5
            REGION_PMS_CONSTRAIN_ADDR_5: u30,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x124);

        /// address: 0x600c1128
        /// SENSITIVE_REGION_PMS_CONSTRAIN_9_REG
        pub const REGION_PMS_CONSTRAIN_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_addr_6
            REGION_PMS_CONSTRAIN_ADDR_6: u30,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x128);

        /// address: 0x600c112c
        /// SENSITIVE_REGION_PMS_CONSTRAIN_10_REG
        pub const REGION_PMS_CONSTRAIN_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// region_pms_constrain_addr_7
            REGION_PMS_CONSTRAIN_ADDR_7: u30,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x12c);

        /// address: 0x600c1130
        /// SENSITIVE_CORE_0_PIF_PMS_MONITOR_0_REG
        pub const CORE_0_PIF_PMS_MONITOR_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_monitor_lock
            CORE_0_PIF_PMS_MONITOR_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x130);

        /// address: 0x600c1134
        /// SENSITIVE_CORE_0_PIF_PMS_MONITOR_1_REG
        pub const CORE_0_PIF_PMS_MONITOR_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_monitor_violate_clr
            CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR: u1,
            /// core_0_pif_pms_monitor_violate_en
            CORE_0_PIF_PMS_MONITOR_VIOLATE_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x134);

        /// address: 0x600c1138
        /// SENSITIVE_CORE_0_PIF_PMS_MONITOR_2_REG
        pub const CORE_0_PIF_PMS_MONITOR_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_monitor_violate_intr
            CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR: u1,
            /// core_0_pif_pms_monitor_violate_status_hport_0
            CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HPORT_0: u1,
            /// core_0_pif_pms_monitor_violate_status_hsize
            CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HSIZE: u3,
            /// core_0_pif_pms_monitor_violate_status_hwrite
            CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HWRITE: u1,
            /// core_0_pif_pms_monitor_violate_status_hworld
            CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HWORLD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x138);

        /// address: 0x600c113c
        /// SENSITIVE_CORE_0_PIF_PMS_MONITOR_3_REG
        pub const CORE_0_PIF_PMS_MONITOR_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_monitor_violate_status_haddr
            CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HADDR: u32,
        }), base_address + 0x13c);

        /// address: 0x600c1140
        /// SENSITIVE_CORE_0_PIF_PMS_MONITOR_4_REG
        pub const CORE_0_PIF_PMS_MONITOR_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_monitor_nonword_violate_clr
            CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_CLR: u1,
            /// core_0_pif_pms_monitor_nonword_violate_en
            CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x140);

        /// address: 0x600c1144
        /// SENSITIVE_CORE_0_PIF_PMS_MONITOR_5_REG
        pub const CORE_0_PIF_PMS_MONITOR_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_monitor_nonword_violate_intr
            CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_INTR: u1,
            /// core_0_pif_pms_monitor_nonword_violate_status_hsize
            CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HSIZE: u2,
            /// core_0_pif_pms_monitor_nonword_violate_status_hworld
            CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HWORLD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x144);

        /// address: 0x600c1148
        /// SENSITIVE_CORE_0_PIF_PMS_MONITOR_6_REG
        pub const CORE_0_PIF_PMS_MONITOR_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// core_0_pif_pms_monitor_nonword_violate_status_haddr
            CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HADDR: u32,
        }), base_address + 0x148);

        /// address: 0x600c114c
        /// SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_0_REG
        pub const BACKUP_BUS_PMS_CONSTRAIN_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// backup_bus_pms_constrain_lock
            BACKUP_BUS_PMS_CONSTRAIN_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14c);

        /// address: 0x600c1150
        /// SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_1_REG
        pub const BACKUP_BUS_PMS_CONSTRAIN_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// backup_bus_pms_constrain_uart
            BACKUP_BUS_PMS_CONSTRAIN_UART: u2,
            /// backup_bus_pms_constrain_g0spi_1
            BACKUP_BUS_PMS_CONSTRAIN_G0SPI_1: u2,
            /// backup_bus_pms_constrain_g0spi_0
            BACKUP_BUS_PMS_CONSTRAIN_G0SPI_0: u2,
            /// backup_bus_pms_constrain_gpio
            BACKUP_BUS_PMS_CONSTRAIN_GPIO: u2,
            /// backup_bus_pms_constrain_fe2
            BACKUP_BUS_PMS_CONSTRAIN_FE2: u2,
            /// backup_bus_pms_constrain_fe
            BACKUP_BUS_PMS_CONSTRAIN_FE: u2,
            /// backup_bus_pms_constrain_timer
            BACKUP_BUS_PMS_CONSTRAIN_TIMER: u2,
            /// backup_bus_pms_constrain_rtc
            BACKUP_BUS_PMS_CONSTRAIN_RTC: u2,
            /// backup_bus_pms_constrain_io_mux
            BACKUP_BUS_PMS_CONSTRAIN_IO_MUX: u2,
            /// backup_bus_pms_constrain_wdg
            BACKUP_BUS_PMS_CONSTRAIN_WDG: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// backup_bus_pms_constrain_misc
            BACKUP_BUS_PMS_CONSTRAIN_MISC: u2,
            /// backup_bus_pms_constrain_i2c
            BACKUP_BUS_PMS_CONSTRAIN_I2C: u2,
            reserved4: u1,
            reserved5: u1,
            /// backup_bus_pms_constrain_uart1
            BACKUP_BUS_PMS_CONSTRAIN_UART1: u2,
        }), base_address + 0x150);

        /// address: 0x600c1154
        /// SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_2_REG
        pub const BACKUP_BUS_PMS_CONSTRAIN_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// backup_bus_pms_constrain_bt
            BACKUP_BUS_PMS_CONSTRAIN_BT: u2,
            reserved0: u1,
            reserved1: u1,
            /// backup_bus_pms_constrain_i2c_ext0
            BACKUP_BUS_PMS_CONSTRAIN_I2C_EXT0: u2,
            /// backup_bus_pms_constrain_uhci0
            BACKUP_BUS_PMS_CONSTRAIN_UHCI0: u2,
            reserved2: u1,
            reserved3: u1,
            /// backup_bus_pms_constrain_rmt
            BACKUP_BUS_PMS_CONSTRAIN_RMT: u2,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// backup_bus_pms_constrain_ledc
            BACKUP_BUS_PMS_CONSTRAIN_LEDC: u2,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// backup_bus_pms_constrain_bb
            BACKUP_BUS_PMS_CONSTRAIN_BB: u2,
            reserved12: u1,
            reserved13: u1,
            /// backup_bus_pms_constrain_timergroup
            BACKUP_BUS_PMS_CONSTRAIN_TIMERGROUP: u2,
            /// backup_bus_pms_constrain_timergroup1
            BACKUP_BUS_PMS_CONSTRAIN_TIMERGROUP1: u2,
            /// backup_bus_pms_constrain_systimer
            BACKUP_BUS_PMS_CONSTRAIN_SYSTIMER: u2,
        }), base_address + 0x154);

        /// address: 0x600c1158
        /// SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_3_REG
        pub const BACKUP_BUS_PMS_CONSTRAIN_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// backup_bus_pms_constrain_spi_2
            BACKUP_BUS_PMS_CONSTRAIN_SPI_2: u2,
            reserved0: u1,
            reserved1: u1,
            /// backup_bus_pms_constrain_apb_ctrl
            BACKUP_BUS_PMS_CONSTRAIN_APB_CTRL: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// backup_bus_pms_constrain_can
            BACKUP_BUS_PMS_CONSTRAIN_CAN: u2,
            reserved6: u1,
            reserved7: u1,
            /// backup_bus_pms_constrain_i2s1
            BACKUP_BUS_PMS_CONSTRAIN_I2S1: u2,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// backup_bus_pms_constrain_rwbt
            BACKUP_BUS_PMS_CONSTRAIN_RWBT: u2,
            reserved14: u1,
            reserved15: u1,
            /// backup_bus_pms_constrain_wifimac
            BACKUP_BUS_PMS_CONSTRAIN_WIFIMAC: u2,
            /// backup_bus_pms_constrain_pwr
            BACKUP_BUS_PMS_CONSTRAIN_PWR: u2,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x158);

        /// address: 0x600c115c
        /// SENSITIVE_BACKUP_BUS_PMS_CONSTRAIN_4_REG
        pub const BACKUP_BUS_PMS_CONSTRAIN_4 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// backup_bus_pms_constrain_usb_wrap
            BACKUP_BUS_PMS_CONSTRAIN_USB_WRAP: u2,
            /// backup_bus_pms_constrain_crypto_peri
            BACKUP_BUS_PMS_CONSTRAIN_CRYPTO_PERI: u2,
            /// backup_bus_pms_constrain_crypto_dma
            BACKUP_BUS_PMS_CONSTRAIN_CRYPTO_DMA: u2,
            /// backup_bus_pms_constrain_apb_adc
            BACKUP_BUS_PMS_CONSTRAIN_APB_ADC: u2,
            reserved2: u1,
            reserved3: u1,
            /// backup_bus_pms_constrain_bt_pwr
            BACKUP_BUS_PMS_CONSTRAIN_BT_PWR: u2,
            /// backup_bus_pms_constrain_usb_device
            BACKUP_BUS_PMS_CONSTRAIN_USB_DEVICE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x15c);

        /// address: 0x600c1160
        /// SENSITIVE_BACKUP_BUS_PMS_MONITOR_0_REG
        pub const BACKUP_BUS_PMS_MONITOR_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// backup_bus_pms_monitor_lock
            BACKUP_BUS_PMS_MONITOR_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x160);

        /// address: 0x600c1164
        /// SENSITIVE_BACKUP_BUS_PMS_MONITOR_1_REG
        pub const BACKUP_BUS_PMS_MONITOR_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// backup_bus_pms_monitor_violate_clr
            BACKUP_BUS_PMS_MONITOR_VIOLATE_CLR: u1,
            /// backup_bus_pms_monitor_violate_en
            BACKUP_BUS_PMS_MONITOR_VIOLATE_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x164);

        /// address: 0x600c1168
        /// SENSITIVE_BACKUP_BUS_PMS_MONITOR_2_REG
        pub const BACKUP_BUS_PMS_MONITOR_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// backup_bus_pms_monitor_violate_intr
            BACKUP_BUS_PMS_MONITOR_VIOLATE_INTR: u1,
            /// backup_bus_pms_monitor_violate_status_htrans
            BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HTRANS: u2,
            /// backup_bus_pms_monitor_violate_status_hsize
            BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HSIZE: u3,
            /// backup_bus_pms_monitor_violate_status_hwrite
            BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HWRITE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x168);

        /// address: 0x600c116c
        /// SENSITIVE_BACKUP_BUS_PMS_MONITOR_3_REG
        pub const BACKUP_BUS_PMS_MONITOR_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// backup_bus_pms_monitor_violate_haddr
            BACKUP_BUS_PMS_MONITOR_VIOLATE_HADDR: u32,
        }), base_address + 0x16c);

        /// address: 0x600c1170
        /// SENSITIVE_CLOCK_GATE_REG
        pub const CLOCK_GATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// clk_en
            CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x170);

        /// address: 0x600c1ffc
        /// SENSITIVE_DATE_REG
        pub const DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0xffc);
    };

    /// SHA (Secure Hash Algorithm) Accelerator
    pub const SHA = struct {
        pub const base_address = 0x6003b000;

        /// address: 0x6003b000
        /// Initial configuration register.
        pub const MODE = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x0);

        /// address: 0x6003b004
        /// SHA 512/t configuration register 0.
        pub const T_STRING = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x6003b008
        /// SHA 512/t configuration register 1.
        pub const T_LENGTH = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x8);

        /// address: 0x6003b00c
        /// DMA configuration register 0.
        pub const DMA_BLOCK_NUM = @intToPtr(*volatile MmioInt(32, u6), base_address + 0xc);

        /// address: 0x6003b010
        /// Typical SHA configuration register 0.
        pub const START = @intToPtr(*volatile MmioInt(32, u31), base_address + 0x10);

        /// address: 0x6003b014
        /// Typical SHA configuration register 1.
        pub const CONTINUE = @intToPtr(*volatile MmioInt(32, u31), base_address + 0x14);

        /// address: 0x6003b018
        /// Busy register.
        pub const BUSY = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sha busy state. 1'b0: idle. 1'b1: busy.
            STATE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x18);

        /// address: 0x6003b01c
        /// DMA configuration register 1.
        pub const DMA_START = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x1c);

        /// address: 0x6003b020
        /// DMA configuration register 2.
        pub const DMA_CONTINUE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x20);

        /// address: 0x6003b024
        /// Interrupt clear register.
        pub const CLEAR_IRQ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear sha interrupt.
            CLEAR_INTERRUPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x24);

        /// address: 0x6003b028
        /// Interrupt enable register.
        pub const IRQ_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sha interrupt enable register. 1'b0: disable(default). 1'b1: enable.
            INTERRUPT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x28);

        /// address: 0x6003b02c
        /// Date register.
        pub const DATE = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x2c);

        /// address: 0x6003b040
        /// Sha H memory which contains intermediate hash or finial hash.
        pub const H_MEM = @intToPtr(*volatile [64]u8, base_address + 0x40);

        /// address: 0x6003b080
        /// Sha M memory which contains message.
        pub const M_MEM = @intToPtr(*volatile [64]u8, base_address + 0x80);
    };

    /// SPI (Serial Peripheral Interface) Controller
    pub const SPI0 = struct {
        pub const base_address = 0x60003000;

        /// address: 0x60003008
        /// SPI0 control register.
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// In the dummy phase the signal level of spi is output by the spi controller.
            FDUMMY_OUT: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Apply 2 signals during command phase 1:enable 0: disable
            FCMD_DUAL: u1,
            /// Apply 4 signals during command phase 1:enable 0: disable
            FCMD_QUAD: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// This bit enable the bits: spi_mem_fread_qio, spi_mem_fread_dio,
            /// spi_mem_fread_qout and spi_mem_fread_dout. 1: enable 0: disable.
            FASTRD_MODE: u1,
            /// In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
            FREAD_DUAL: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// The bit is used to set MISO line polarity, 1: high 0, low
            Q_POL: u1,
            /// The bit is used to set MOSI line polarity, 1: high 0, low
            D_POL: u1,
            /// In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
            FREAD_QUAD: u1,
            /// Write protect signal output when SPI is idle. 1: output high, 0: output low.
            WP: u1,
            reserved13: u1,
            /// In the read operations address phase and read-data phase apply 2 signals. 1:
            /// enable 0: disable.
            FREAD_DIO: u1,
            /// In the read operations address phase and read-data phase apply 4 signals. 1:
            /// enable 0: disable.
            FREAD_QIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x6000300c
        /// SPI0 control1 register.
        pub const CTRL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is
            /// delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS
            /// inactive 3: SPI clock is alwasy on.
            CLK_MODE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            /// SPI0 RX FIFO reset signal.
            RXFIFO_RST: u1,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x60003010
        /// SPI0 control2 register.
        pub const CTRL2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// (cycles-1) of prepare phase by spi clock this bits are combined with
            /// spi_mem_cs_setup bit.
            CS_SETUP_TIME: u5,
            /// Spi cs signal is delayed to inactive by spi clock this bits are combined with
            /// spi_mem_cs_hold bit.
            CS_HOLD_TIME: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// These bits are used to set the minimum CS high time tSHSL between SPI burst
            /// transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELAY[5:0] + 1) MSPI
            /// core clock cycles.
            CS_HOLD_DELAY: u6,
            /// The FSM will be reset.
            SYNC_RESET: u1,
        }), base_address + 0x10);

        /// address: 0x60003014
        /// SPI clock division control register.
        pub const CLOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// In the master mode it must be equal to spi_mem_clkcnt_N.
            CLKCNT_L: u8,
            /// In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
            CLKCNT_H: u8,
            /// In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is
            /// system/(spi_mem_clkcnt_N+1)
            CLKCNT_N: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Set this bit in 1-division mode.
            CLK_EQU_SYSCLK: u1,
        }), base_address + 0x14);

        /// address: 0x60003018
        /// SPI0 user register.
        pub const USER = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// spi cs keep low when spi is in done phase. 1: enable 0: disable.
            CS_HOLD: u1,
            /// spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
            CS_SETUP: u1,
            reserved6: u1,
            /// the bit combined with spi_mem_mosi_delay_mode bits to set mosi signal delay
            /// mode.
            CK_OUT_EDGE: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// spi clock is disable in dummy phase when the bit is enable.
            USR_DUMMY_IDLE: u1,
            reserved23: u1,
            reserved24: u1,
            /// This bit enable the dummy phase of an operation.
            USR_DUMMY: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x18);

        /// address: 0x6000301c
        /// SPI0 user1 register.
        pub const USER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length in spi_mem_clk cycles of dummy phase. The register value shall be
            /// (cycle_num-1).
            USR_DUMMY_CYCLELEN: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// The length in bits of address phase. The register value shall be (bit_num-1).
            USR_ADDR_BITLEN: u6,
        }), base_address + 0x1c);

        /// address: 0x60003020
        /// SPI0 user2 register.
        pub const USER2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of command.
            USR_COMMAND_VALUE: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// The length in bits of command phase. The register value shall be (bit_num-1)
            USR_COMMAND_BITLEN: u4,
        }), base_address + 0x20);

        /// address: 0x6000302c
        /// SPI0 read control register.
        pub const RD_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Mode bits in the flash fast read mode it is combined with spi_mem_fastrd_mode
            /// bit.
            WB_MODE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x60003034
        /// SPI0 misc register
        pub const MISC = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// The bit is used to indicate the spi0_mst_st controlled transmitting is done.
            TRANS_END: u1,
            /// The bit is used to enable the interrupt of spi0_mst_st controlled transmitting
            /// is done.
            TRANS_END_INT_ENA: u1,
            /// The bit is used to indicate the spi0_slv_st controlled transmitting is done.
            CSPI_ST_TRANS_END: u1,
            /// The bit is used to enable the interrupt of spi0_slv_st controlled transmitting
            /// is done.
            CSPI_ST_TRANS_END_INT_ENA: u1,
            reserved3: u1,
            reserved4: u1,
            /// 1: spi clk line is high when idle 0: spi clk line is low when idle
            CK_IDLE_EDGE: u1,
            /// spi cs line keep low when the bit is set.
            CS_KEEP_ACTIVE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x34);

        /// address: 0x6000303c
        /// SPI0 bit mode control register.
        pub const CACHE_FCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// For SPI0, Cache access enable, 1: enable, 0:disable.
            CACHE_REQ_EN: u1,
            /// For SPI0, cache read flash with 4 bytes address, 1: enable, 0:disable.
            CACHE_USR_ADDR_4BYTE: u1,
            /// For SPI0, cache read flash for user define command, 1: enable, 0:disable.
            CACHE_FLASH_USR_CMD: u1,
            /// For SPI0 flash, din phase apply 2 signals. 1: enable 0: disable. The bit is the
            /// same with spi_mem_fread_dio.
            FDIN_DUAL: u1,
            /// For SPI0 flash, dout phase apply 2 signals. 1: enable 0: disable. The bit is the
            /// same with spi_mem_fread_dio.
            FDOUT_DUAL: u1,
            /// For SPI0 flash, address phase apply 2 signals. 1: enable 0: disable. The bit is
            /// the same with spi_mem_fread_dio.
            FADDR_DUAL: u1,
            /// For SPI0 flash, din phase apply 4 signals. 1: enable 0: disable. The bit is the
            /// same with spi_mem_fread_qio.
            FDIN_QUAD: u1,
            /// For SPI0 flash, dout phase apply 4 signals. 1: enable 0: disable. The bit is the
            /// same with spi_mem_fread_qio.
            FDOUT_QUAD: u1,
            /// For SPI0 flash, address phase apply 4 signals. 1: enable 0: disable. The bit is
            /// the same with spi_mem_fread_qio.
            FADDR_QUAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x3c);

        /// address: 0x60003054
        /// SPI0 FSM status register
        pub const FSM = @intToPtr(*volatile Mmio(32, packed struct {
            /// The current status of SPI0 slave FSM: spi0_slv_st. 0: idle state, 1: preparation
            /// state, 2: send command state, 3: send address state, 4: wait state, 5: read data
            /// state, 6:write data state, 7: done state, 8: read data end state.
            CSPI_ST: u4,
            /// The current status of SPI0 master FSM: spi0_mst_st. 0: idle state,
            /// 1:EM_CACHE_GRANT , 2: program/erase suspend state, 3: SPI0 read data state, 4:
            /// wait cache/EDMA sent data is stored in SPI0 TX FIFO, 5: SPI0 write data state.
            EM_ST: u3,
            /// The lock delay time of SPI0/1 arbiter by spi0_slv_st, after PER is sent by SPI1.
            CSPI_LOCK_DELAY_TIME: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x54);

        /// address: 0x600030a8
        /// SPI0 timing calibration register
        pub const TIMING_CALI = @intToPtr(*volatile Mmio(32, packed struct {
            /// The bit is used to enable timing adjust clock for all reading operations.
            TIMING_CLK_ENA: u1,
            /// The bit is used to enable timing auto-calibration for all reading operations.
            TIMING_CALI: u1,
            /// add extra dummy spi clock cycle length for spi clock calibration.
            EXTRA_DUMMY_CYCLELEN: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xa8);

        /// address: 0x600030ac
        /// SPI0 input delay mode control register
        pub const DIN_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// the input signals are delayed by system clock cycles, 0: input without delayed,
            /// 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3:
            /// input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input
            /// with the spi_clk high edge, 6: input with the spi_clk low edge
            DIN0_MODE: u2,
            /// the input signals are delayed by system clock cycles, 0: input without delayed,
            /// 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3:
            /// input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input
            /// with the spi_clk high edge, 6: input with the spi_clk low edge
            DIN1_MODE: u2,
            /// the input signals are delayed by system clock cycles, 0: input without delayed,
            /// 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3:
            /// input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input
            /// with the spi_clk high edge, 6: input with the spi_clk low edge
            DIN2_MODE: u2,
            /// the input signals are delayed by system clock cycles, 0: input without delayed,
            /// 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3:
            /// input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input
            /// with the spi_clk high edge, 6: input with the spi_clk low edge
            DIN3_MODE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xac);

        /// address: 0x600030b0
        /// SPI0 input delay number control register
        pub const DIN_NUM = @intToPtr(*volatile Mmio(32, packed struct {
            /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1:
            /// delayed by 2 cycles,...
            DIN0_NUM: u2,
            /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1:
            /// delayed by 2 cycles,...
            DIN1_NUM: u2,
            /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1:
            /// delayed by 2 cycles,...
            DIN2_NUM: u2,
            /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1:
            /// delayed by 2 cycles,...
            DIN3_NUM: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xb0);

        /// address: 0x600030b4
        /// SPI0 output delay mode control register
        pub const DOUT_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// the output signals are delayed by system clock cycles, 0: output without
            /// delayed, 1: output with the posedge of clk_apb,2 output with the negedge of
            /// clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of
            /// clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low
            /// edge
            DOUT0_MODE: u1,
            /// the output signals are delayed by system clock cycles, 0: output without
            /// delayed, 1: output with the posedge of clk_apb,2 output with the negedge of
            /// clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of
            /// clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low
            /// edge
            DOUT1_MODE: u1,
            /// the output signals are delayed by system clock cycles, 0: output without
            /// delayed, 1: output with the posedge of clk_apb,2 output with the negedge of
            /// clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of
            /// clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low
            /// edge
            DOUT2_MODE: u1,
            /// the output signals are delayed by system clock cycles, 0: output without
            /// delayed, 1: output with the posedge of clk_apb,2 output with the negedge of
            /// clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of
            /// clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low
            /// edge
            DOUT3_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xb4);

        /// address: 0x600030dc
        /// SPI0 clk_gate register
        pub const CLOCK_GATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Register clock gate enable signal. 1: Enable. 0: Disable.
            CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xdc);

        /// address: 0x600030e0
        /// SPI0 module clock select register
        pub const CORE_CLK_SEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// When the digital system clock selects PLL clock and the frequency of PLL clock
            /// is 480MHz, the value of reg_spi01_clk_sel: 0: SPI0/1 module clock (clk) is
            /// 80MHz. 1: SPI0/1 module clock (clk) is 120MHz. 2: SPI0/1 module clock (clk)
            /// 160MHz. 3: Not used. When the digital system clock selects PLL clock and the
            /// frequency of PLL clock is 320MHz, the value of reg_spi01_clk_sel: 0: SPI0/1
            /// module clock (clk) is 80MHz. 1: SPI0/1 module clock (clk) is 80MHz. 2: SPI0/1
            /// module clock (clk) 160MHz. 3: Not used.
            SPI01_CLK_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xe0);

        /// address: 0x600033fc
        /// Version control register
        pub const DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0x3fc);
    };

    /// SPI (Serial Peripheral Interface) Controller
    pub const SPI1 = struct {
        pub const base_address = 0x60002000;

        /// address: 0x60002000
        /// SPI1 memory command register
        pub const CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// The current status of SPI1 master FSM.
            SPI1_MST_ST: u4,
            /// The current status of SPI1 slave FSM: mspi_st. 0: idle state, 1: preparation
            /// state, 2: send command state, 3: send address state, 4: wait state, 5: read data
            /// state, 6:write data state, 7: done state, 8: read data end state.
            MSPI_ST: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// In user mode, it is set to indicate that program/erase operation will be
            /// triggered. The bit is combined with spi_mem_usr bit. The bit will be cleared
            /// once the operation done.1: enable 0: disable.
            FLASH_PE: u1,
            /// User define command enable. An operation will be triggered when the bit is set.
            /// The bit will be cleared once the operation done.1: enable 0: disable.
            USR: u1,
            /// Drive Flash into high performance mode. The bit will be cleared once the
            /// operation done.1: enable 0: disable.
            FLASH_HPM: u1,
            /// This bit combined with reg_resandres bit releases Flash from the power-down
            /// state or high performance mode and obtains the devices ID. The bit will be
            /// cleared once the operation done.1: enable 0: disable.
            FLASH_RES: u1,
            /// Drive Flash into power down. An operation will be triggered when the bit is set.
            /// The bit will be cleared once the operation done.1: enable 0: disable.
            FLASH_DP: u1,
            /// Chip erase enable. Chip erase operation will be triggered when the bit is set.
            /// The bit will be cleared once the operation done.1: enable 0: disable.
            FLASH_CE: u1,
            /// Block erase enable(32KB) . Block erase operation will be triggered when the bit
            /// is set. The bit will be cleared once the operation done.1: enable 0: disable.
            FLASH_BE: u1,
            /// Sector erase enable(4KB). Sector erase operation will be triggered when the bit
            /// is set. The bit will be cleared once the operation done.1: enable 0: disable.
            FLASH_SE: u1,
            /// Page program enable(1 byte ~256 bytes data to be programmed). Page program
            /// operation will be triggered when the bit is set. The bit will be cleared once
            /// the operation done .1: enable 0: disable.
            FLASH_PP: u1,
            /// Write status register enable. Write status operation will be triggered when the
            /// bit is set. The bit will be cleared once the operation done.1: enable 0:
            /// disable.
            FLASH_WRSR: u1,
            /// Read status register-1. Read status operation will be triggered when the bit is
            /// set. The bit will be cleared once the operation done.1: enable 0: disable.
            FLASH_RDSR: u1,
            /// Read JEDEC ID . Read ID command will be sent when the bit is set. The bit will
            /// be cleared once the operation done. 1: enable 0: disable.
            FLASH_RDID: u1,
            /// Write flash disable. Write disable command will be sent when the bit is set. The
            /// bit will be cleared once the operation done. 1: enable 0: disable.
            FLASH_WRDI: u1,
            /// Write flash enable. Write enable command will be sent when the bit is set. The
            /// bit will be cleared once the operation done. 1: enable 0: disable.
            FLASH_WREN: u1,
            /// Read flash enable. Read flash operation will be triggered when the bit is set.
            /// The bit will be cleared once the operation done. 1: enable 0: disable.
            FLASH_READ: u1,
        }), base_address + 0x0);

        /// address: 0x60002004
        /// SPI1 address register
        pub const ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// In user mode, it is the memory address. other then the bit0-bit23 is the memory
            /// address, the bit24-bit31 are the byte length of a transfer.
            USR_ADDR_VALUE: u32,
        }), base_address + 0x4);

        /// address: 0x60002008
        /// SPI1 control register.
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// In the dummy phase the signal level of spi is output by the spi controller.
            FDUMMY_OUT: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Apply 2 signals during command phase 1:enable 0: disable
            FCMD_DUAL: u1,
            /// Apply 4 signals during command phase 1:enable 0: disable
            FCMD_QUAD: u1,
            reserved6: u1,
            /// For SPI1, initialize crc32 module before writing encrypted data to flash. Active
            /// low.
            FCS_CRC_EN: u1,
            /// For SPI1, enable crc32 when writing encrypted data to flash. 1: enable 0:disable
            TX_CRC_EN: u1,
            reserved7: u1,
            /// This bit enable the bits: spi_mem_fread_qio, spi_mem_fread_dio,
            /// spi_mem_fread_qout and spi_mem_fread_dout. 1: enable 0: disable.
            FASTRD_MODE: u1,
            /// In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
            FREAD_DUAL: u1,
            /// The Device ID is read out to SPI_MEM_RD_STATUS register, this bit combine with
            /// spi_mem_flash_res bit. 1: enable 0: disable.
            RESANDRES: u1,
            reserved8: u1,
            reserved9: u1,
            /// The bit is used to set MISO line polarity, 1: high 0, low
            Q_POL: u1,
            /// The bit is used to set MOSI line polarity, 1: high 0, low
            D_POL: u1,
            /// In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
            FREAD_QUAD: u1,
            /// Write protect signal output when SPI is idle. 1: output high, 0: output low.
            WP: u1,
            /// two bytes data will be written to status register when it is set. 1: enable 0:
            /// disable.
            WRSR_2B: u1,
            /// In the read operations address phase and read-data phase apply 2 signals. 1:
            /// enable 0: disable.
            FREAD_DIO: u1,
            /// In the read operations address phase and read-data phase apply 4 signals. 1:
            /// enable 0: disable.
            FREAD_QIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x6000200c
        /// SPI1 control1 register.
        pub const CTRL1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is
            /// delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS
            /// inactive 3: SPI clock is alwasy on.
            CLK_MODE: u2,
            /// After RES/DP/HPM command is sent, SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] *
            /// 512) SPI_CLK cycles.
            CS_HOLD_DLY_RES: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xc);

        /// address: 0x60002010
        /// SPI1 control2 register.
        pub const CTRL2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// The FSM will be reset.
            SYNC_RESET: u1,
        }), base_address + 0x10);

        /// address: 0x60002014
        /// SPI1 clock division control register.
        pub const CLOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// In the master mode it must be equal to spi_mem_clkcnt_N.
            CLKCNT_L: u8,
            /// In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
            CLKCNT_H: u8,
            /// In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is
            /// system/(spi_mem_clkcnt_N+1)
            CLKCNT_N: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// reserved
            CLK_EQU_SYSCLK: u1,
        }), base_address + 0x14);

        /// address: 0x60002018
        /// SPI1 user register.
        pub const USER = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// the bit combined with spi_mem_mosi_delay_mode bits to set mosi signal delay
            /// mode.
            CK_OUT_EDGE: u1,
            reserved9: u1,
            reserved10: u1,
            /// In the write operations read-data phase apply 2 signals
            FWRITE_DUAL: u1,
            /// In the write operations read-data phase apply 4 signals
            FWRITE_QUAD: u1,
            /// In the write operations address phase and read-data phase apply 2 signals.
            FWRITE_DIO: u1,
            /// In the write operations address phase and read-data phase apply 4 signals.
            FWRITE_QIO: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// read-data phase only access to high-part of the buffer spi_mem_w8~spi_mem_w15.
            /// 1: enable 0: disable.
            USR_MISO_HIGHPART: u1,
            /// write-data phase only access to high-part of the buffer spi_mem_w8~spi_mem_w15.
            /// 1: enable 0: disable.
            USR_MOSI_HIGHPART: u1,
            /// SPI clock is disable in dummy phase when the bit is enable.
            USR_DUMMY_IDLE: u1,
            /// This bit enable the write-data phase of an operation.
            USR_MOSI: u1,
            /// This bit enable the read-data phase of an operation.
            USR_MISO: u1,
            /// This bit enable the dummy phase of an operation.
            USR_DUMMY: u1,
            /// This bit enable the address phase of an operation.
            USR_ADDR: u1,
            /// This bit enable the command phase of an operation.
            USR_COMMAND: u1,
        }), base_address + 0x18);

        /// address: 0x6000201c
        /// SPI1 user1 register.
        pub const USER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length in spi_mem_clk cycles of dummy phase. The register value shall be
            /// (cycle_num-1).
            USR_DUMMY_CYCLELEN: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// The length in bits of address phase. The register value shall be (bit_num-1).
            USR_ADDR_BITLEN: u6,
        }), base_address + 0x1c);

        /// address: 0x60002020
        /// SPI1 user2 register.
        pub const USER2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of command.
            USR_COMMAND_VALUE: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// The length in bits of command phase. The register value shall be (bit_num-1)
            USR_COMMAND_BITLEN: u4,
        }), base_address + 0x20);

        /// address: 0x60002024
        /// SPI1 send data bit length control register.
        pub const MOSI_DLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length in bits of write-data. The register value shall be (bit_num-1).
            USR_MOSI_DBITLEN: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x24);

        /// address: 0x60002028
        /// SPI1 receive data bit length control register.
        pub const MISO_DLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length in bits of read-data. The register value shall be (bit_num-1).
            USR_MISO_DBITLEN: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x28);

        /// address: 0x6000202c
        /// SPI1 status register.
        pub const RD_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value is stored when set spi_mem_flash_rdsr bit and spi_mem_flash_res bit.
            STATUS: u16,
            /// Mode bits in the flash fast read mode it is combined with spi_mem_fastrd_mode
            /// bit.
            WB_MODE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x60002034
        /// SPI1 misc register
        pub const MISC = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI_CS0 pin enable, 1: disable SPI_CS0, 0: SPI_CS0 pin is active to select SPI
            /// device, such as flash, external RAM and so on.
            CS0_DIS: u1,
            /// SPI_CS1 pin enable, 1: disable SPI_CS1, 0: SPI_CS1 pin is active to select SPI
            /// device, such as flash, external RAM and so on.
            CS1_DIS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// 1: spi clk line is high when idle 0: spi clk line is low when idle
            CK_IDLE_EDGE: u1,
            /// spi cs line keep low when the bit is set.
            CS_KEEP_ACTIVE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x34);

        /// address: 0x60002038
        /// SPI1 TX CRC data register.
        pub const TX_CRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// For SPI1, the value of crc32.
            DATA: u32,
        }), base_address + 0x38);

        /// address: 0x6000203c
        /// SPI1 bit mode control register.
        pub const CACHE_FCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// For SPI1, cache read flash with 4 bytes address, 1: enable, 0:disable.
            CACHE_USR_ADDR_4BYTE: u1,
            reserved1: u1,
            /// For SPI1, din phase apply 2 signals. 1: enable 0: disable. The bit is the same
            /// with spi_mem_fread_dio.
            FDIN_DUAL: u1,
            /// For SPI1, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same
            /// with spi_mem_fread_dio.
            FDOUT_DUAL: u1,
            /// For SPI1, address phase apply 2 signals. 1: enable 0: disable. The bit is the
            /// same with spi_mem_fread_dio.
            FADDR_DUAL: u1,
            /// For SPI1, din phase apply 4 signals. 1: enable 0: disable. The bit is the same
            /// with spi_mem_fread_qio.
            FDIN_QUAD: u1,
            /// For SPI1, dout phase apply 4 signals. 1: enable 0: disable. The bit is the same
            /// with spi_mem_fread_qio.
            FDOUT_QUAD: u1,
            /// For SPI1, address phase apply 4 signals. 1: enable 0: disable. The bit is the
            /// same with spi_mem_fread_qio.
            FADDR_QUAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x3c);

        /// address: 0x60002058
        /// SPI1 memory data buffer0
        pub const W0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF0: u32,
        }), base_address + 0x58);

        /// address: 0x6000205c
        /// SPI1 memory data buffer1
        pub const W1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF1: u32,
        }), base_address + 0x5c);

        /// address: 0x60002060
        /// SPI1 memory data buffer2
        pub const W2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF2: u32,
        }), base_address + 0x60);

        /// address: 0x60002064
        /// SPI1 memory data buffer3
        pub const W3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF3: u32,
        }), base_address + 0x64);

        /// address: 0x60002068
        /// SPI1 memory data buffer4
        pub const W4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF4: u32,
        }), base_address + 0x68);

        /// address: 0x6000206c
        /// SPI1 memory data buffer5
        pub const W5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF5: u32,
        }), base_address + 0x6c);

        /// address: 0x60002070
        /// SPI1 memory data buffer6
        pub const W6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF6: u32,
        }), base_address + 0x70);

        /// address: 0x60002074
        /// SPI1 memory data buffer7
        pub const W7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF7: u32,
        }), base_address + 0x74);

        /// address: 0x60002078
        /// SPI1 memory data buffer8
        pub const W8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF8: u32,
        }), base_address + 0x78);

        /// address: 0x6000207c
        /// SPI1 memory data buffer9
        pub const W9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF9: u32,
        }), base_address + 0x7c);

        /// address: 0x60002080
        /// SPI1 memory data buffer10
        pub const W10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF10: u32,
        }), base_address + 0x80);

        /// address: 0x60002084
        /// SPI1 memory data buffer11
        pub const W11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF11: u32,
        }), base_address + 0x84);

        /// address: 0x60002088
        /// SPI1 memory data buffer12
        pub const W12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF12: u32,
        }), base_address + 0x88);

        /// address: 0x6000208c
        /// SPI1 memory data buffer13
        pub const W13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF13: u32,
        }), base_address + 0x8c);

        /// address: 0x60002090
        /// SPI1 memory data buffer14
        pub const W14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF14: u32,
        }), base_address + 0x90);

        /// address: 0x60002094
        /// SPI1 memory data buffer15
        pub const W15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF15: u32,
        }), base_address + 0x94);

        /// address: 0x60002098
        /// SPI1 wait idle control register
        pub const FLASH_WAITI_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// The dummy phase enable when wait flash idle (RDSR)
            WAITI_DUMMY: u1,
            /// The command to wait flash idle(RDSR).
            WAITI_CMD: u8,
            /// The dummy cycle length when wait flash idle(RDSR).
            WAITI_DUMMY_CYCLELEN: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x98);

        /// address: 0x6000209c
        /// SPI1 flash suspend control register
        pub const FLASH_SUS_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// program erase resume bit, program erase suspend operation will be triggered when
            /// the bit is set. The bit will be cleared once the operation done.1: enable 0:
            /// disable.
            FLASH_PER: u1,
            /// program erase suspend bit, program erase suspend operation will be triggered
            /// when the bit is set. The bit will be cleared once the operation done.1: enable
            /// 0: disable.
            FLASH_PES: u1,
            /// 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4 or *128) SPI_CLK cycles after
            /// program erase resume command is sent. 0: SPI1 does not wait after program erase
            /// resume command is sent.
            FLASH_PER_WAIT_EN: u1,
            /// 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4 or *128) SPI_CLK cycles after
            /// program erase suspend command is sent. 0: SPI1 does not wait after program erase
            /// suspend command is sent.
            FLASH_PES_WAIT_EN: u1,
            /// Set this bit to enable PES end triggers PER transfer option. If this bit is 0,
            /// application should send PER after PES is done.
            PES_PER_EN: u1,
            /// Set this bit to enable Auto-suspending function.
            FLASH_PES_EN: u1,
            /// The mask value when check SUS/SUS1/SUS2 status bit. If the read status value is
            /// status_in[15:0](only status_in[7:0] is valid when only one byte of data is read
            /// out, status_in[15:0] is valid when two bytes of data are read out),
            /// SUS/SUS1/SUS2 = status_in[15:0]^ SPI_MEM_PESR_END_MSK[15:0].
            PESR_END_MSK: u16,
            /// 1: Read two bytes when check flash SUS/SUS1/SUS2 status bit. 0: Read one byte
            /// when check flash SUS/SUS1/SUS2 status bit
            RD_SUS_2B: u1,
            /// 1: Both WIP and SUS/SUS1/SUS2 bits should be checked to insure the resume status
            /// of flash. 0: Only need to check WIP is 0.
            PER_END_EN: u1,
            /// 1: Both WIP and SUS/SUS1/SUS2 bits should be checked to insure the suspend
            /// status of flash. 0: Only need to check WIP is 0.
            PES_END_EN: u1,
            /// When SPI1 checks SUS/SUS1/SUS2 bits fail for SPI_MEM_SUS_TIMEOUT_CNT[6:0] times,
            /// it will be treated as check pass.
            SUS_TIMEOUT_CNT: u7,
        }), base_address + 0x9c);

        /// address: 0x600020a0
        /// SPI1 flash suspend command register
        pub const FLASH_SUS_CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Program/Erase resume command.
            FLASH_PER_COMMAND: u8,
            /// Program/Erase suspend command.
            FLASH_PES_COMMAND: u8,
            /// Flash SUS/SUS1/SUS2 status bit read command. The command should be sent when
            /// SUS/SUS1/SUS2 bit should be checked to insure the suspend or resume status of
            /// flash.
            WAIT_PESR_COMMAND: u16,
        }), base_address + 0xa0);

        /// address: 0x600020a4
        /// SPI1 flash suspend status register
        pub const SUS_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// The status of flash suspend, only used in SPI1.
            FLASH_SUS: u1,
            /// 1: SPI1 sends out SPI_MEM_WAIT_PESR_COMMAND[15:0] to check SUS/SUS1/SUS2 bit. 0:
            /// SPI1 sends out SPI_MEM_WAIT_PESR_COMMAND[7:0] to check SUS/SUS1/SUS2 bit.
            WAIT_PESR_CMD_2B: u1,
            /// 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after HPM
            /// command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK
            /// cycles after HPM command is sent.
            FLASH_HPM_DLY_128: u1,
            /// 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after RES
            /// command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK
            /// cycles after RES command is sent.
            FLASH_RES_DLY_128: u1,
            /// 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after DP
            /// command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK
            /// cycles after DP command is sent.
            FLASH_DP_DLY_128: u1,
            /// Valid when SPI_MEM_FLASH_PER_WAIT_EN is 1. 1: SPI1 waits
            /// (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after PER command is sent.
            /// 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after PER
            /// command is sent.
            FLASH_PER_DLY_128: u1,
            /// Valid when SPI_MEM_FLASH_PES_WAIT_EN is 1. 1: SPI1 waits
            /// (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 128) SPI_CLK cycles after PES command is sent.
            /// 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK cycles after PES
            /// command is sent.
            FLASH_PES_DLY_128: u1,
            /// 1: Enable SPI0 lock SPI0/1 arbiter option. 0: Disable it.
            SPI0_LOCK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xa4);

        /// address: 0x600020a8
        /// SPI1 timing control register
        pub const TIMING_CALI = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// The bit is used to enable timing auto-calibration for all reading operations.
            TIMING_CALI: u1,
            /// add extra dummy spi clock cycle length for spi clock calibration.
            EXTRA_DUMMY_CYCLELEN: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xa8);

        /// address: 0x600020c0
        /// SPI1 interrupt enable register
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The enable bit for SPI_MEM_PER_END_INT interrupt.
            PER_END_INT_ENA: u1,
            /// The enable bit for SPI_MEM_PES_END_INT interrupt.
            PES_END_INT_ENA: u1,
            /// The enable bit for SPI_MEM_WPE_END_INT interrupt.
            WPE_END_INT_ENA: u1,
            /// The enable bit for SPI_MEM_SLV_ST_END_INT interrupt.
            SLV_ST_END_INT_ENA: u1,
            /// The enable bit for SPI_MEM_MST_ST_END_INT interrupt.
            MST_ST_END_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xc0);

        /// address: 0x600020c4
        /// SPI1 interrupt clear register
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The clear bit for SPI_MEM_PER_END_INT interrupt.
            PER_END_INT_CLR: u1,
            /// The clear bit for SPI_MEM_PES_END_INT interrupt.
            PES_END_INT_CLR: u1,
            /// The clear bit for SPI_MEM_WPE_END_INT interrupt.
            WPE_END_INT_CLR: u1,
            /// The clear bit for SPI_MEM_SLV_ST_END_INT interrupt.
            SLV_ST_END_INT_CLR: u1,
            /// The clear bit for SPI_MEM_MST_ST_END_INT interrupt.
            MST_ST_END_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xc4);

        /// address: 0x600020c8
        /// SPI1 interrupt raw register
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw bit for SPI_MEM_PER_END_INT interrupt. 1: Triggered when Auto Resume
            /// command (0x7A) is sent and flash is resumed. 0: Others.
            PER_END_INT_RAW: u1,
            /// The raw bit for SPI_MEM_PES_END_INT interrupt.1: Triggered when Auto Suspend
            /// command (0x75) is sent and flash is suspended. 0: Others.
            PES_END_INT_RAW: u1,
            /// The raw bit for SPI_MEM_WPE_END_INT interrupt. 1: Triggered when
            /// WRSR/PP/SE/BE/CE is sent and flash is already idle. 0: Others.
            WPE_END_INT_RAW: u1,
            /// The raw bit for SPI_MEM_SLV_ST_END_INT interrupt. 1: Triggered when spi1_slv_st
            /// is changed from non idle state to idle state. It means that SPI_CS raises high.
            /// 0: Others
            SLV_ST_END_INT_RAW: u1,
            /// The raw bit for SPI_MEM_MST_ST_END_INT interrupt. 1: Triggered when spi1_mst_st
            /// is changed from non idle state to idle state. 0: Others.
            MST_ST_END_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xc8);

        /// address: 0x600020cc
        /// SPI1 interrupt status register
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The status bit for SPI_MEM_PER_END_INT interrupt.
            PER_END_INT_ST: u1,
            /// The status bit for SPI_MEM_PES_END_INT interrupt.
            PES_END_INT_ST: u1,
            /// The status bit for SPI_MEM_WPE_END_INT interrupt.
            WPE_END_INT_ST: u1,
            /// The status bit for SPI_MEM_SLV_ST_END_INT interrupt.
            SLV_ST_END_INT_ST: u1,
            /// The status bit for SPI_MEM_MST_ST_END_INT interrupt.
            MST_ST_END_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xcc);

        /// address: 0x600020dc
        /// SPI1 clk_gate register
        pub const CLOCK_GATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Register clock gate enable signal. 1: Enable. 0: Disable.
            CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xdc);

        /// address: 0x600023fc
        /// Version control register
        pub const DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0x3fc);
    };

    /// SPI (Serial Peripheral Interface) Controller
    pub const SPI2 = struct {
        pub const base_address = 0x60024000;

        /// address: 0x60024000
        /// Command control register
        pub const CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Define the APB cycles of SPI_CONF state. Can be configured in CONF state.
            CONF_BITLEN: u18,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Set this bit to synchronize SPI registers from APB clock domain into SPI module
            /// clock domain, which is only used in SPI master mode.
            UPDATE: u1,
            /// User define command enable. An operation will be triggered when the bit is set.
            /// The bit will be cleared once the operation done.1: enable 0: disable. Can not be
            /// changed by CONF_buf.
            USR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x0);

        /// address: 0x60024004
        /// Address value register
        pub const ADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address to slave. Can be configured in CONF state.
            USR_ADDR_VALUE: u32,
        }), base_address + 0x4);

        /// address: 0x60024008
        /// SPI control register
        pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// In the dummy phase the signal level of spi is output by the spi controller. Can
            /// be configured in CONF state.
            DUMMY_OUT: u1,
            reserved3: u1,
            /// Apply 2 signals during addr phase 1:enable 0: disable. Can be configured in CONF
            /// state.
            FADDR_DUAL: u1,
            /// Apply 4 signals during addr phase 1:enable 0: disable. Can be configured in CONF
            /// state.
            FADDR_QUAD: u1,
            reserved4: u1,
            /// Apply 2 signals during command phase 1:enable 0: disable. Can be configured in
            /// CONF state.
            FCMD_DUAL: u1,
            /// Apply 4 signals during command phase 1:enable 0: disable. Can be configured in
            /// CONF state.
            FCMD_QUAD: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
            /// Can be configured in CONF state.
            FREAD_DUAL: u1,
            /// In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
            /// Can be configured in CONF state.
            FREAD_QUAD: u1,
            reserved9: u1,
            reserved10: u1,
            /// The bit is used to set MISO line polarity, 1: high 0, low. Can be configured in
            /// CONF state.
            Q_POL: u1,
            /// The bit is used to set MOSI line polarity, 1: high 0, low. Can be configured in
            /// CONF state.
            D_POL: u1,
            /// SPI_HOLD output value when SPI is idle. 1: output high, 0: output low. Can be
            /// configured in CONF state.
            HOLD_POL: u1,
            /// Write protect signal output when SPI is idle. 1: output high, 0: output low. Can
            /// be configured in CONF state.
            WP_POL: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// In read-data (MISO) phase 1: LSB first 0: MSB first. Can be configured in CONF
            /// state.
            RD_BIT_ORDER: u1,
            /// In command address write-data (MOSI) phases 1: LSB firs 0: MSB first. Can be
            /// configured in CONF state.
            WR_BIT_ORDER: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x8);

        /// address: 0x6002400c
        /// SPI clock control register
        pub const CLOCK = @intToPtr(*volatile Mmio(32, packed struct {
            /// In the master mode it must be equal to spi_clkcnt_N. In the slave mode it must
            /// be 0. Can be configured in CONF state.
            CLKCNT_L: u6,
            /// In the master mode it must be floor((spi_clkcnt_N+1)/2-1). In the slave mode it
            /// must be 0. Can be configured in CONF state.
            CLKCNT_H: u6,
            /// In the master mode it is the divider of spi_clk. So spi_clk frequency is
            /// system/(spi_clkdiv_pre+1)/(spi_clkcnt_N+1). Can be configured in CONF state.
            CLKCNT_N: u6,
            /// In the master mode it is pre-divider of spi_clk. Can be configured in CONF
            /// state.
            CLKDIV_PRE: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// In the master mode 1: spi_clk is eqaul to system 0: spi_clk is divided from
            /// system clock. Can be configured in CONF state.
            CLK_EQU_SYSCLK: u1,
        }), base_address + 0xc);

        /// address: 0x60024010
        /// SPI USER control register
        pub const USER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set the bit to enable full duplex communication. 1: enable 0: disable. Can be
            /// configured in CONF state.
            DOUTDIN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Both for master mode and slave mode. 1: spi controller is in QPI mode. 0:
            /// others. Can be configured in CONF state.
            QPI_MODE: u1,
            reserved2: u1,
            /// In the slave mode, this bit can be used to change the polarity of tsck. 0: tsck
            /// = spi_ck_i. 1:tsck = !spi_ck_i.
            TSCK_I_EDGE: u1,
            /// spi cs keep low when spi is in done phase. 1: enable 0: disable. Can be
            /// configured in CONF state.
            CS_HOLD: u1,
            /// spi cs is enable when spi is in prepare phase. 1: enable 0: disable. Can be
            /// configured in CONF state.
            CS_SETUP: u1,
            /// In the slave mode, this bit can be used to change the polarity of rsck. 0: rsck
            /// = !spi_ck_i. 1:rsck = spi_ck_i.
            RSCK_I_EDGE: u1,
            /// the bit combined with spi_mosi_delay_mode bits to set mosi signal delay mode.
            /// Can be configured in CONF state.
            CK_OUT_EDGE: u1,
            reserved3: u1,
            reserved4: u1,
            /// In the write operations read-data phase apply 2 signals. Can be configured in
            /// CONF state.
            FWRITE_DUAL: u1,
            /// In the write operations read-data phase apply 4 signals. Can be configured in
            /// CONF state.
            FWRITE_QUAD: u1,
            reserved5: u1,
            /// 1: Enable the DMA CONF phase of next seg-trans operation, which means seg-trans
            /// will continue. 0: The seg-trans will end after the current SPI seg-trans or this
            /// is not seg-trans mode. Can be configured in CONF state.
            USR_CONF_NXT: u1,
            reserved6: u1,
            /// Set the bit to enable 3-line half duplex communication mosi and miso signals
            /// share the same pin. 1: enable 0: disable. Can be configured in CONF state.
            SIO: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// read-data phase only access to high-part of the buffer spi_w8~spi_w15. 1: enable
            /// 0: disable. Can be configured in CONF state.
            USR_MISO_HIGHPART: u1,
            /// write-data phase only access to high-part of the buffer spi_w8~spi_w15. 1:
            /// enable 0: disable. Can be configured in CONF state.
            USR_MOSI_HIGHPART: u1,
            /// spi clock is disable in dummy phase when the bit is enable. Can be configured in
            /// CONF state.
            USR_DUMMY_IDLE: u1,
            /// This bit enable the write-data phase of an operation. Can be configured in CONF
            /// state.
            USR_MOSI: u1,
            /// This bit enable the read-data phase of an operation. Can be configured in CONF
            /// state.
            USR_MISO: u1,
            /// This bit enable the dummy phase of an operation. Can be configured in CONF
            /// state.
            USR_DUMMY: u1,
            /// This bit enable the address phase of an operation. Can be configured in CONF
            /// state.
            USR_ADDR: u1,
            /// This bit enable the command phase of an operation. Can be configured in CONF
            /// state.
            USR_COMMAND: u1,
        }), base_address + 0x10);

        /// address: 0x60024014
        /// SPI USER control register 1
        pub const USER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The length in spi_clk cycles of dummy phase. The register value shall be
            /// (cycle_num-1). Can be configured in CONF state.
            USR_DUMMY_CYCLELEN: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// 1: SPI transfer is ended when SPI RX AFIFO wfull error is valid in GP-SPI master
            /// FD/HD-mode. 0: SPI transfer is not ended when SPI RX AFIFO wfull error is valid
            /// in GP-SPI master FD/HD-mode.
            MST_WFULL_ERR_END_EN: u1,
            /// (cycles+1) of prepare phase by spi clock this bits are combined with
            /// spi_cs_setup bit. Can be configured in CONF state.
            CS_SETUP_TIME: u5,
            /// delay cycles of cs pin by spi clock this bits are combined with spi_cs_hold bit.
            /// Can be configured in CONF state.
            CS_HOLD_TIME: u5,
            /// The length in bits of address phase. The register value shall be (bit_num-1).
            /// Can be configured in CONF state.
            USR_ADDR_BITLEN: u5,
        }), base_address + 0x14);

        /// address: 0x60024018
        /// SPI USER control register 2
        pub const USER2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of command. Can be configured in CONF state.
            USR_COMMAND_VALUE: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// 1: SPI transfer is ended when SPI TX AFIFO read empty error is valid in GP-SPI
            /// master FD/HD-mode. 0: SPI transfer is not ended when SPI TX AFIFO read empty
            /// error is valid in GP-SPI master FD/HD-mode.
            MST_REMPTY_ERR_END_EN: u1,
            /// The length in bits of command phase. The register value shall be (bit_num-1).
            /// Can be configured in CONF state.
            USR_COMMAND_BITLEN: u4,
        }), base_address + 0x18);

        /// address: 0x6002401c
        /// SPI data bit length control register
        pub const MS_DLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// The value of these bits is the configured SPI transmission data bit length in
            /// master mode DMA controlled transfer or CPU controlled transfer. The value is
            /// also the configured bit length in slave mode DMA RX controlled transfer. The
            /// register value shall be (bit_num-1). Can be configured in CONF state.
            MS_DATA_BITLEN: u18,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x1c);

        /// address: 0x60024020
        /// SPI misc register
        pub const MISC = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI CS0 pin enable, 1: disable CS0, 0: spi_cs0 signal is from/to CS0 pin. Can be
            /// configured in CONF state.
            CS0_DIS: u1,
            /// SPI CS1 pin enable, 1: disable CS1, 0: spi_cs1 signal is from/to CS1 pin. Can be
            /// configured in CONF state.
            CS1_DIS: u1,
            /// SPI CS2 pin enable, 1: disable CS2, 0: spi_cs2 signal is from/to CS2 pin. Can be
            /// configured in CONF state.
            CS2_DIS: u1,
            /// SPI CS3 pin enable, 1: disable CS3, 0: spi_cs3 signal is from/to CS3 pin. Can be
            /// configured in CONF state.
            CS3_DIS: u1,
            /// SPI CS4 pin enable, 1: disable CS4, 0: spi_cs4 signal is from/to CS4 pin. Can be
            /// configured in CONF state.
            CS4_DIS: u1,
            /// SPI CS5 pin enable, 1: disable CS5, 0: spi_cs5 signal is from/to CS5 pin. Can be
            /// configured in CONF state.
            CS5_DIS: u1,
            /// 1: spi clk out disable, 0: spi clk out enable. Can be configured in CONF state.
            CK_DIS: u1,
            /// In the master mode the bits are the polarity of spi cs line, the value is
            /// equivalent to spi_cs ^ spi_master_cs_pol. Can be configured in CONF state.
            MASTER_CS_POL: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// spi slave input cs polarity select. 1: inv 0: not change. Can be configured in
            /// CONF state.
            SLAVE_CS_POL: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// 1: spi clk line is high when idle 0: spi clk line is low when idle. Can be
            /// configured in CONF state.
            CK_IDLE_EDGE: u1,
            /// spi cs line keep low when the bit is set. Can be configured in CONF state.
            CS_KEEP_ACTIVE: u1,
            /// 1: spi quad input swap enable 0: spi quad input swap disable. Can be configured
            /// in CONF state.
            QUAD_DIN_PIN_SWAP: u1,
        }), base_address + 0x20);

        /// address: 0x60024024
        /// SPI input delay mode configuration
        pub const DIN_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// the input signals are delayed by SPI module clock cycles, 0: input without
            /// delayed, 1: input with the posedge of clk_apb,2 input with the negedge of
            /// clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
            DIN0_MODE: u2,
            /// the input signals are delayed by SPI module clock cycles, 0: input without
            /// delayed, 1: input with the posedge of clk_apb,2 input with the negedge of
            /// clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
            DIN1_MODE: u2,
            /// the input signals are delayed by SPI module clock cycles, 0: input without
            /// delayed, 1: input with the posedge of clk_apb,2 input with the negedge of
            /// clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
            DIN2_MODE: u2,
            /// the input signals are delayed by SPI module clock cycles, 0: input without
            /// delayed, 1: input with the posedge of clk_apb,2 input with the negedge of
            /// clk_apb, 3: input with the spi_clk. Can be configured in CONF state.
            DIN3_MODE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// 1:enable hclk in SPI input timing module. 0: disable it. Can be configured in
            /// CONF state.
            TIMING_HCLK_ACTIVE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x24);

        /// address: 0x60024028
        /// SPI input delay number configuration
        pub const DIN_NUM = @intToPtr(*volatile Mmio(32, packed struct {
            /// the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle,
            /// 1: delayed by 2 cycles,... Can be configured in CONF state.
            DIN0_NUM: u2,
            /// the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle,
            /// 1: delayed by 2 cycles,... Can be configured in CONF state.
            DIN1_NUM: u2,
            /// the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle,
            /// 1: delayed by 2 cycles,... Can be configured in CONF state.
            DIN2_NUM: u2,
            /// the input signals are delayed by SPI module clock cycles, 0: delayed by 1 cycle,
            /// 1: delayed by 2 cycles,... Can be configured in CONF state.
            DIN3_NUM: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);

        /// address: 0x6002402c
        /// SPI output delay mode configuration
        pub const DOUT_MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// The output signal 0 is delayed by the SPI module clock, 0: output without
            /// delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can
            /// be configured in CONF state.
            DOUT0_MODE: u1,
            /// The output signal 1 is delayed by the SPI module clock, 0: output without
            /// delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can
            /// be configured in CONF state.
            DOUT1_MODE: u1,
            /// The output signal 2 is delayed by the SPI module clock, 0: output without
            /// delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can
            /// be configured in CONF state.
            DOUT2_MODE: u1,
            /// The output signal 3 is delayed by the SPI module clock, 0: output without
            /// delayed, 1: output delay for a SPI module clock cycle at its negative edge. Can
            /// be configured in CONF state.
            DOUT3_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x2c);

        /// address: 0x60024030
        /// SPI DMA control register
        pub const DMA_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Enable dma segment transfer in spi dma half slave mode. 1: enable. 0: disable.
            DMA_SLV_SEG_TRANS_EN: u1,
            /// 1: spi_dma_infifo_full_vld is cleared by spi slave cmd 5. 0:
            /// spi_dma_infifo_full_vld is cleared by spi_trans_done.
            SLV_RX_SEG_TRANS_CLR_EN: u1,
            /// 1: spi_dma_outfifo_empty_vld is cleared by spi slave cmd 6. 0:
            /// spi_dma_outfifo_empty_vld is cleared by spi_trans_done.
            SLV_TX_SEG_TRANS_CLR_EN: u1,
            /// 1: spi_dma_inlink_eof is set when the number of dma pushed data bytes is equal
            /// to the value of spi_slv/mst_dma_rd_bytelen[19:0] in spi dma transition. 0:
            /// spi_dma_inlink_eof is set by spi_trans_done in non-seg-trans or
            /// spi_dma_seg_trans_done in seg-trans.
            RX_EOF_EN: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// Set this bit to enable SPI DMA controlled receive data mode.
            DMA_RX_ENA: u1,
            /// Set this bit to enable SPI DMA controlled send data mode.
            DMA_TX_ENA: u1,
            /// Set this bit to reset RX AFIFO, which is used to receive data in SPI master and
            /// slave mode transfer.
            RX_AFIFO_RST: u1,
            /// Set this bit to reset BUF TX AFIFO, which is used send data out in SPI slave CPU
            /// controlled mode transfer and master mode transfer.
            BUF_AFIFO_RST: u1,
            /// Set this bit to reset DMA TX AFIFO, which is used to send data out in SPI slave
            /// DMA controlled mode transfer.
            DMA_AFIFO_RST: u1,
        }), base_address + 0x30);

        /// address: 0x60024034
        /// SPI DMA interrupt enable register
        pub const DMA_INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The enable bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
            DMA_INFIFO_FULL_ERR_INT_ENA: u1,
            /// The enable bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
            DMA_OUTFIFO_EMPTY_ERR_INT_ENA: u1,
            /// The enable bit for SPI slave Ex_QPI interrupt.
            SLV_EX_QPI_INT_ENA: u1,
            /// The enable bit for SPI slave En_QPI interrupt.
            SLV_EN_QPI_INT_ENA: u1,
            /// The enable bit for SPI slave CMD7 interrupt.
            SLV_CMD7_INT_ENA: u1,
            /// The enable bit for SPI slave CMD8 interrupt.
            SLV_CMD8_INT_ENA: u1,
            /// The enable bit for SPI slave CMD9 interrupt.
            SLV_CMD9_INT_ENA: u1,
            /// The enable bit for SPI slave CMDA interrupt.
            SLV_CMDA_INT_ENA: u1,
            /// The enable bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
            SLV_RD_DMA_DONE_INT_ENA: u1,
            /// The enable bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
            SLV_WR_DMA_DONE_INT_ENA: u1,
            /// The enable bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
            SLV_RD_BUF_DONE_INT_ENA: u1,
            /// The enable bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
            SLV_WR_BUF_DONE_INT_ENA: u1,
            /// The enable bit for SPI_TRANS_DONE_INT interrupt.
            TRANS_DONE_INT_ENA: u1,
            /// The enable bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
            DMA_SEG_TRANS_DONE_INT_ENA: u1,
            /// The enable bit for SPI_SEG_MAGIC_ERR_INT interrupt.
            SEG_MAGIC_ERR_INT_ENA: u1,
            /// The enable bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
            SLV_BUF_ADDR_ERR_INT_ENA: u1,
            /// The enable bit for SPI_SLV_CMD_ERR_INT interrupt.
            SLV_CMD_ERR_INT_ENA: u1,
            /// The enable bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
            MST_RX_AFIFO_WFULL_ERR_INT_ENA: u1,
            /// The enable bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
            MST_TX_AFIFO_REMPTY_ERR_INT_ENA: u1,
            /// The enable bit for SPI_APP2_INT interrupt.
            APP2_INT_ENA: u1,
            /// The enable bit for SPI_APP1_INT interrupt.
            APP1_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x34);

        /// address: 0x60024038
        /// SPI DMA interrupt clear register
        pub const DMA_INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// The clear bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
            DMA_INFIFO_FULL_ERR_INT_CLR: u1,
            /// The clear bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
            DMA_OUTFIFO_EMPTY_ERR_INT_CLR: u1,
            /// The clear bit for SPI slave Ex_QPI interrupt.
            SLV_EX_QPI_INT_CLR: u1,
            /// The clear bit for SPI slave En_QPI interrupt.
            SLV_EN_QPI_INT_CLR: u1,
            /// The clear bit for SPI slave CMD7 interrupt.
            SLV_CMD7_INT_CLR: u1,
            /// The clear bit for SPI slave CMD8 interrupt.
            SLV_CMD8_INT_CLR: u1,
            /// The clear bit for SPI slave CMD9 interrupt.
            SLV_CMD9_INT_CLR: u1,
            /// The clear bit for SPI slave CMDA interrupt.
            SLV_CMDA_INT_CLR: u1,
            /// The clear bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
            SLV_RD_DMA_DONE_INT_CLR: u1,
            /// The clear bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
            SLV_WR_DMA_DONE_INT_CLR: u1,
            /// The clear bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
            SLV_RD_BUF_DONE_INT_CLR: u1,
            /// The clear bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
            SLV_WR_BUF_DONE_INT_CLR: u1,
            /// The clear bit for SPI_TRANS_DONE_INT interrupt.
            TRANS_DONE_INT_CLR: u1,
            /// The clear bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
            DMA_SEG_TRANS_DONE_INT_CLR: u1,
            /// The clear bit for SPI_SEG_MAGIC_ERR_INT interrupt.
            SEG_MAGIC_ERR_INT_CLR: u1,
            /// The clear bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
            SLV_BUF_ADDR_ERR_INT_CLR: u1,
            /// The clear bit for SPI_SLV_CMD_ERR_INT interrupt.
            SLV_CMD_ERR_INT_CLR: u1,
            /// The clear bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
            MST_RX_AFIFO_WFULL_ERR_INT_CLR: u1,
            /// The clear bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
            MST_TX_AFIFO_REMPTY_ERR_INT_CLR: u1,
            /// The clear bit for SPI_APP2_INT interrupt.
            APP2_INT_CLR: u1,
            /// The clear bit for SPI_APP1_INT interrupt.
            APP1_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x38);

        /// address: 0x6002403c
        /// SPI DMA interrupt raw register
        pub const DMA_INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: The current data rate of DMA Rx is smaller than that of SPI, which will lose
            /// the receive data. 0: Others.
            DMA_INFIFO_FULL_ERR_INT_RAW: u1,
            /// 1: The current data rate of DMA TX is smaller than that of SPI. SPI will stop in
            /// master mode and send out all 0 in slave mode. 0: Others.
            DMA_OUTFIFO_EMPTY_ERR_INT_RAW: u1,
            /// The raw bit for SPI slave Ex_QPI interrupt. 1: SPI slave mode Ex_QPI
            /// transmission is ended. 0: Others.
            SLV_EX_QPI_INT_RAW: u1,
            /// The raw bit for SPI slave En_QPI interrupt. 1: SPI slave mode En_QPI
            /// transmission is ended. 0: Others.
            SLV_EN_QPI_INT_RAW: u1,
            /// The raw bit for SPI slave CMD7 interrupt. 1: SPI slave mode CMD7 transmission is
            /// ended. 0: Others.
            SLV_CMD7_INT_RAW: u1,
            /// The raw bit for SPI slave CMD8 interrupt. 1: SPI slave mode CMD8 transmission is
            /// ended. 0: Others.
            SLV_CMD8_INT_RAW: u1,
            /// The raw bit for SPI slave CMD9 interrupt. 1: SPI slave mode CMD9 transmission is
            /// ended. 0: Others.
            SLV_CMD9_INT_RAW: u1,
            /// The raw bit for SPI slave CMDA interrupt. 1: SPI slave mode CMDA transmission is
            /// ended. 0: Others.
            SLV_CMDA_INT_RAW: u1,
            /// The raw bit for SPI_SLV_RD_DMA_DONE_INT interrupt. 1: SPI slave mode Rd_DMA
            /// transmission is ended. 0: Others.
            SLV_RD_DMA_DONE_INT_RAW: u1,
            /// The raw bit for SPI_SLV_WR_DMA_DONE_INT interrupt. 1: SPI slave mode Wr_DMA
            /// transmission is ended. 0: Others.
            SLV_WR_DMA_DONE_INT_RAW: u1,
            /// The raw bit for SPI_SLV_RD_BUF_DONE_INT interrupt. 1: SPI slave mode Rd_BUF
            /// transmission is ended. 0: Others.
            SLV_RD_BUF_DONE_INT_RAW: u1,
            /// The raw bit for SPI_SLV_WR_BUF_DONE_INT interrupt. 1: SPI slave mode Wr_BUF
            /// transmission is ended. 0: Others.
            SLV_WR_BUF_DONE_INT_RAW: u1,
            /// The raw bit for SPI_TRANS_DONE_INT interrupt. 1: SPI master mode transmission is
            /// ended. 0: others.
            TRANS_DONE_INT_RAW: u1,
            /// The raw bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt. 1: spi master DMA
            /// full-duplex/half-duplex seg-conf-trans ends or slave half-duplex seg-trans ends.
            /// And data has been pushed to corresponding memory. 0: seg-conf-trans or seg-trans
            /// is not ended or not occurred.
            DMA_SEG_TRANS_DONE_INT_RAW: u1,
            /// The raw bit for SPI_SEG_MAGIC_ERR_INT interrupt. 1: The magic value in CONF
            /// buffer is error in the DMA seg-conf-trans. 0: others.
            SEG_MAGIC_ERR_INT_RAW: u1,
            /// The raw bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt. 1: The accessing data
            /// address of the current SPI slave mode CPU controlled FD, Wr_BUF or Rd_BUF
            /// transmission is bigger than 63. 0: Others.
            SLV_BUF_ADDR_ERR_INT_RAW: u1,
            /// The raw bit for SPI_SLV_CMD_ERR_INT interrupt. 1: The slave command value in the
            /// current SPI slave HD mode transmission is not supported. 0: Others.
            SLV_CMD_ERR_INT_RAW: u1,
            /// The raw bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt. 1: There is a RX AFIFO
            /// write-full error when SPI inputs data in master mode. 0: Others.
            MST_RX_AFIFO_WFULL_ERR_INT_RAW: u1,
            /// The raw bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt. 1: There is a TX BUF
            /// AFIFO read-empty error when SPI outputs data in master mode. 0: Others.
            MST_TX_AFIFO_REMPTY_ERR_INT_RAW: u1,
            /// The raw bit for SPI_APP2_INT interrupt. The value is only controlled by
            /// application.
            APP2_INT_RAW: u1,
            /// The raw bit for SPI_APP1_INT interrupt. The value is only controlled by
            /// application.
            APP1_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x3c);

        /// address: 0x60024040
        /// SPI DMA interrupt status register
        pub const DMA_INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The status bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.
            DMA_INFIFO_FULL_ERR_INT_ST: u1,
            /// The status bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.
            DMA_OUTFIFO_EMPTY_ERR_INT_ST: u1,
            /// The status bit for SPI slave Ex_QPI interrupt.
            SLV_EX_QPI_INT_ST: u1,
            /// The status bit for SPI slave En_QPI interrupt.
            SLV_EN_QPI_INT_ST: u1,
            /// The status bit for SPI slave CMD7 interrupt.
            SLV_CMD7_INT_ST: u1,
            /// The status bit for SPI slave CMD8 interrupt.
            SLV_CMD8_INT_ST: u1,
            /// The status bit for SPI slave CMD9 interrupt.
            SLV_CMD9_INT_ST: u1,
            /// The status bit for SPI slave CMDA interrupt.
            SLV_CMDA_INT_ST: u1,
            /// The status bit for SPI_SLV_RD_DMA_DONE_INT interrupt.
            SLV_RD_DMA_DONE_INT_ST: u1,
            /// The status bit for SPI_SLV_WR_DMA_DONE_INT interrupt.
            SLV_WR_DMA_DONE_INT_ST: u1,
            /// The status bit for SPI_SLV_RD_BUF_DONE_INT interrupt.
            SLV_RD_BUF_DONE_INT_ST: u1,
            /// The status bit for SPI_SLV_WR_BUF_DONE_INT interrupt.
            SLV_WR_BUF_DONE_INT_ST: u1,
            /// The status bit for SPI_TRANS_DONE_INT interrupt.
            TRANS_DONE_INT_ST: u1,
            /// The status bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.
            DMA_SEG_TRANS_DONE_INT_ST: u1,
            /// The status bit for SPI_SEG_MAGIC_ERR_INT interrupt.
            SEG_MAGIC_ERR_INT_ST: u1,
            /// The status bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.
            SLV_BUF_ADDR_ERR_INT_ST: u1,
            /// The status bit for SPI_SLV_CMD_ERR_INT interrupt.
            SLV_CMD_ERR_INT_ST: u1,
            /// The status bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.
            MST_RX_AFIFO_WFULL_ERR_INT_ST: u1,
            /// The status bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.
            MST_TX_AFIFO_REMPTY_ERR_INT_ST: u1,
            /// The status bit for SPI_APP2_INT interrupt.
            APP2_INT_ST: u1,
            /// The status bit for SPI_APP1_INT interrupt.
            APP1_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x40);

        /// address: 0x60024098
        /// SPI CPU-controlled buffer0
        pub const W0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF0: u32,
        }), base_address + 0x98);

        /// address: 0x6002409c
        /// SPI CPU-controlled buffer1
        pub const W1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF1: u32,
        }), base_address + 0x9c);

        /// address: 0x600240a0
        /// SPI CPU-controlled buffer2
        pub const W2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF2: u32,
        }), base_address + 0xa0);

        /// address: 0x600240a4
        /// SPI CPU-controlled buffer3
        pub const W3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF3: u32,
        }), base_address + 0xa4);

        /// address: 0x600240a8
        /// SPI CPU-controlled buffer4
        pub const W4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF4: u32,
        }), base_address + 0xa8);

        /// address: 0x600240ac
        /// SPI CPU-controlled buffer5
        pub const W5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF5: u32,
        }), base_address + 0xac);

        /// address: 0x600240b0
        /// SPI CPU-controlled buffer6
        pub const W6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF6: u32,
        }), base_address + 0xb0);

        /// address: 0x600240b4
        /// SPI CPU-controlled buffer7
        pub const W7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF7: u32,
        }), base_address + 0xb4);

        /// address: 0x600240b8
        /// SPI CPU-controlled buffer8
        pub const W8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF8: u32,
        }), base_address + 0xb8);

        /// address: 0x600240bc
        /// SPI CPU-controlled buffer9
        pub const W9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF9: u32,
        }), base_address + 0xbc);

        /// address: 0x600240c0
        /// SPI CPU-controlled buffer10
        pub const W10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF10: u32,
        }), base_address + 0xc0);

        /// address: 0x600240c4
        /// SPI CPU-controlled buffer11
        pub const W11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF11: u32,
        }), base_address + 0xc4);

        /// address: 0x600240c8
        /// SPI CPU-controlled buffer12
        pub const W12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF12: u32,
        }), base_address + 0xc8);

        /// address: 0x600240cc
        /// SPI CPU-controlled buffer13
        pub const W13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF13: u32,
        }), base_address + 0xcc);

        /// address: 0x600240d0
        /// SPI CPU-controlled buffer14
        pub const W14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF14: u32,
        }), base_address + 0xd0);

        /// address: 0x600240d4
        /// SPI CPU-controlled buffer15
        pub const W15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// data buffer
            BUF15: u32,
        }), base_address + 0xd4);

        /// address: 0x600240e0
        /// SPI slave control register
        pub const SLAVE = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is
            /// delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS
            /// inactive 3: SPI clock is alwasy on. Can be configured in CONF state.
            CLK_MODE: u2,
            /// {CPOL, CPHA},1: support spi clk mode 1 and 3, first edge output data B[0]/B[7].
            /// 0: support spi clk mode 0 and 2, first edge output data B[1]/B[6].
            CLK_MODE_13: u1,
            /// It saves half a cycle when tsck is the same as rsck. 1: output data at rsck
            /// posedge 0: output data at tsck posedge
            RSCK_DATA_OUT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 1: SPI_SLV_DATA_BITLEN stores data bit length of master-read-slave data length
            /// in DMA controlled mode(Rd_DMA). 0: others
            SLV_RDDMA_BITLEN_EN: u1,
            /// 1: SPI_SLV_DATA_BITLEN stores data bit length of master-write-to-slave data
            /// length in DMA controlled mode(Wr_DMA). 0: others
            SLV_WRDMA_BITLEN_EN: u1,
            /// 1: SPI_SLV_DATA_BITLEN stores data bit length of master-read-slave data length
            /// in CPU controlled mode(Rd_BUF). 0: others
            SLV_RDBUF_BITLEN_EN: u1,
            /// 1: SPI_SLV_DATA_BITLEN stores data bit length of master-write-to-slave data
            /// length in CPU controlled mode(Wr_BUF). 0: others
            SLV_WRBUF_BITLEN_EN: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// The magic value of BM table in master DMA seg-trans.
            DMA_SEG_MAGIC_VALUE: u4,
            /// Set SPI work mode. 1: slave mode 0: master mode.
            MODE: u1,
            /// Software reset enable, reset the spi clock line cs line and data lines. Can be
            /// configured in CONF state.
            SOFT_RESET: u1,
            /// 1: Enable the DMA CONF phase of current seg-trans operation, which means
            /// seg-trans will start. 0: This is not seg-trans mode.
            USR_CONF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xe0);

        /// address: 0x600240e4
        /// SPI slave control register 1
        pub const SLAVE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The transferred data bit length in SPI slave FD and HD mode.
            SLV_DATA_BITLEN: u18,
            /// In the slave mode it is the value of command.
            SLV_LAST_COMMAND: u8,
            /// In the slave mode it is the value of address.
            SLV_LAST_ADDR: u6,
        }), base_address + 0xe4);

        /// address: 0x600240e8
        /// SPI module clock and register clock control
        pub const CLK_GATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to enable clk gate
            CLK_EN: u1,
            /// Set this bit to power on the SPI module clock.
            MST_CLK_ACTIVE: u1,
            /// This bit is used to select SPI module clock source in master mode. 1:
            /// PLL_CLK_80M. 0: XTAL CLK.
            MST_CLK_SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xe8);

        /// address: 0x600240f0
        /// Version control
        pub const DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0xf0);
    };

    /// System
    pub const SYSTEM = struct {
        pub const base_address = 0x600c0000;

        /// address: 0x600c0000
        /// cpu_peripheral clock gating register
        pub const CPU_PERI_CLK_EN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// reg_clk_en_assist_debug
            CLK_EN_ASSIST_DEBUG: u1,
            /// reg_clk_en_dedicated_gpio
            CLK_EN_DEDICATED_GPIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x600c0004
        /// cpu_peripheral reset register
        pub const CPU_PERI_RST_EN = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// reg_rst_en_assist_debug
            RST_EN_ASSIST_DEBUG: u1,
            /// reg_rst_en_dedicated_gpio
            RST_EN_DEDICATED_GPIO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x600c0008
        /// cpu clock config register
        pub const CPU_PER_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_cpuperiod_sel
            CPUPERIOD_SEL: u2,
            /// reg_pll_freq_sel
            PLL_FREQ_SEL: u1,
            /// reg_cpu_wait_mode_force_on
            CPU_WAIT_MODE_FORCE_ON: u1,
            /// reg_cpu_waiti_delay_num
            CPU_WAITI_DELAY_NUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x600c000c
        /// memory power down mask register
        pub const MEM_PD_MASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_lslp_mem_pd_mask
            LSLP_MEM_PD_MASK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xc);

        /// address: 0x600c0010
        /// peripheral clock gating register
        pub const PERIP_CLK_EN0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_timers_clk_en
            TIMERS_CLK_EN: u1,
            /// reg_spi01_clk_en
            SPI01_CLK_EN: u1,
            /// reg_uart_clk_en
            UART_CLK_EN: u1,
            /// reg_wdg_clk_en
            WDG_CLK_EN: u1,
            /// reg_i2s0_clk_en
            I2S0_CLK_EN: u1,
            /// reg_uart1_clk_en
            UART1_CLK_EN: u1,
            /// reg_spi2_clk_en
            SPI2_CLK_EN: u1,
            /// reg_ext0_clk_en
            I2C_EXT0_CLK_EN: u1,
            /// reg_uhci0_clk_en
            UHCI0_CLK_EN: u1,
            /// reg_rmt_clk_en
            RMT_CLK_EN: u1,
            /// reg_pcnt_clk_en
            PCNT_CLK_EN: u1,
            /// reg_ledc_clk_en
            LEDC_CLK_EN: u1,
            /// reg_uhci1_clk_en
            UHCI1_CLK_EN: u1,
            /// reg_timergroup_clk_en
            TIMERGROUP_CLK_EN: u1,
            /// reg_efuse_clk_en
            EFUSE_CLK_EN: u1,
            /// reg_timergroup1_clk_en
            TIMERGROUP1_CLK_EN: u1,
            /// reg_spi3_clk_en
            SPI3_CLK_EN: u1,
            /// reg_pwm0_clk_en
            PWM0_CLK_EN: u1,
            /// reg_ext1_clk_en
            EXT1_CLK_EN: u1,
            /// reg_can_clk_en
            CAN_CLK_EN: u1,
            /// reg_pwm1_clk_en
            PWM1_CLK_EN: u1,
            /// reg_i2s1_clk_en
            I2S1_CLK_EN: u1,
            /// reg_spi2_dma_clk_en
            SPI2_DMA_CLK_EN: u1,
            /// reg_usb_device_clk_en
            USB_DEVICE_CLK_EN: u1,
            /// reg_uart_mem_clk_en
            UART_MEM_CLK_EN: u1,
            /// reg_pwm2_clk_en
            PWM2_CLK_EN: u1,
            /// reg_pwm3_clk_en
            PWM3_CLK_EN: u1,
            /// reg_spi3_dma_clk_en
            SPI3_DMA_CLK_EN: u1,
            /// reg_apb_saradc_clk_en
            APB_SARADC_CLK_EN: u1,
            /// reg_systimer_clk_en
            SYSTIMER_CLK_EN: u1,
            /// reg_adc2_arb_clk_en
            ADC2_ARB_CLK_EN: u1,
            /// reg_spi4_clk_en
            SPI4_CLK_EN: u1,
        }), base_address + 0x10);

        /// address: 0x600c0014
        /// peripheral clock gating register
        pub const PERIP_CLK_EN1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// reg_crypto_aes_clk_en
            CRYPTO_AES_CLK_EN: u1,
            /// reg_crypto_sha_clk_en
            CRYPTO_SHA_CLK_EN: u1,
            /// reg_crypto_rsa_clk_en
            CRYPTO_RSA_CLK_EN: u1,
            /// reg_crypto_ds_clk_en
            CRYPTO_DS_CLK_EN: u1,
            /// reg_crypto_hmac_clk_en
            CRYPTO_HMAC_CLK_EN: u1,
            /// reg_dma_clk_en
            DMA_CLK_EN: u1,
            /// reg_sdio_host_clk_en
            SDIO_HOST_CLK_EN: u1,
            /// reg_lcd_cam_clk_en
            LCD_CAM_CLK_EN: u1,
            /// reg_uart2_clk_en
            UART2_CLK_EN: u1,
            /// reg_tsens_clk_en
            TSENS_CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x14);

        /// address: 0x600c0018
        /// reserved
        pub const PERIP_RST_EN0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_timers_rst
            TIMERS_RST: u1,
            /// reg_spi01_rst
            SPI01_RST: u1,
            /// reg_uart_rst
            UART_RST: u1,
            /// reg_wdg_rst
            WDG_RST: u1,
            /// reg_i2s0_rst
            I2S0_RST: u1,
            /// reg_uart1_rst
            UART1_RST: u1,
            /// reg_spi2_rst
            SPI2_RST: u1,
            /// reg_ext0_rst
            I2C_EXT0_RST: u1,
            /// reg_uhci0_rst
            UHCI0_RST: u1,
            /// reg_rmt_rst
            RMT_RST: u1,
            /// reg_pcnt_rst
            PCNT_RST: u1,
            /// reg_ledc_rst
            LEDC_RST: u1,
            /// reg_uhci1_rst
            UHCI1_RST: u1,
            /// reg_timergroup_rst
            TIMERGROUP_RST: u1,
            /// reg_efuse_rst
            EFUSE_RST: u1,
            /// reg_timergroup1_rst
            TIMERGROUP1_RST: u1,
            /// reg_spi3_rst
            SPI3_RST: u1,
            /// reg_pwm0_rst
            PWM0_RST: u1,
            /// reg_ext1_rst
            EXT1_RST: u1,
            /// reg_can_rst
            CAN_RST: u1,
            /// reg_pwm1_rst
            PWM1_RST: u1,
            /// reg_i2s1_rst
            I2S1_RST: u1,
            /// reg_spi2_dma_rst
            SPI2_DMA_RST: u1,
            /// reg_usb_device_rst
            USB_DEVICE_RST: u1,
            /// reg_uart_mem_rst
            UART_MEM_RST: u1,
            /// reg_pwm2_rst
            PWM2_RST: u1,
            /// reg_pwm3_rst
            PWM3_RST: u1,
            /// reg_spi3_dma_rst
            SPI3_DMA_RST: u1,
            /// reg_apb_saradc_rst
            APB_SARADC_RST: u1,
            /// reg_systimer_rst
            SYSTIMER_RST: u1,
            /// reg_adc2_arb_rst
            ADC2_ARB_RST: u1,
            /// reg_spi4_rst
            SPI4_RST: u1,
        }), base_address + 0x18);

        /// address: 0x600c001c
        /// peripheral reset register
        pub const PERIP_RST_EN1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// reg_crypto_aes_rst
            CRYPTO_AES_RST: u1,
            /// reg_crypto_sha_rst
            CRYPTO_SHA_RST: u1,
            /// reg_crypto_rsa_rst
            CRYPTO_RSA_RST: u1,
            /// reg_crypto_ds_rst
            CRYPTO_DS_RST: u1,
            /// reg_crypto_hmac_rst
            CRYPTO_HMAC_RST: u1,
            /// reg_dma_rst
            DMA_RST: u1,
            /// reg_sdio_host_rst
            SDIO_HOST_RST: u1,
            /// reg_lcd_cam_rst
            LCD_CAM_RST: u1,
            /// reg_uart2_rst
            UART2_RST: u1,
            /// reg_tsens_rst
            TSENS_RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1c);

        /// address: 0x600c0020
        /// clock config register
        pub const BT_LPCK_DIV_INT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_bt_lpck_div_num
            BT_LPCK_DIV_NUM: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x20);

        /// address: 0x600c0024
        /// clock config register
        pub const BT_LPCK_DIV_FRAC = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_bt_lpck_div_b
            BT_LPCK_DIV_B: u12,
            /// reg_bt_lpck_div_a
            BT_LPCK_DIV_A: u12,
            /// reg_lpclk_sel_rtc_slow
            LPCLK_SEL_RTC_SLOW: u1,
            /// reg_lpclk_sel_8m
            LPCLK_SEL_8M: u1,
            /// reg_lpclk_sel_xtal
            LPCLK_SEL_XTAL: u1,
            /// reg_lpclk_sel_xtal32k
            LPCLK_SEL_XTAL32K: u1,
            /// reg_lpclk_rtc_en
            LPCLK_RTC_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x24);

        /// address: 0x600c0028
        /// interrupt generate register
        pub const CPU_INTR_FROM_CPU_0 = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x28);

        /// address: 0x600c002c
        /// interrupt generate register
        pub const CPU_INTR_FROM_CPU_1 = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x2c);

        /// address: 0x600c0030
        /// interrupt generate register
        pub const CPU_INTR_FROM_CPU_2 = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x30);

        /// address: 0x600c0034
        /// interrupt generate register
        pub const CPU_INTR_FROM_CPU_3 = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x34);

        /// address: 0x600c0038
        /// rsa memory power control register
        pub const RSA_PD_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rsa_mem_pd
            RSA_MEM_PD: u1,
            /// reg_rsa_mem_force_pu
            RSA_MEM_FORCE_PU: u1,
            /// reg_rsa_mem_force_pd
            RSA_MEM_FORCE_PD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x38);

        /// address: 0x600c003c
        /// edma clcok and reset register
        pub const EDMA_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_edma_clk_on
            EDMA_CLK_ON: u1,
            /// reg_edma_reset
            EDMA_RESET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x3c);

        /// address: 0x600c0040
        /// cache control register
        pub const CACHE_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_icache_clk_on
            ICACHE_CLK_ON: u1,
            /// reg_icache_reset
            ICACHE_RESET: u1,
            /// reg_dcache_clk_on
            DCACHE_CLK_ON: u1,
            /// reg_dcache_reset
            DCACHE_RESET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x40);

        /// address: 0x600c0044
        /// SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG
        pub const EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_enable_spi_manual_encrypt
            ENABLE_SPI_MANUAL_ENCRYPT: u1,
            /// reg_enable_download_db_encrypt
            ENABLE_DOWNLOAD_DB_ENCRYPT: u1,
            /// reg_enable_download_g0cb_decrypt
            ENABLE_DOWNLOAD_G0CB_DECRYPT: u1,
            /// reg_enable_download_manual_encrypt
            ENABLE_DOWNLOAD_MANUAL_ENCRYPT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x44);

        /// address: 0x600c0048
        /// fast memory config register
        pub const RTC_FASTMEM_CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// reg_rtc_mem_crc_start
            RTC_MEM_CRC_START: u1,
            /// reg_rtc_mem_crc_addr
            RTC_MEM_CRC_ADDR: u11,
            /// reg_rtc_mem_crc_len
            RTC_MEM_CRC_LEN: u11,
            /// reg_rtc_mem_crc_finish
            RTC_MEM_CRC_FINISH: u1,
        }), base_address + 0x48);

        /// address: 0x600c004c
        /// reserved
        pub const RTC_FASTMEM_CRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_rtc_mem_crc_res
            RTC_MEM_CRC_RES: u32,
        }), base_address + 0x4c);

        /// address: 0x600c0050
        /// eco register
        pub const REDUNDANT_ECO_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_redundant_eco_drive
            REDUNDANT_ECO_DRIVE: u1,
            /// reg_redundant_eco_result
            REDUNDANT_ECO_RESULT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x50);

        /// address: 0x600c0054
        /// clock gating register
        pub const CLOCK_GATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_clk_en
            CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x54);

        /// address: 0x600c0058
        /// system clock config register
        pub const SYSCLK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_pre_div_cnt
            PRE_DIV_CNT: u10,
            /// reg_soc_clk_sel
            SOC_CLK_SEL: u2,
            /// reg_clk_xtal_freq
            CLK_XTAL_FREQ: u7,
            /// reg_clk_div_en
            CLK_DIV_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x58);

        /// address: 0x600c005c
        /// mem pvt register
        pub const MEM_PVT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_mem_path_len
            MEM_PATH_LEN: u4,
            /// reg_mem_err_cnt_clr
            MEM_ERR_CNT_CLR: u1,
            /// reg_mem_pvt_monitor_en
            MONITOR_EN: u1,
            /// reg_mem_timing_err_cnt
            MEM_TIMING_ERR_CNT: u16,
            /// reg_mem_vt_sel
            MEM_VT_SEL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x5c);

        /// address: 0x600c0060
        /// mem pvt register
        pub const COMB_PVT_LVT_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_path_len_lvt
            COMB_PATH_LEN_LVT: u5,
            /// reg_comb_err_cnt_clr_lvt
            COMB_ERR_CNT_CLR_LVT: u1,
            /// reg_comb_pvt_monitor_en_lvt
            COMB_PVT_MONITOR_EN_LVT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x60);

        /// address: 0x600c0064
        /// mem pvt register
        pub const COMB_PVT_NVT_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_path_len_nvt
            COMB_PATH_LEN_NVT: u5,
            /// reg_comb_err_cnt_clr_nvt
            COMB_ERR_CNT_CLR_NVT: u1,
            /// reg_comb_pvt_monitor_en_nvt
            COMB_PVT_MONITOR_EN_NVT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x64);

        /// address: 0x600c0068
        /// mem pvt register
        pub const COMB_PVT_HVT_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_path_len_hvt
            COMB_PATH_LEN_HVT: u5,
            /// reg_comb_err_cnt_clr_hvt
            COMB_ERR_CNT_CLR_HVT: u1,
            /// reg_comb_pvt_monitor_en_hvt
            COMB_PVT_MONITOR_EN_HVT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x68);

        /// address: 0x600c006c
        /// mem pvt register
        pub const COMB_PVT_ERR_LVT_SITE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_lvt_site0
            COMB_TIMING_ERR_CNT_LVT_SITE0: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x6c);

        /// address: 0x600c0070
        /// mem pvt register
        pub const COMB_PVT_ERR_NVT_SITE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_nvt_site0
            COMB_TIMING_ERR_CNT_NVT_SITE0: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x600c0074
        /// mem pvt register
        pub const COMB_PVT_ERR_HVT_SITE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_hvt_site0
            COMB_TIMING_ERR_CNT_HVT_SITE0: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x74);

        /// address: 0x600c0078
        /// mem pvt register
        pub const COMB_PVT_ERR_LVT_SITE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_lvt_site1
            COMB_TIMING_ERR_CNT_LVT_SITE1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x78);

        /// address: 0x600c007c
        /// mem pvt register
        pub const COMB_PVT_ERR_NVT_SITE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_nvt_site1
            COMB_TIMING_ERR_CNT_NVT_SITE1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x7c);

        /// address: 0x600c0080
        /// mem pvt register
        pub const COMB_PVT_ERR_HVT_SITE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_hvt_site1
            COMB_TIMING_ERR_CNT_HVT_SITE1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x600c0084
        /// mem pvt register
        pub const COMB_PVT_ERR_LVT_SITE2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_lvt_site2
            COMB_TIMING_ERR_CNT_LVT_SITE2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x600c0088
        /// mem pvt register
        pub const COMB_PVT_ERR_NVT_SITE2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_nvt_site2
            COMB_TIMING_ERR_CNT_NVT_SITE2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x600c008c
        /// mem pvt register
        pub const COMB_PVT_ERR_HVT_SITE2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_hvt_site2
            COMB_TIMING_ERR_CNT_HVT_SITE2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x600c0090
        /// mem pvt register
        pub const COMB_PVT_ERR_LVT_SITE3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_lvt_site3
            COMB_TIMING_ERR_CNT_LVT_SITE3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x90);

        /// address: 0x600c0094
        /// mem pvt register
        pub const COMB_PVT_ERR_NVT_SITE3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_nvt_site3
            COMB_TIMING_ERR_CNT_NVT_SITE3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x94);

        /// address: 0x600c0098
        /// mem pvt register
        pub const COMB_PVT_ERR_HVT_SITE3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_comb_timing_err_cnt_hvt_site3
            COMB_TIMING_ERR_CNT_HVT_SITE3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x98);

        /// address: 0x600c0ffc
        /// Version register
        pub const SYSTEM_REG_DATE = @intToPtr(*volatile MmioInt(32, u28), base_address + 0xffc);
    };

    /// System Timer
    pub const SYSTIMER = struct {
        pub const base_address = 0x60023000;

        /// address: 0x60023000
        /// SYSTIMER_CONF.
        pub const CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// systimer clock force on
            SYSTIMER_CLK_FO: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// target2 work enable
            TARGET2_WORK_EN: u1,
            /// target1 work enable
            TARGET1_WORK_EN: u1,
            /// target0 work enable
            TARGET0_WORK_EN: u1,
            /// If timer unit1 is stalled when core1 stalled
            TIMER_UNIT1_CORE1_STALL_EN: u1,
            /// If timer unit1 is stalled when core0 stalled
            TIMER_UNIT1_CORE0_STALL_EN: u1,
            /// If timer unit0 is stalled when core1 stalled
            TIMER_UNIT0_CORE1_STALL_EN: u1,
            /// If timer unit0 is stalled when core0 stalled
            TIMER_UNIT0_CORE0_STALL_EN: u1,
            /// timer unit1 work enable
            TIMER_UNIT1_WORK_EN: u1,
            /// timer unit0 work enable
            TIMER_UNIT0_WORK_EN: u1,
            /// register file clk gating
            CLK_EN: u1,
        }), base_address + 0x0);

        /// address: 0x60023004
        /// SYSTIMER_UNIT0_OP.
        pub const UNIT0_OP = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// reg_timer_unit0_value_valid
            TIMER_UNIT0_VALUE_VALID: u1,
            /// update timer_unit0
            TIMER_UNIT0_UPDATE: u1,
            padding0: u1,
        }), base_address + 0x4);

        /// address: 0x60023008
        /// SYSTIMER_UNIT1_OP.
        pub const UNIT1_OP = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// timer value is sync and valid
            TIMER_UNIT1_VALUE_VALID: u1,
            /// update timer unit1
            TIMER_UNIT1_UPDATE: u1,
            padding0: u1,
        }), base_address + 0x8);

        /// address: 0x6002300c
        /// SYSTIMER_UNIT0_LOAD_HI.
        pub const UNIT0_LOAD_HI = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer unit0 load high 32 bit
            TIMER_UNIT0_LOAD_HI: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0xc);

        /// address: 0x60023010
        /// SYSTIMER_UNIT0_LOAD_LO.
        pub const UNIT0_LOAD_LO = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer unit0 load low 32 bit
            TIMER_UNIT0_LOAD_LO: u32,
        }), base_address + 0x10);

        /// address: 0x60023014
        /// SYSTIMER_UNIT1_LOAD_HI.
        pub const UNIT1_LOAD_HI = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer unit1 load high 32 bit
            TIMER_UNIT1_LOAD_HI: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x14);

        /// address: 0x60023018
        /// SYSTIMER_UNIT1_LOAD_LO.
        pub const UNIT1_LOAD_LO = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer unit1 load low 32 bit
            TIMER_UNIT1_LOAD_LO: u32,
        }), base_address + 0x18);

        /// address: 0x6002301c
        /// SYSTIMER_TARGET0_HI.
        pub const TARGET0_HI = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer taget0 high 32 bit
            TIMER_TARGET0_HI: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x1c);

        /// address: 0x60023020
        /// SYSTIMER_TARGET0_LO.
        pub const TARGET0_LO = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer taget0 low 32 bit
            TIMER_TARGET0_LO: u32,
        }), base_address + 0x20);

        /// address: 0x60023024
        /// SYSTIMER_TARGET1_HI.
        pub const TARGET1_HI = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer taget1 high 32 bit
            TIMER_TARGET1_HI: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x24);

        /// address: 0x60023028
        /// SYSTIMER_TARGET1_LO.
        pub const TARGET1_LO = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer taget1 low 32 bit
            TIMER_TARGET1_LO: u32,
        }), base_address + 0x28);

        /// address: 0x6002302c
        /// SYSTIMER_TARGET2_HI.
        pub const TARGET2_HI = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer taget2 high 32 bit
            TIMER_TARGET2_HI: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x2c);

        /// address: 0x60023030
        /// SYSTIMER_TARGET2_LO.
        pub const TARGET2_LO = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer taget2 low 32 bit
            TIMER_TARGET2_LO: u32,
        }), base_address + 0x30);

        /// address: 0x60023034
        /// SYSTIMER_TARGET0_CONF.
        pub const TARGET0_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// target0 period
            TARGET0_PERIOD: u26,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Set target0 to period mode
            TARGET0_PERIOD_MODE: u1,
            /// select which unit to compare
            TARGET0_TIMER_UNIT_SEL: u1,
        }), base_address + 0x34);

        /// address: 0x60023038
        /// SYSTIMER_TARGET1_CONF.
        pub const TARGET1_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// target1 period
            TARGET1_PERIOD: u26,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Set target1 to period mode
            TARGET1_PERIOD_MODE: u1,
            /// select which unit to compare
            TARGET1_TIMER_UNIT_SEL: u1,
        }), base_address + 0x38);

        /// address: 0x6002303c
        /// SYSTIMER_TARGET2_CONF.
        pub const TARGET2_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// target2 period
            TARGET2_PERIOD: u26,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Set target2 to period mode
            TARGET2_PERIOD_MODE: u1,
            /// select which unit to compare
            TARGET2_TIMER_UNIT_SEL: u1,
        }), base_address + 0x3c);

        /// address: 0x60023040
        /// SYSTIMER_UNIT0_VALUE_HI.
        pub const UNIT0_VALUE_HI = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer read value high 32bit
            TIMER_UNIT0_VALUE_HI: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x40);

        /// address: 0x60023044
        /// SYSTIMER_UNIT0_VALUE_LO.
        pub const UNIT0_VALUE_LO = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer read value low 32bit
            TIMER_UNIT0_VALUE_LO: u32,
        }), base_address + 0x44);

        /// address: 0x60023048
        /// SYSTIMER_UNIT1_VALUE_HI.
        pub const UNIT1_VALUE_HI = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer read value high 32bit
            TIMER_UNIT1_VALUE_HI: u20,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x48);

        /// address: 0x6002304c
        /// SYSTIMER_UNIT1_VALUE_LO.
        pub const UNIT1_VALUE_LO = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer read value low 32bit
            TIMER_UNIT1_VALUE_LO: u32,
        }), base_address + 0x4c);

        /// address: 0x60023050
        /// SYSTIMER_COMP0_LOAD.
        pub const COMP0_LOAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer comp0 load value
            TIMER_COMP0_LOAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x50);

        /// address: 0x60023054
        /// SYSTIMER_COMP1_LOAD.
        pub const COMP1_LOAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer comp1 load value
            TIMER_COMP1_LOAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x54);

        /// address: 0x60023058
        /// SYSTIMER_COMP2_LOAD.
        pub const COMP2_LOAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer comp2 load value
            TIMER_COMP2_LOAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x58);

        /// address: 0x6002305c
        /// SYSTIMER_UNIT0_LOAD.
        pub const UNIT0_LOAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer unit0 load value
            TIMER_UNIT0_LOAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x5c);

        /// address: 0x60023060
        /// SYSTIMER_UNIT1_LOAD.
        pub const UNIT1_LOAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// timer unit1 load value
            TIMER_UNIT1_LOAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x60);

        /// address: 0x60023064
        /// SYSTIMER_INT_ENA.
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// interupt0 enable
            TARGET0_INT_ENA: u1,
            /// interupt1 enable
            TARGET1_INT_ENA: u1,
            /// interupt2 enable
            TARGET2_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x64);

        /// address: 0x60023068
        /// SYSTIMER_INT_RAW.
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// interupt0 raw
            TARGET0_INT_RAW: u1,
            /// interupt1 raw
            TARGET1_INT_RAW: u1,
            /// interupt2 raw
            TARGET2_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x68);

        /// address: 0x6002306c
        /// SYSTIMER_INT_CLR.
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// interupt0 clear
            TARGET0_INT_CLR: u1,
            /// interupt1 clear
            TARGET1_INT_CLR: u1,
            /// interupt2 clear
            TARGET2_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x6c);

        /// address: 0x60023070
        /// SYSTIMER_INT_ST.
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_target0_int_st
            TARGET0_INT_ST: u1,
            /// reg_target1_int_st
            TARGET1_INT_ST: u1,
            /// reg_target2_int_st
            TARGET2_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x70);

        /// address: 0x600230fc
        /// SYSTIMER_DATE.
        pub const DATE = @intToPtr(*volatile u32, base_address + 0xfc);
    };

    /// Timer Group
    pub const TIMG0 = struct {
        pub const base_address = 0x6001f000;

        /// address: 0x6001f000
        /// TIMG_T0CONFIG_REG.
        pub const T0CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// reg_t0_use_xtal.
            T0_USE_XTAL: u1,
            /// reg_t0_alarm_en.
            T0_ALARM_EN: u1,
            reserved9: u1,
            /// reg_t0_divcnt_rst.
            T0_DIVCNT_RST: u1,
            /// reg_t0_divider.
            T0_DIVIDER: u16,
            /// reg_t0_autoreload.
            T0_AUTORELOAD: u1,
            /// reg_t0_increase.
            T0_INCREASE: u1,
            /// reg_t0_en.
            T0_EN: u1,
        }), base_address + 0x0);

        /// address: 0x6001f004
        /// TIMG_T0LO_REG.
        pub const T0LO = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_lo
            T0_LO: u32,
        }), base_address + 0x4);

        /// address: 0x6001f008
        /// TIMG_T0HI_REG.
        pub const T0HI = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_hi
            T0_HI: u22,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x6001f00c
        /// TIMG_T0UPDATE_REG.
        pub const T0UPDATE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// t0_update
            T0_UPDATE: u1,
        }), base_address + 0xc);

        /// address: 0x6001f010
        /// TIMG_T0ALARMLO_REG.
        pub const T0ALARMLO = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_t0_alarm_lo.
            T0_ALARM_LO: u32,
        }), base_address + 0x10);

        /// address: 0x6001f014
        /// TIMG_T0ALARMHI_REG.
        pub const T0ALARMHI = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_t0_alarm_hi.
            T0_ALARM_HI: u22,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x14);

        /// address: 0x6001f018
        /// TIMG_T0LOADLO_REG.
        pub const T0LOADLO = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_t0_load_lo.
            T0_LOAD_LO: u32,
        }), base_address + 0x18);

        /// address: 0x6001f01c
        /// TIMG_T0LOADHI_REG.
        pub const T0LOADHI = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_t0_load_hi.
            T0_LOAD_HI: u22,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x1c);

        /// address: 0x6001f020
        /// TIMG_T0LOAD_REG.
        pub const T0LOAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_load
            T0_LOAD: u32,
        }), base_address + 0x20);

        /// address: 0x6001f048
        /// TIMG_WDTCONFIG0_REG.
        pub const WDTCONFIG0 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// reg_wdt_appcpu_reset_en.
            WDT_APPCPU_RESET_EN: u1,
            /// reg_wdt_procpu_reset_en.
            WDT_PROCPU_RESET_EN: u1,
            /// reg_wdt_flashboot_mod_en.
            WDT_FLASHBOOT_MOD_EN: u1,
            /// reg_wdt_sys_reset_length.
            WDT_SYS_RESET_LENGTH: u3,
            /// reg_wdt_cpu_reset_length.
            WDT_CPU_RESET_LENGTH: u3,
            /// reg_wdt_use_xtal.
            WDT_USE_XTAL: u1,
            /// reg_wdt_conf_update_en.
            WDT_CONF_UPDATE_EN: u1,
            /// reg_wdt_stg3.
            WDT_STG3: u2,
            /// reg_wdt_stg2.
            WDT_STG2: u2,
            /// reg_wdt_stg1.
            WDT_STG1: u2,
            /// reg_wdt_stg0.
            WDT_STG0: u2,
            /// reg_wdt_en.
            WDT_EN: u1,
        }), base_address + 0x48);

        /// address: 0x6001f04c
        /// TIMG_WDTCONFIG1_REG.
        pub const WDTCONFIG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_divcnt_rst.
            WDT_DIVCNT_RST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// reg_wdt_clk_prescale.
            WDT_CLK_PRESCALE: u16,
        }), base_address + 0x4c);

        /// address: 0x6001f050
        /// TIMG_WDTCONFIG2_REG.
        pub const WDTCONFIG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_stg0_hold.
            WDT_STG0_HOLD: u32,
        }), base_address + 0x50);

        /// address: 0x6001f054
        /// TIMG_WDTCONFIG3_REG.
        pub const WDTCONFIG3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_stg1_hold.
            WDT_STG1_HOLD: u32,
        }), base_address + 0x54);

        /// address: 0x6001f058
        /// TIMG_WDTCONFIG4_REG.
        pub const WDTCONFIG4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_stg2_hold.
            WDT_STG2_HOLD: u32,
        }), base_address + 0x58);

        /// address: 0x6001f05c
        /// TIMG_WDTCONFIG5_REG.
        pub const WDTCONFIG5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_stg3_hold.
            WDT_STG3_HOLD: u32,
        }), base_address + 0x5c);

        /// address: 0x6001f060
        /// TIMG_WDTFEED_REG.
        pub const WDTFEED = @intToPtr(*volatile Mmio(32, packed struct {
            /// wdt_feed
            WDT_FEED: u32,
        }), base_address + 0x60);

        /// address: 0x6001f064
        /// TIMG_WDTWPROTECT_REG.
        pub const WDTWPROTECT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_wkey.
            WDT_WKEY: u32,
        }), base_address + 0x64);

        /// address: 0x6001f068
        /// TIMG_RTCCALICFG_REG.
        pub const RTCCALICFG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// reg_rtc_cali_start_cycling.
            RTC_CALI_START_CYCLING: u1,
            /// reg_rtc_cali_clk_sel.0:rtcslowclock.1:clk_80m.2:xtal_32k
            RTC_CALI_CLK_SEL: u2,
            /// rtc_cali_rdy
            RTC_CALI_RDY: u1,
            /// reg_rtc_cali_max.
            RTC_CALI_MAX: u15,
            /// reg_rtc_cali_start.
            RTC_CALI_START: u1,
        }), base_address + 0x68);

        /// address: 0x6001f06c
        /// TIMG_RTCCALICFG1_REG.
        pub const RTCCALICFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// rtc_cali_cycling_data_vld
            RTC_CALI_CYCLING_DATA_VLD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// rtc_cali_value
            RTC_CALI_VALUE: u25,
        }), base_address + 0x6c);

        /// address: 0x6001f070
        /// INT_ENA_TIMG_REG
        pub const INT_ENA_TIMERS = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_int_ena
            T0_INT_ENA: u1,
            /// wdt_int_ena
            WDT_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x70);

        /// address: 0x6001f074
        /// INT_RAW_TIMG_REG
        pub const INT_RAW_TIMERS = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_int_raw
            T0_INT_RAW: u1,
            /// wdt_int_raw
            WDT_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x74);

        /// address: 0x6001f078
        /// INT_ST_TIMG_REG
        pub const INT_ST_TIMERS = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_int_st
            T0_INT_ST: u1,
            /// wdt_int_st
            WDT_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x78);

        /// address: 0x6001f07c
        /// INT_CLR_TIMG_REG
        pub const INT_CLR_TIMERS = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_int_clr
            T0_INT_CLR: u1,
            /// wdt_int_clr
            WDT_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x7c);

        /// address: 0x6001f080
        /// TIMG_RTCCALICFG2_REG.
        pub const RTCCALICFG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// timeoutindicator
            RTC_CALI_TIMEOUT: u1,
            reserved0: u1,
            reserved1: u1,
            /// reg_rtc_cali_timeout_rst_cnt.Cyclesthatreleasecalibrationtimeoutreset
            RTC_CALI_TIMEOUT_RST_CNT: u4,
            /// reg_rtc_cali_timeout_thres.timeoutifcalivaluecountsoverthreshold
            RTC_CALI_TIMEOUT_THRES: u25,
        }), base_address + 0x80);

        /// address: 0x6001f0f8
        /// TIMG_NTIMG_DATE_REG.
        pub const NTIMG_DATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_ntimers_date.
            NTIMGS_DATE: u28,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xf8);

        /// address: 0x6001f0fc
        /// TIMG_REGCLK_REG.
        pub const REGCLK = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// reg_wdt_clk_is_active.
            WDT_CLK_IS_ACTIVE: u1,
            /// reg_timer_clk_is_active.
            TIMER_CLK_IS_ACTIVE: u1,
            /// reg_clk_en.
            CLK_EN: u1,
        }), base_address + 0xfc);
    };

    /// Timer Group
    pub const TIMG1 = struct {
        pub const base_address = 0x60020000;

        /// address: 0x60020000
        /// TIMG_T0CONFIG_REG.
        pub const T0CONFIG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// reg_t0_use_xtal.
            T0_USE_XTAL: u1,
            /// reg_t0_alarm_en.
            T0_ALARM_EN: u1,
            reserved9: u1,
            /// reg_t0_divcnt_rst.
            T0_DIVCNT_RST: u1,
            /// reg_t0_divider.
            T0_DIVIDER: u16,
            /// reg_t0_autoreload.
            T0_AUTORELOAD: u1,
            /// reg_t0_increase.
            T0_INCREASE: u1,
            /// reg_t0_en.
            T0_EN: u1,
        }), base_address + 0x0);

        /// address: 0x60020004
        /// TIMG_T0LO_REG.
        pub const T0LO = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_lo
            T0_LO: u32,
        }), base_address + 0x4);

        /// address: 0x60020008
        /// TIMG_T0HI_REG.
        pub const T0HI = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_hi
            T0_HI: u22,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x6002000c
        /// TIMG_T0UPDATE_REG.
        pub const T0UPDATE = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            reserved29: u1,
            reserved30: u1,
            /// t0_update
            T0_UPDATE: u1,
        }), base_address + 0xc);

        /// address: 0x60020010
        /// TIMG_T0ALARMLO_REG.
        pub const T0ALARMLO = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_t0_alarm_lo.
            T0_ALARM_LO: u32,
        }), base_address + 0x10);

        /// address: 0x60020014
        /// TIMG_T0ALARMHI_REG.
        pub const T0ALARMHI = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_t0_alarm_hi.
            T0_ALARM_HI: u22,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x14);

        /// address: 0x60020018
        /// TIMG_T0LOADLO_REG.
        pub const T0LOADLO = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_t0_load_lo.
            T0_LOAD_LO: u32,
        }), base_address + 0x18);

        /// address: 0x6002001c
        /// TIMG_T0LOADHI_REG.
        pub const T0LOADHI = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_t0_load_hi.
            T0_LOAD_HI: u22,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x1c);

        /// address: 0x60020020
        /// TIMG_T0LOAD_REG.
        pub const T0LOAD = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_load
            T0_LOAD: u32,
        }), base_address + 0x20);

        /// address: 0x60020048
        /// TIMG_WDTCONFIG0_REG.
        pub const WDTCONFIG0 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// reg_wdt_appcpu_reset_en.
            WDT_APPCPU_RESET_EN: u1,
            /// reg_wdt_procpu_reset_en.
            WDT_PROCPU_RESET_EN: u1,
            /// reg_wdt_flashboot_mod_en.
            WDT_FLASHBOOT_MOD_EN: u1,
            /// reg_wdt_sys_reset_length.
            WDT_SYS_RESET_LENGTH: u3,
            /// reg_wdt_cpu_reset_length.
            WDT_CPU_RESET_LENGTH: u3,
            /// reg_wdt_use_xtal.
            WDT_USE_XTAL: u1,
            /// reg_wdt_conf_update_en.
            WDT_CONF_UPDATE_EN: u1,
            /// reg_wdt_stg3.
            WDT_STG3: u2,
            /// reg_wdt_stg2.
            WDT_STG2: u2,
            /// reg_wdt_stg1.
            WDT_STG1: u2,
            /// reg_wdt_stg0.
            WDT_STG0: u2,
            /// reg_wdt_en.
            WDT_EN: u1,
        }), base_address + 0x48);

        /// address: 0x6002004c
        /// TIMG_WDTCONFIG1_REG.
        pub const WDTCONFIG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_divcnt_rst.
            WDT_DIVCNT_RST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// reg_wdt_clk_prescale.
            WDT_CLK_PRESCALE: u16,
        }), base_address + 0x4c);

        /// address: 0x60020050
        /// TIMG_WDTCONFIG2_REG.
        pub const WDTCONFIG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_stg0_hold.
            WDT_STG0_HOLD: u32,
        }), base_address + 0x50);

        /// address: 0x60020054
        /// TIMG_WDTCONFIG3_REG.
        pub const WDTCONFIG3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_stg1_hold.
            WDT_STG1_HOLD: u32,
        }), base_address + 0x54);

        /// address: 0x60020058
        /// TIMG_WDTCONFIG4_REG.
        pub const WDTCONFIG4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_stg2_hold.
            WDT_STG2_HOLD: u32,
        }), base_address + 0x58);

        /// address: 0x6002005c
        /// TIMG_WDTCONFIG5_REG.
        pub const WDTCONFIG5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_stg3_hold.
            WDT_STG3_HOLD: u32,
        }), base_address + 0x5c);

        /// address: 0x60020060
        /// TIMG_WDTFEED_REG.
        pub const WDTFEED = @intToPtr(*volatile Mmio(32, packed struct {
            /// wdt_feed
            WDT_FEED: u32,
        }), base_address + 0x60);

        /// address: 0x60020064
        /// TIMG_WDTWPROTECT_REG.
        pub const WDTWPROTECT = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_wdt_wkey.
            WDT_WKEY: u32,
        }), base_address + 0x64);

        /// address: 0x60020068
        /// TIMG_RTCCALICFG_REG.
        pub const RTCCALICFG = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// reg_rtc_cali_start_cycling.
            RTC_CALI_START_CYCLING: u1,
            /// reg_rtc_cali_clk_sel.0:rtcslowclock.1:clk_80m.2:xtal_32k
            RTC_CALI_CLK_SEL: u2,
            /// rtc_cali_rdy
            RTC_CALI_RDY: u1,
            /// reg_rtc_cali_max.
            RTC_CALI_MAX: u15,
            /// reg_rtc_cali_start.
            RTC_CALI_START: u1,
        }), base_address + 0x68);

        /// address: 0x6002006c
        /// TIMG_RTCCALICFG1_REG.
        pub const RTCCALICFG1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// rtc_cali_cycling_data_vld
            RTC_CALI_CYCLING_DATA_VLD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// rtc_cali_value
            RTC_CALI_VALUE: u25,
        }), base_address + 0x6c);

        /// address: 0x60020070
        /// INT_ENA_TIMG_REG
        pub const INT_ENA_TIMERS = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_int_ena
            T0_INT_ENA: u1,
            /// wdt_int_ena
            WDT_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x70);

        /// address: 0x60020074
        /// INT_RAW_TIMG_REG
        pub const INT_RAW_TIMERS = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_int_raw
            T0_INT_RAW: u1,
            /// wdt_int_raw
            WDT_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x74);

        /// address: 0x60020078
        /// INT_ST_TIMG_REG
        pub const INT_ST_TIMERS = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_int_st
            T0_INT_ST: u1,
            /// wdt_int_st
            WDT_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x78);

        /// address: 0x6002007c
        /// INT_CLR_TIMG_REG
        pub const INT_CLR_TIMERS = @intToPtr(*volatile Mmio(32, packed struct {
            /// t0_int_clr
            T0_INT_CLR: u1,
            /// wdt_int_clr
            WDT_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x7c);

        /// address: 0x60020080
        /// TIMG_RTCCALICFG2_REG.
        pub const RTCCALICFG2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// timeoutindicator
            RTC_CALI_TIMEOUT: u1,
            reserved0: u1,
            reserved1: u1,
            /// reg_rtc_cali_timeout_rst_cnt.Cyclesthatreleasecalibrationtimeoutreset
            RTC_CALI_TIMEOUT_RST_CNT: u4,
            /// reg_rtc_cali_timeout_thres.timeoutifcalivaluecountsoverthreshold
            RTC_CALI_TIMEOUT_THRES: u25,
        }), base_address + 0x80);

        /// address: 0x600200f8
        /// TIMG_NTIMG_DATE_REG.
        pub const NTIMG_DATE = @intToPtr(*volatile Mmio(32, packed struct {
            /// reg_ntimers_date.
            NTIMGS_DATE: u28,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xf8);

        /// address: 0x600200fc
        /// TIMG_REGCLK_REG.
        pub const REGCLK = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// reg_wdt_clk_is_active.
            WDT_CLK_IS_ACTIVE: u1,
            /// reg_timer_clk_is_active.
            TIMER_CLK_IS_ACTIVE: u1,
            /// reg_clk_en.
            CLK_EN: u1,
        }), base_address + 0xfc);
    };

    /// Two-Wire Automotive Interface
    pub const TWAI = struct {
        pub const base_address = 0x6002b000;

        /// address: 0x6002b000
        /// Mode Register
        pub const MODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This bit is used to configure the operating mode of the TWAI Controller. 1:
            /// Reset mode; 0: Operating mode.
            RESET_MODE: u1,
            /// 1: Listen only mode. In this mode the nodes will only receive messages from the
            /// bus, without generating the acknowledge signal nor updating the RX error
            /// counter.
            LISTEN_ONLY_MODE: u1,
            /// 1: Self test mode. In this mode the TX nodes can perform a successful
            /// transmission without receiving the acknowledge signal. This mode is often used
            /// to test a single node with the self reception request command.
            SELF_TEST_MODE: u1,
            /// This bit is used to configure the filter mode. 0: Dual filter mode; 1: Single
            /// filter mode.
            RX_FILTER_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x0);

        /// address: 0x6002b004
        /// Command Register
        pub const CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set the bit to 1 to allow the driving nodes start transmission.
            TX_REQ: u1,
            /// Set the bit to 1 to cancel a pending transmission request.
            ABORT_TX: u1,
            /// Set the bit to 1 to release the RX buffer.
            RELEASE_BUF: u1,
            /// Set the bit to 1 to clear the data overrun status bit.
            CLR_OVERRUN: u1,
            /// Self reception request command. Set the bit to 1 to allow a message be
            /// transmitted and received simultaneously.
            SELF_RX_REQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x4);

        /// address: 0x6002b008
        /// Status register
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: The data in the RX buffer is not empty, with at least one received data
            /// packet.
            RX_BUF_ST: u1,
            /// 1: The RX FIFO is full and data overrun has occurred.
            OVERRUN_ST: u1,
            /// 1: The TX buffer is empty, the CPU may write a message into it.
            TX_BUF_ST: u1,
            /// 1: The TWAI controller has successfully received a packet from the bus.
            TX_COMPLETE: u1,
            /// 1: The TWAI Controller is receiving a message from the bus.
            RX_ST: u1,
            /// 1: The TWAI Controller is transmitting a message to the bus.
            TX_ST: u1,
            /// 1: At least one of the RX/TX error counter has reached or exceeded the value set
            /// in register TWAI_ERR_WARNING_LIMIT_REG.
            ERR_ST: u1,
            /// 1: In bus-off status, the TWAI Controller is no longer involved in bus
            /// activities.
            BUS_OFF_ST: u1,
            /// This bit reflects whether the data packet in the RX FIFO is complete. 1: The
            /// current packet is missing; 0: The current packet is complete
            MISS_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x8);

        /// address: 0x6002b00c
        /// Interrupt Register
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive interrupt. If this bit is set to 1, it indicates there are messages to
            /// be handled in the RX FIFO.
            RX_INT_ST: u1,
            /// Transmit interrupt. If this bit is set to 1, it indicates the message
            /// transmitting mis- sion is finished and a new transmission is able to execute.
            TX_INT_ST: u1,
            /// Error warning interrupt. If this bit is set to 1, it indicates the error status
            /// signal and the bus-off status signal of Status register have changed (e.g.,
            /// switched from 0 to 1 or from 1 to 0).
            ERR_WARN_INT_ST: u1,
            /// Data overrun interrupt. If this bit is set to 1, it indicates a data overrun
            /// interrupt is generated in the RX FIFO.
            OVERRUN_INT_ST: u1,
            reserved0: u1,
            /// Error passive interrupt. If this bit is set to 1, it indicates the TWAI
            /// Controller is switched between error active status and error passive status due
            /// to the change of error counters.
            ERR_PASSIVE_INT_ST: u1,
            /// Arbitration lost interrupt. If this bit is set to 1, it indicates an arbitration
            /// lost interrupt is generated.
            ARB_LOST_INT_ST: u1,
            /// Error interrupt. If this bit is set to 1, it indicates an error is detected on
            /// the bus.
            BUS_ERR_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x6002b010
        /// Interrupt Enable Register
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to 1 to enable receive interrupt.
            RX_INT_ENA: u1,
            /// Set this bit to 1 to enable transmit interrupt.
            TX_INT_ENA: u1,
            /// Set this bit to 1 to enable error warning interrupt.
            ERR_WARN_INT_ENA: u1,
            /// Set this bit to 1 to enable data overrun interrupt.
            OVERRUN_INT_ENA: u1,
            reserved0: u1,
            /// Set this bit to 1 to enable error passive interrupt.
            ERR_PASSIVE_INT_ENA: u1,
            /// Set this bit to 1 to enable arbitration lost interrupt.
            ARB_LOST_INT_ENA: u1,
            /// Set this bit to 1 to enable error interrupt.
            BUS_ERR_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x6002b018
        /// Bus Timing Register 0
        pub const BUS_TIMING_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Baud Rate Prescaler, determines the frequency dividing ratio.
            BAUD_PRESC: u13,
            reserved0: u1,
            /// Synchronization Jump Width (SJW), 1 \verb+~+ 14 Tq wide.
            SYNC_JUMP_WIDTH: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x6002b01c
        /// Bus Timing Register 1
        pub const BUS_TIMING_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// The width of PBS1.
            TIME_SEG1: u4,
            /// The width of PBS2.
            TIME_SEG2: u3,
            /// The number of sample points. 0: the bus is sampled once; 1: the bus is sampled
            /// three times
            TIME_SAMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x6002b02c
        /// Arbitration Lost Capture Register
        pub const ARB_LOST_CAP = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x2c);

        /// address: 0x6002b030
        /// Error Code Capture Register
        pub const ERR_CODE_CAP = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register contains information about the location of errors, see Table 181
            /// for details.
            ECC_SEGMENT: u5,
            /// This register contains information about transmission direction of the node when
            /// error occurs. 1: Error occurs when receiving a message; 0: Error occurs when
            /// transmitting a message
            ECC_DIRECTION: u1,
            /// This register contains information about error types: 00: bit error; 01: form
            /// error; 10: stuff error; 11: other type of error
            ECC_TYPE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x6002b034
        /// Error Warning Limit Register
        pub const ERR_WARNING_LIMIT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x34);

        /// address: 0x6002b038
        /// Receive Error Counter Register
        pub const RX_ERR_CNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x38);

        /// address: 0x6002b03c
        /// Transmit Error Counter Register
        pub const TX_ERR_CNT = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x3c);

        /// address: 0x6002b040
        /// Data register 0
        pub const DATA_0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// In reset mode, it is acceptance code register 0 with R/W Permission. In
            /// operation mode, it stores the 0th byte information of the data to be transmitted
            /// under operating mode.
            TX_BYTE_0: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x40);

        /// address: 0x6002b044
        /// Data register 1
        pub const DATA_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// In reset mode, it is acceptance code register 1 with R/W Permission. In
            /// operation mode, it stores the 1st byte information of the data to be transmitted
            /// under operating mode.
            TX_BYTE_1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x44);

        /// address: 0x6002b048
        /// Data register 2
        pub const DATA_2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// In reset mode, it is acceptance code register 2 with R/W Permission. In
            /// operation mode, it stores the 2nd byte information of the data to be transmitted
            /// under operating mode.
            TX_BYTE_2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x48);

        /// address: 0x6002b04c
        /// Data register 3
        pub const DATA_3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// In reset mode, it is acceptance code register 3 with R/W Permission. In
            /// operation mode, it stores the 3rd byte information of the data to be transmitted
            /// under operating mode.
            TX_BYTE_3: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4c);

        /// address: 0x6002b050
        /// Data register 4
        pub const DATA_4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// In reset mode, it is acceptance mask register 0 with R/W Permission. In
            /// operation mode, it stores the 4th byte information of the data to be transmitted
            /// under operating mode.
            TX_BYTE_4: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x50);

        /// address: 0x6002b054
        /// Data register 5
        pub const DATA_5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// In reset mode, it is acceptance mask register 1 with R/W Permission. In
            /// operation mode, it stores the 5th byte information of the data to be transmitted
            /// under operating mode.
            TX_BYTE_5: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x54);

        /// address: 0x6002b058
        /// Data register 6
        pub const DATA_6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// In reset mode, it is acceptance mask register 2 with R/W Permission. In
            /// operation mode, it stores the 6th byte information of the data to be transmitted
            /// under operating mode.
            TX_BYTE_6: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x58);

        /// address: 0x6002b05c
        /// Data register 7
        pub const DATA_7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// In reset mode, it is acceptance mask register 3 with R/W Permission. In
            /// operation mode, it stores the 7th byte information of the data to be transmitted
            /// under operating mode.
            TX_BYTE_7: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x5c);

        /// address: 0x6002b060
        /// Data register 8
        pub const DATA_8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stored the 8th byte information of the data to be transmitted under operating
            /// mode.
            TX_BYTE_8: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x60);

        /// address: 0x6002b064
        /// Data register 9
        pub const DATA_9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stored the 9th byte information of the data to be transmitted under operating
            /// mode.
            TX_BYTE_9: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x64);

        /// address: 0x6002b068
        /// Data register 10
        pub const DATA_10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stored the 10th byte information of the data to be transmitted under operating
            /// mode.
            TX_BYTE_10: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x68);

        /// address: 0x6002b06c
        /// Data register 11
        pub const DATA_11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stored the 11th byte information of the data to be transmitted under operating
            /// mode.
            TX_BYTE_11: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x6c);

        /// address: 0x6002b070
        /// Data register 12
        pub const DATA_12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stored the 12th byte information of the data to be transmitted under operating
            /// mode.
            TX_BYTE_12: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x70);

        /// address: 0x6002b074
        /// Receive Message Counter Register
        pub const RX_MESSAGE_CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register reflects the number of messages available within the RX FIFO.
            RX_MESSAGE_COUNTER: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x74);

        /// address: 0x6002b07c
        /// Clock Divider register
        pub const CLOCK_DIVIDER = @intToPtr(*volatile Mmio(32, packed struct {
            /// These bits are used to configure frequency dividing coefficients of the external
            /// CLKOUT pin.
            CD: u8,
            /// This bit can be configured under reset mode. 1: Disable the external CLKOUT pin;
            /// 0: Enable the external CLKOUT pin
            CLOCK_OFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x7c);
    };

    /// UART (Universal Asynchronous Receiver-Transmitter) Controller
    pub const UART0 = struct {
        pub const base_address = 0x60000000;

        /// address: 0x60000000
        /// FIFO data register
        pub const FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART 0 accesses FIFO via this register.
            RXFIFO_RD_BYTE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x60000004
        /// Raw interrupt status
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// This interrupt raw bit turns to high level when receiver receives more data than
            /// what rxfifo_full_thrhd specifies.
            RXFIFO_FULL_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is
            /// less than what txfifo_empty_thrhd specifies .
            TXFIFO_EMPTY_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a parity error
            /// in the data.
            PARITY_ERR_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a data frame
            /// error .
            FRM_ERR_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver receives more data than
            /// the FIFO can store.
            RXFIFO_OVF_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects the edge change
            /// of DSRn signal.
            DSR_CHG_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects the edge change
            /// of CTSn signal.
            CTS_CHG_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a 0 after the
            /// stop bit.
            BRK_DET_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver takes more time than
            /// rx_tout_thrhd to receive a byte.
            RXFIFO_TOUT_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver recevies Xon char when
            /// uart_sw_flow_con_en is set to 1.
            SW_XON_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver receives Xoff char when
            /// uart_sw_flow_con_en is set to 1.
            SW_XOFF_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a glitch in the
            /// middle of a start bit.
            GLITCH_DET_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when transmitter completes sending
            /// NULL characters, after all data in Tx-FIFO are sent.
            TX_BRK_DONE_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when transmitter has kept the
            /// shortest duration after sending the last data.
            TX_BRK_IDLE_DONE_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when transmitter has send out all
            /// data in FIFO.
            TX_DONE_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a parity error
            /// from the echo of transmitter in rs485 mode.
            RS485_PARITY_ERR_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a data frame
            /// error from the echo of transmitter in rs485 mode.
            RS485_FRM_ERR_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when detects a clash between
            /// transmitter and receiver in rs485 mode.
            RS485_CLASH_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects the configured
            /// at_cmd char.
            AT_CMD_CHAR_DET_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when input rxd edge changes more
            /// times than what reg_active_threshold specifies in light sleeping mode.
            WAKEUP_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4);

        /// address: 0x60000008
        /// Masked interrupt status
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set
            /// to 1.
            RXFIFO_FULL_INT_ST: u1,
            /// This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set
            /// to 1.
            TXFIFO_EMPTY_INT_ST: u1,
            /// This is the status bit for parity_err_int_raw when parity_err_int_ena is set to
            /// 1.
            PARITY_ERR_INT_ST: u1,
            /// This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
            FRM_ERR_INT_ST: u1,
            /// This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to
            /// 1.
            RXFIFO_OVF_INT_ST: u1,
            /// This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
            DSR_CHG_INT_ST: u1,
            /// This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
            CTS_CHG_INT_ST: u1,
            /// This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
            BRK_DET_INT_ST: u1,
            /// This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set
            /// to 1.
            RXFIFO_TOUT_INT_ST: u1,
            /// This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
            SW_XON_INT_ST: u1,
            /// This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
            SW_XOFF_INT_ST: u1,
            /// This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to
            /// 1.
            GLITCH_DET_INT_ST: u1,
            /// This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set
            /// to 1.
            TX_BRK_DONE_INT_ST: u1,
            /// This is the stauts bit for tx_brk_idle_done_int_raw when
            /// tx_brk_idle_done_int_ena is set to 1.
            TX_BRK_IDLE_DONE_INT_ST: u1,
            /// This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
            TX_DONE_INT_ST: u1,
            /// This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is
            /// set to 1.
            RS485_PARITY_ERR_INT_ST: u1,
            /// This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena is
            /// set to 1.
            RS485_FRM_ERR_INT_ST: u1,
            /// This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set
            /// to 1.
            RS485_CLASH_INT_ST: u1,
            /// This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is
            /// set to 1.
            AT_CMD_CHAR_DET_INT_ST: u1,
            /// This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set
            /// to 1.
            WAKEUP_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x8);

        /// address: 0x6000000c
        /// Interrupt enable bits
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// This is the enable bit for rxfifo_full_int_st register.
            RXFIFO_FULL_INT_ENA: u1,
            /// This is the enable bit for txfifo_empty_int_st register.
            TXFIFO_EMPTY_INT_ENA: u1,
            /// This is the enable bit for parity_err_int_st register.
            PARITY_ERR_INT_ENA: u1,
            /// This is the enable bit for frm_err_int_st register.
            FRM_ERR_INT_ENA: u1,
            /// This is the enable bit for rxfifo_ovf_int_st register.
            RXFIFO_OVF_INT_ENA: u1,
            /// This is the enable bit for dsr_chg_int_st register.
            DSR_CHG_INT_ENA: u1,
            /// This is the enable bit for cts_chg_int_st register.
            CTS_CHG_INT_ENA: u1,
            /// This is the enable bit for brk_det_int_st register.
            BRK_DET_INT_ENA: u1,
            /// This is the enable bit for rxfifo_tout_int_st register.
            RXFIFO_TOUT_INT_ENA: u1,
            /// This is the enable bit for sw_xon_int_st register.
            SW_XON_INT_ENA: u1,
            /// This is the enable bit for sw_xoff_int_st register.
            SW_XOFF_INT_ENA: u1,
            /// This is the enable bit for glitch_det_int_st register.
            GLITCH_DET_INT_ENA: u1,
            /// This is the enable bit for tx_brk_done_int_st register.
            TX_BRK_DONE_INT_ENA: u1,
            /// This is the enable bit for tx_brk_idle_done_int_st register.
            TX_BRK_IDLE_DONE_INT_ENA: u1,
            /// This is the enable bit for tx_done_int_st register.
            TX_DONE_INT_ENA: u1,
            /// This is the enable bit for rs485_parity_err_int_st register.
            RS485_PARITY_ERR_INT_ENA: u1,
            /// This is the enable bit for rs485_parity_err_int_st register.
            RS485_FRM_ERR_INT_ENA: u1,
            /// This is the enable bit for rs485_clash_int_st register.
            RS485_CLASH_INT_ENA: u1,
            /// This is the enable bit for at_cmd_char_det_int_st register.
            AT_CMD_CHAR_DET_INT_ENA: u1,
            /// This is the enable bit for uart_wakeup_int_st register.
            WAKEUP_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0xc);

        /// address: 0x60000010
        /// Interrupt clear bits
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to clear the rxfifo_full_int_raw interrupt.
            RXFIFO_FULL_INT_CLR: u1,
            /// Set this bit to clear txfifo_empty_int_raw interrupt.
            TXFIFO_EMPTY_INT_CLR: u1,
            /// Set this bit to clear parity_err_int_raw interrupt.
            PARITY_ERR_INT_CLR: u1,
            /// Set this bit to clear frm_err_int_raw interrupt.
            FRM_ERR_INT_CLR: u1,
            /// Set this bit to clear rxfifo_ovf_int_raw interrupt.
            RXFIFO_OVF_INT_CLR: u1,
            /// Set this bit to clear the dsr_chg_int_raw interrupt.
            DSR_CHG_INT_CLR: u1,
            /// Set this bit to clear the cts_chg_int_raw interrupt.
            CTS_CHG_INT_CLR: u1,
            /// Set this bit to clear the brk_det_int_raw interrupt.
            BRK_DET_INT_CLR: u1,
            /// Set this bit to clear the rxfifo_tout_int_raw interrupt.
            RXFIFO_TOUT_INT_CLR: u1,
            /// Set this bit to clear the sw_xon_int_raw interrupt.
            SW_XON_INT_CLR: u1,
            /// Set this bit to clear the sw_xoff_int_raw interrupt.
            SW_XOFF_INT_CLR: u1,
            /// Set this bit to clear the glitch_det_int_raw interrupt.
            GLITCH_DET_INT_CLR: u1,
            /// Set this bit to clear the tx_brk_done_int_raw interrupt..
            TX_BRK_DONE_INT_CLR: u1,
            /// Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
            TX_BRK_IDLE_DONE_INT_CLR: u1,
            /// Set this bit to clear the tx_done_int_raw interrupt.
            TX_DONE_INT_CLR: u1,
            /// Set this bit to clear the rs485_parity_err_int_raw interrupt.
            RS485_PARITY_ERR_INT_CLR: u1,
            /// Set this bit to clear the rs485_frm_err_int_raw interrupt.
            RS485_FRM_ERR_INT_CLR: u1,
            /// Set this bit to clear the rs485_clash_int_raw interrupt.
            RS485_CLASH_INT_CLR: u1,
            /// Set this bit to clear the at_cmd_char_det_int_raw interrupt.
            AT_CMD_CHAR_DET_INT_CLR: u1,
            /// Set this bit to clear the uart_wakeup_int_raw interrupt.
            WAKEUP_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x10);

        /// address: 0x60000014
        /// Clock divider configuration
        pub const CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// The integral part of the frequency divider factor.
            CLKDIV: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// The decimal part of the frequency divider factor.
            FRAG: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x14);

        /// address: 0x60000018
        /// Rx Filter configuration
        pub const RX_FILT = @intToPtr(*volatile Mmio(32, packed struct {
            /// when input pulse width is lower than this value, the pulse is ignored.
            GLITCH_FILT: u8,
            /// Set this bit to enable Rx signal filter.
            GLITCH_FILT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x18);

        /// address: 0x6000001c
        /// UART status register
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the byte number of valid data in Rx-FIFO.
            RXFIFO_CNT: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// The register represent the level value of the internal uart dsr signal.
            DSRN: u1,
            /// This register represent the level value of the internal uart cts signal.
            CTSN: u1,
            /// This register represent the level value of the internal uart rxd signal.
            RXD: u1,
            /// Stores the byte number of data in Tx-FIFO.
            TXFIFO_CNT: u10,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// This bit represents the level of the internal uart dtr signal.
            DTRN: u1,
            /// This bit represents the level of the internal uart rts signal.
            RTSN: u1,
            /// This bit represents the level of the internal uart txd signal.
            TXD: u1,
        }), base_address + 0x1c);

        /// address: 0x60000020
        /// a
        pub const CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the parity check mode.
            PARITY: u1,
            /// Set this bit to enable uart parity check.
            PARITY_EN: u1,
            /// This register is used to set the length of data.
            BIT_NUM: u2,
            /// This register is used to set the length of stop bit.
            STOP_BIT_NUM: u2,
            /// This register is used to configure the software rts signal which is used in
            /// software flow control.
            SW_RTS: u1,
            /// This register is used to configure the software dtr signal which is used in
            /// software flow control.
            SW_DTR: u1,
            /// Set this bit to enbale transmitter to send NULL when the process of sending data
            /// is done.
            TXD_BRK: u1,
            /// Set this bit to enable IrDA loopback mode.
            IRDA_DPLX: u1,
            /// This is the start enable bit for IrDA transmitter.
            IRDA_TX_EN: u1,
            /// 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit. 1'h0: Set IrDA
            /// transmitter's 11th bit to 0.
            IRDA_WCTL: u1,
            /// Set this bit to invert the level of IrDA transmitter.
            IRDA_TX_INV: u1,
            /// Set this bit to invert the level of IrDA receiver.
            IRDA_RX_INV: u1,
            /// Set this bit to enable uart loopback test mode.
            LOOPBACK: u1,
            /// Set this bit to enable flow control function for transmitter.
            TX_FLOW_EN: u1,
            /// Set this bit to enable IrDA protocol.
            IRDA_EN: u1,
            /// Set this bit to reset the uart receive-FIFO.
            RXFIFO_RST: u1,
            /// Set this bit to reset the uart transmit-FIFO.
            TXFIFO_RST: u1,
            /// Set this bit to inverse the level value of uart rxd signal.
            RXD_INV: u1,
            /// Set this bit to inverse the level value of uart cts signal.
            CTS_INV: u1,
            /// Set this bit to inverse the level value of uart dsr signal.
            DSR_INV: u1,
            /// Set this bit to inverse the level value of uart txd signal.
            TXD_INV: u1,
            /// Set this bit to inverse the level value of uart rts signal.
            RTS_INV: u1,
            /// Set this bit to inverse the level value of uart dtr signal.
            DTR_INV: u1,
            /// 1'h1: Force clock on for register. 1'h0: Support clock only when application
            /// writes registers.
            CLK_EN: u1,
            /// 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver
            /// stores the data even if the received data is wrong.
            ERR_WR_MASK: u1,
            /// This is the enable bit for detecting baudrate.
            AUTOBAUD_EN: u1,
            /// UART memory clock gate enable signal.
            MEM_CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x20);

        /// address: 0x60000024
        /// Configuration register 1
        pub const CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// It will produce rxfifo_full_int interrupt when receiver receives more data than
            /// this register value.
            RXFIFO_FULL_THRHD: u9,
            /// It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is
            /// less than this register value.
            TXFIFO_EMPTY_THRHD: u9,
            /// Disable UART Rx data overflow detect.
            DIS_RX_DAT_OVF: u1,
            /// Set this bit to stop accumulating idle_cnt when hardware flow control works.
            RX_TOUT_FLOW_DIS: u1,
            /// This is the flow enable bit for UART receiver.
            RX_FLOW_EN: u1,
            /// This is the enble bit for uart receiver's timeout function.
            RX_TOUT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x24);

        /// address: 0x60000028
        /// Autobaud minimum low pulse duration register
        pub const LOWPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the value of the minimum duration time of the low level
            /// pulse. It is used in baud rate-detect process.
            MIN_CNT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x28);

        /// address: 0x6000002c
        /// Autobaud minimum high pulse duration register
        pub const HIGHPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the value of the maxinum duration time for the high level
            /// pulse. It is used in baud rate-detect process.
            MIN_CNT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x60000030
        /// Autobaud edge change count register
        pub const RXD_CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the count of rxd edge change. It is used in baud
            /// rate-detect process.
            RXD_EDGE_CNT: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x30);

        /// address: 0x60000034
        /// Software flow-control configuration
        pub const FLOW_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to enable software flow control. It is used with register sw_xon or
            /// sw_xoff.
            SW_FLOW_CON_EN: u1,
            /// Set this bit to remove flow control char from the received data.
            XONOFF_DEL: u1,
            /// Set this bit to enable the transmitter to go on sending data.
            FORCE_XON: u1,
            /// Set this bit to stop the transmitter from sending data.
            FORCE_XOFF: u1,
            /// Set this bit to send Xon char. It is cleared by hardware automatically.
            SEND_XON: u1,
            /// Set this bit to send Xoff char. It is cleared by hardware automatically.
            SEND_XOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x34);

        /// address: 0x60000038
        /// Sleep-mode configuration
        pub const SLEEP_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// The uart is activated from light sleeping mode when the input rxd edge changes
            /// more times than this register value.
            ACTIVE_THRESHOLD: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x38);

        /// address: 0x6000003c
        /// Software flow-control character configuration
        pub const SWFC_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// When the data amount in Rx-FIFO is more than this register value with
            /// uart_sw_flow_con_en set to 1, it will send a Xoff char.
            XOFF_THRESHOLD: u9,
            /// This register stores the Xoff flow control char.
            XOFF_CHAR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x3c);

        /// address: 0x60000040
        /// Software flow-control character configuration
        pub const SWFC_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// When the data amount in Rx-FIFO is less than this register value with
            /// uart_sw_flow_con_en set to 1, it will send a Xon char.
            XON_THRESHOLD: u9,
            /// This register stores the Xon flow control char.
            XON_CHAR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x40);

        /// address: 0x60000044
        /// Tx Break character configuration
        pub const TXBRK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the number of 0 to be sent after the process
            /// of sending data is done. It is active when txd_brk is set to 1.
            TX_BRK_NUM: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x44);

        /// address: 0x60000048
        /// Frame-end idle configuration
        pub const IDLE_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// It will produce frame end signal when receiver takes more time to receive one
            /// byte data than this register value.
            RX_IDLE_THRHD: u10,
            /// This register is used to configure the duration time between transfers.
            TX_IDLE_NUM: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x48);

        /// address: 0x6000004c
        /// RS485 mode configuration
        pub const RS485_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to choose the rs485 mode.
            RS485_EN: u1,
            /// Set this bit to delay the stop bit by 1 bit.
            DL0_EN: u1,
            /// Set this bit to delay the stop bit by 1 bit.
            DL1_EN: u1,
            /// Set this bit to enable receiver could receive data when the transmitter is
            /// transmitting data in rs485 mode.
            RS485TX_RX_EN: u1,
            /// 1'h1: enable rs485 transmitter to send data when rs485 receiver line is busy.
            RS485RXBY_TX_EN: u1,
            /// This register is used to delay the receiver's internal data signal.
            RS485_RX_DLY_NUM: u1,
            /// This register is used to delay the transmitter's internal data signal.
            RS485_TX_DLY_NUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4c);

        /// address: 0x60000050
        /// Pre-sequence timing configuration
        pub const AT_CMD_PRECNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the idle duration time before the first
            /// at_cmd is received by receiver.
            PRE_IDLE_NUM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x50);

        /// address: 0x60000054
        /// Post-sequence timing configuration
        pub const AT_CMD_POSTCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the duration time between the last at_cmd and
            /// the next data.
            POST_IDLE_NUM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x54);

        /// address: 0x60000058
        /// Timeout configuration
        pub const AT_CMD_GAPTOUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the duration time between the at_cmd chars.
            RX_GAP_TOUT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);

        /// address: 0x6000005c
        /// AT escape sequence detection configuration
        pub const AT_CMD_CHAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the content of at_cmd char.
            AT_CMD_CHAR: u8,
            /// This register is used to configure the num of continuous at_cmd chars received
            /// by receiver.
            CHAR_NUM: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x60000060
        /// UART threshold and allocation configuration
        pub const MEM_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// This register is used to configure the amount of mem allocated for receive-FIFO.
            /// The default number is 128 bytes.
            RX_SIZE: u3,
            /// This register is used to configure the amount of mem allocated for
            /// transmit-FIFO. The default number is 128 bytes.
            TX_SIZE: u3,
            /// This register is used to configure the maximum amount of data that can be
            /// received when hardware flow control works.
            RX_FLOW_THRHD: u9,
            /// This register is used to configure the threshold time that receiver takes to
            /// receive one byte. The rxfifo_tout_int interrupt will be trigger when the
            /// receiver takes more time to receive one byte with rx_tout_en set to 1.
            RX_TOUT_THRHD: u10,
            /// Set this bit to force power down UART memory.
            MEM_FORCE_PD: u1,
            /// Set this bit to force power up UART memory.
            MEM_FORCE_PU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x60);

        /// address: 0x60000064
        /// Tx-FIFO write and read offset address.
        pub const MEM_TX_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the offset address in Tx-FIFO when software writes Tx-FIFO
            /// via APB.
            APB_TX_WADDR: u10,
            reserved0: u1,
            /// This register stores the offset address in Tx-FIFO when Tx-FSM reads data via
            /// Tx-FIFO_Ctrl.
            TX_RADDR: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x64);

        /// address: 0x60000068
        /// Rx-FIFO write and read offset address.
        pub const MEM_RX_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the offset address in RX-FIFO when software reads data from
            /// Rx-FIFO via APB. UART0 is 10'h100. UART1 is 10'h180.
            APB_RX_RADDR: u10,
            reserved0: u1,
            /// This register stores the offset address in Rx-FIFO when Rx-FIFO_Ctrl writes
            /// Rx-FIFO. UART0 is 10'h100. UART1 is 10'h180.
            RX_WADDR: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x68);

        /// address: 0x6000006c
        /// UART transmit and receive status.
        pub const FSM_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This is the status register of receiver.
            ST_URX_OUT: u4,
            /// This is the status register of transmitter.
            ST_UTX_OUT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x6c);

        /// address: 0x60000070
        /// Autobaud high pulse register
        pub const POSPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the minimal input clock count between two positive edges.
            /// It is used in boudrate-detect process.
            POSEDGE_MIN_CNT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x70);

        /// address: 0x60000074
        /// Autobaud low pulse register
        pub const NEGPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the minimal input clock count between two negative edges.
            /// It is used in boudrate-detect process.
            NEGEDGE_MIN_CNT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x74);

        /// address: 0x60000078
        /// UART core clock configuration
        pub const CLK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// The denominator of the frequency divider factor.
            SCLK_DIV_B: u6,
            /// The numerator of the frequency divider factor.
            SCLK_DIV_A: u6,
            /// The integral part of the frequency divider factor.
            SCLK_DIV_NUM: u8,
            /// UART clock source select. 1: 80Mhz, 2: 8Mhz, 3: XTAL.
            SCLK_SEL: u2,
            /// Set this bit to enable UART Tx/Rx clock.
            SCLK_EN: u1,
            /// Write 1 then write 0 to this bit, reset UART Tx/Rx.
            RST_CORE: u1,
            /// Set this bit to enable UART Tx clock.
            TX_SCLK_EN: u1,
            /// Set this bit to enable UART Rx clock.
            RX_SCLK_EN: u1,
            /// Write 1 then write 0 to this bit, reset UART Tx.
            TX_RST_CORE: u1,
            /// Write 1 then write 0 to this bit, reset UART Rx.
            RX_RST_CORE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x78);

        /// address: 0x6000007c
        /// UART Version register
        pub const DATE = @intToPtr(*volatile u32, base_address + 0x7c);

        /// address: 0x60000080
        /// UART ID register
        pub const ID = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the uart_id.
            ID: u30,
            /// This bit used to select synchronize mode. 1: Registers are auto synchronized
            /// into UART Core clock and UART core should be keep the same with APB clock. 0:
            /// After configure registers, software needs to write 1 to UART_REG_UPDATE to
            /// synchronize registers.
            HIGH_SPEED: u1,
            /// Software write 1 would synchronize registers into UART Core clock domain and
            /// would be cleared by hardware after synchronization is done.
            REG_UPDATE: u1,
        }), base_address + 0x80);
    };

    /// UART (Universal Asynchronous Receiver-Transmitter) Controller
    pub const UART1 = struct {
        pub const base_address = 0x60010000;

        /// address: 0x60010000
        /// FIFO data register
        pub const FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// UART 0 accesses FIFO via this register.
            RXFIFO_RD_BYTE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x60010004
        /// Raw interrupt status
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// This interrupt raw bit turns to high level when receiver receives more data than
            /// what rxfifo_full_thrhd specifies.
            RXFIFO_FULL_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is
            /// less than what txfifo_empty_thrhd specifies .
            TXFIFO_EMPTY_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a parity error
            /// in the data.
            PARITY_ERR_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a data frame
            /// error .
            FRM_ERR_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver receives more data than
            /// the FIFO can store.
            RXFIFO_OVF_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects the edge change
            /// of DSRn signal.
            DSR_CHG_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects the edge change
            /// of CTSn signal.
            CTS_CHG_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a 0 after the
            /// stop bit.
            BRK_DET_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver takes more time than
            /// rx_tout_thrhd to receive a byte.
            RXFIFO_TOUT_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver recevies Xon char when
            /// uart_sw_flow_con_en is set to 1.
            SW_XON_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver receives Xoff char when
            /// uart_sw_flow_con_en is set to 1.
            SW_XOFF_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a glitch in the
            /// middle of a start bit.
            GLITCH_DET_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when transmitter completes sending
            /// NULL characters, after all data in Tx-FIFO are sent.
            TX_BRK_DONE_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when transmitter has kept the
            /// shortest duration after sending the last data.
            TX_BRK_IDLE_DONE_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when transmitter has send out all
            /// data in FIFO.
            TX_DONE_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a parity error
            /// from the echo of transmitter in rs485 mode.
            RS485_PARITY_ERR_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects a data frame
            /// error from the echo of transmitter in rs485 mode.
            RS485_FRM_ERR_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when detects a clash between
            /// transmitter and receiver in rs485 mode.
            RS485_CLASH_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when receiver detects the configured
            /// at_cmd char.
            AT_CMD_CHAR_DET_INT_RAW: u1,
            /// This interrupt raw bit turns to high level when input rxd edge changes more
            /// times than what reg_active_threshold specifies in light sleeping mode.
            WAKEUP_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4);

        /// address: 0x60010008
        /// Masked interrupt status
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set
            /// to 1.
            RXFIFO_FULL_INT_ST: u1,
            /// This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set
            /// to 1.
            TXFIFO_EMPTY_INT_ST: u1,
            /// This is the status bit for parity_err_int_raw when parity_err_int_ena is set to
            /// 1.
            PARITY_ERR_INT_ST: u1,
            /// This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
            FRM_ERR_INT_ST: u1,
            /// This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to
            /// 1.
            RXFIFO_OVF_INT_ST: u1,
            /// This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
            DSR_CHG_INT_ST: u1,
            /// This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
            CTS_CHG_INT_ST: u1,
            /// This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
            BRK_DET_INT_ST: u1,
            /// This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set
            /// to 1.
            RXFIFO_TOUT_INT_ST: u1,
            /// This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
            SW_XON_INT_ST: u1,
            /// This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
            SW_XOFF_INT_ST: u1,
            /// This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to
            /// 1.
            GLITCH_DET_INT_ST: u1,
            /// This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set
            /// to 1.
            TX_BRK_DONE_INT_ST: u1,
            /// This is the stauts bit for tx_brk_idle_done_int_raw when
            /// tx_brk_idle_done_int_ena is set to 1.
            TX_BRK_IDLE_DONE_INT_ST: u1,
            /// This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
            TX_DONE_INT_ST: u1,
            /// This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is
            /// set to 1.
            RS485_PARITY_ERR_INT_ST: u1,
            /// This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena is
            /// set to 1.
            RS485_FRM_ERR_INT_ST: u1,
            /// This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set
            /// to 1.
            RS485_CLASH_INT_ST: u1,
            /// This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is
            /// set to 1.
            AT_CMD_CHAR_DET_INT_ST: u1,
            /// This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set
            /// to 1.
            WAKEUP_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x8);

        /// address: 0x6001000c
        /// Interrupt enable bits
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// This is the enable bit for rxfifo_full_int_st register.
            RXFIFO_FULL_INT_ENA: u1,
            /// This is the enable bit for txfifo_empty_int_st register.
            TXFIFO_EMPTY_INT_ENA: u1,
            /// This is the enable bit for parity_err_int_st register.
            PARITY_ERR_INT_ENA: u1,
            /// This is the enable bit for frm_err_int_st register.
            FRM_ERR_INT_ENA: u1,
            /// This is the enable bit for rxfifo_ovf_int_st register.
            RXFIFO_OVF_INT_ENA: u1,
            /// This is the enable bit for dsr_chg_int_st register.
            DSR_CHG_INT_ENA: u1,
            /// This is the enable bit for cts_chg_int_st register.
            CTS_CHG_INT_ENA: u1,
            /// This is the enable bit for brk_det_int_st register.
            BRK_DET_INT_ENA: u1,
            /// This is the enable bit for rxfifo_tout_int_st register.
            RXFIFO_TOUT_INT_ENA: u1,
            /// This is the enable bit for sw_xon_int_st register.
            SW_XON_INT_ENA: u1,
            /// This is the enable bit for sw_xoff_int_st register.
            SW_XOFF_INT_ENA: u1,
            /// This is the enable bit for glitch_det_int_st register.
            GLITCH_DET_INT_ENA: u1,
            /// This is the enable bit for tx_brk_done_int_st register.
            TX_BRK_DONE_INT_ENA: u1,
            /// This is the enable bit for tx_brk_idle_done_int_st register.
            TX_BRK_IDLE_DONE_INT_ENA: u1,
            /// This is the enable bit for tx_done_int_st register.
            TX_DONE_INT_ENA: u1,
            /// This is the enable bit for rs485_parity_err_int_st register.
            RS485_PARITY_ERR_INT_ENA: u1,
            /// This is the enable bit for rs485_parity_err_int_st register.
            RS485_FRM_ERR_INT_ENA: u1,
            /// This is the enable bit for rs485_clash_int_st register.
            RS485_CLASH_INT_ENA: u1,
            /// This is the enable bit for at_cmd_char_det_int_st register.
            AT_CMD_CHAR_DET_INT_ENA: u1,
            /// This is the enable bit for uart_wakeup_int_st register.
            WAKEUP_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0xc);

        /// address: 0x60010010
        /// Interrupt clear bits
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to clear the rxfifo_full_int_raw interrupt.
            RXFIFO_FULL_INT_CLR: u1,
            /// Set this bit to clear txfifo_empty_int_raw interrupt.
            TXFIFO_EMPTY_INT_CLR: u1,
            /// Set this bit to clear parity_err_int_raw interrupt.
            PARITY_ERR_INT_CLR: u1,
            /// Set this bit to clear frm_err_int_raw interrupt.
            FRM_ERR_INT_CLR: u1,
            /// Set this bit to clear rxfifo_ovf_int_raw interrupt.
            RXFIFO_OVF_INT_CLR: u1,
            /// Set this bit to clear the dsr_chg_int_raw interrupt.
            DSR_CHG_INT_CLR: u1,
            /// Set this bit to clear the cts_chg_int_raw interrupt.
            CTS_CHG_INT_CLR: u1,
            /// Set this bit to clear the brk_det_int_raw interrupt.
            BRK_DET_INT_CLR: u1,
            /// Set this bit to clear the rxfifo_tout_int_raw interrupt.
            RXFIFO_TOUT_INT_CLR: u1,
            /// Set this bit to clear the sw_xon_int_raw interrupt.
            SW_XON_INT_CLR: u1,
            /// Set this bit to clear the sw_xoff_int_raw interrupt.
            SW_XOFF_INT_CLR: u1,
            /// Set this bit to clear the glitch_det_int_raw interrupt.
            GLITCH_DET_INT_CLR: u1,
            /// Set this bit to clear the tx_brk_done_int_raw interrupt..
            TX_BRK_DONE_INT_CLR: u1,
            /// Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
            TX_BRK_IDLE_DONE_INT_CLR: u1,
            /// Set this bit to clear the tx_done_int_raw interrupt.
            TX_DONE_INT_CLR: u1,
            /// Set this bit to clear the rs485_parity_err_int_raw interrupt.
            RS485_PARITY_ERR_INT_CLR: u1,
            /// Set this bit to clear the rs485_frm_err_int_raw interrupt.
            RS485_FRM_ERR_INT_CLR: u1,
            /// Set this bit to clear the rs485_clash_int_raw interrupt.
            RS485_CLASH_INT_CLR: u1,
            /// Set this bit to clear the at_cmd_char_det_int_raw interrupt.
            AT_CMD_CHAR_DET_INT_CLR: u1,
            /// Set this bit to clear the uart_wakeup_int_raw interrupt.
            WAKEUP_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x10);

        /// address: 0x60010014
        /// Clock divider configuration
        pub const CLKDIV = @intToPtr(*volatile Mmio(32, packed struct {
            /// The integral part of the frequency divider factor.
            CLKDIV: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// The decimal part of the frequency divider factor.
            FRAG: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x14);

        /// address: 0x60010018
        /// Rx Filter configuration
        pub const RX_FILT = @intToPtr(*volatile Mmio(32, packed struct {
            /// when input pulse width is lower than this value, the pulse is ignored.
            GLITCH_FILT: u8,
            /// Set this bit to enable Rx signal filter.
            GLITCH_FILT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x18);

        /// address: 0x6001001c
        /// UART status register
        pub const STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// Stores the byte number of valid data in Rx-FIFO.
            RXFIFO_CNT: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// The register represent the level value of the internal uart dsr signal.
            DSRN: u1,
            /// This register represent the level value of the internal uart cts signal.
            CTSN: u1,
            /// This register represent the level value of the internal uart rxd signal.
            RXD: u1,
            /// Stores the byte number of data in Tx-FIFO.
            TXFIFO_CNT: u10,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// This bit represents the level of the internal uart dtr signal.
            DTRN: u1,
            /// This bit represents the level of the internal uart rts signal.
            RTSN: u1,
            /// This bit represents the level of the internal uart txd signal.
            TXD: u1,
        }), base_address + 0x1c);

        /// address: 0x60010020
        /// a
        pub const CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the parity check mode.
            PARITY: u1,
            /// Set this bit to enable uart parity check.
            PARITY_EN: u1,
            /// This register is used to set the length of data.
            BIT_NUM: u2,
            /// This register is used to set the length of stop bit.
            STOP_BIT_NUM: u2,
            /// This register is used to configure the software rts signal which is used in
            /// software flow control.
            SW_RTS: u1,
            /// This register is used to configure the software dtr signal which is used in
            /// software flow control.
            SW_DTR: u1,
            /// Set this bit to enbale transmitter to send NULL when the process of sending data
            /// is done.
            TXD_BRK: u1,
            /// Set this bit to enable IrDA loopback mode.
            IRDA_DPLX: u1,
            /// This is the start enable bit for IrDA transmitter.
            IRDA_TX_EN: u1,
            /// 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit. 1'h0: Set IrDA
            /// transmitter's 11th bit to 0.
            IRDA_WCTL: u1,
            /// Set this bit to invert the level of IrDA transmitter.
            IRDA_TX_INV: u1,
            /// Set this bit to invert the level of IrDA receiver.
            IRDA_RX_INV: u1,
            /// Set this bit to enable uart loopback test mode.
            LOOPBACK: u1,
            /// Set this bit to enable flow control function for transmitter.
            TX_FLOW_EN: u1,
            /// Set this bit to enable IrDA protocol.
            IRDA_EN: u1,
            /// Set this bit to reset the uart receive-FIFO.
            RXFIFO_RST: u1,
            /// Set this bit to reset the uart transmit-FIFO.
            TXFIFO_RST: u1,
            /// Set this bit to inverse the level value of uart rxd signal.
            RXD_INV: u1,
            /// Set this bit to inverse the level value of uart cts signal.
            CTS_INV: u1,
            /// Set this bit to inverse the level value of uart dsr signal.
            DSR_INV: u1,
            /// Set this bit to inverse the level value of uart txd signal.
            TXD_INV: u1,
            /// Set this bit to inverse the level value of uart rts signal.
            RTS_INV: u1,
            /// Set this bit to inverse the level value of uart dtr signal.
            DTR_INV: u1,
            /// 1'h1: Force clock on for register. 1'h0: Support clock only when application
            /// writes registers.
            CLK_EN: u1,
            /// 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver
            /// stores the data even if the received data is wrong.
            ERR_WR_MASK: u1,
            /// This is the enable bit for detecting baudrate.
            AUTOBAUD_EN: u1,
            /// UART memory clock gate enable signal.
            MEM_CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x20);

        /// address: 0x60010024
        /// Configuration register 1
        pub const CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// It will produce rxfifo_full_int interrupt when receiver receives more data than
            /// this register value.
            RXFIFO_FULL_THRHD: u9,
            /// It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is
            /// less than this register value.
            TXFIFO_EMPTY_THRHD: u9,
            /// Disable UART Rx data overflow detect.
            DIS_RX_DAT_OVF: u1,
            /// Set this bit to stop accumulating idle_cnt when hardware flow control works.
            RX_TOUT_FLOW_DIS: u1,
            /// This is the flow enable bit for UART receiver.
            RX_FLOW_EN: u1,
            /// This is the enble bit for uart receiver's timeout function.
            RX_TOUT_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x24);

        /// address: 0x60010028
        /// Autobaud minimum low pulse duration register
        pub const LOWPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the value of the minimum duration time of the low level
            /// pulse. It is used in baud rate-detect process.
            MIN_CNT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x28);

        /// address: 0x6001002c
        /// Autobaud minimum high pulse duration register
        pub const HIGHPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the value of the maxinum duration time for the high level
            /// pulse. It is used in baud rate-detect process.
            MIN_CNT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x60010030
        /// Autobaud edge change count register
        pub const RXD_CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the count of rxd edge change. It is used in baud
            /// rate-detect process.
            RXD_EDGE_CNT: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x30);

        /// address: 0x60010034
        /// Software flow-control configuration
        pub const FLOW_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to enable software flow control. It is used with register sw_xon or
            /// sw_xoff.
            SW_FLOW_CON_EN: u1,
            /// Set this bit to remove flow control char from the received data.
            XONOFF_DEL: u1,
            /// Set this bit to enable the transmitter to go on sending data.
            FORCE_XON: u1,
            /// Set this bit to stop the transmitter from sending data.
            FORCE_XOFF: u1,
            /// Set this bit to send Xon char. It is cleared by hardware automatically.
            SEND_XON: u1,
            /// Set this bit to send Xoff char. It is cleared by hardware automatically.
            SEND_XOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x34);

        /// address: 0x60010038
        /// Sleep-mode configuration
        pub const SLEEP_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// The uart is activated from light sleeping mode when the input rxd edge changes
            /// more times than this register value.
            ACTIVE_THRESHOLD: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x38);

        /// address: 0x6001003c
        /// Software flow-control character configuration
        pub const SWFC_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// When the data amount in Rx-FIFO is more than this register value with
            /// uart_sw_flow_con_en set to 1, it will send a Xoff char.
            XOFF_THRESHOLD: u9,
            /// This register stores the Xoff flow control char.
            XOFF_CHAR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x3c);

        /// address: 0x60010040
        /// Software flow-control character configuration
        pub const SWFC_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// When the data amount in Rx-FIFO is less than this register value with
            /// uart_sw_flow_con_en set to 1, it will send a Xon char.
            XON_THRESHOLD: u9,
            /// This register stores the Xon flow control char.
            XON_CHAR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x40);

        /// address: 0x60010044
        /// Tx Break character configuration
        pub const TXBRK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the number of 0 to be sent after the process
            /// of sending data is done. It is active when txd_brk is set to 1.
            TX_BRK_NUM: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x44);

        /// address: 0x60010048
        /// Frame-end idle configuration
        pub const IDLE_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// It will produce frame end signal when receiver takes more time to receive one
            /// byte data than this register value.
            RX_IDLE_THRHD: u10,
            /// This register is used to configure the duration time between transfers.
            TX_IDLE_NUM: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x48);

        /// address: 0x6001004c
        /// RS485 mode configuration
        pub const RS485_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to choose the rs485 mode.
            RS485_EN: u1,
            /// Set this bit to delay the stop bit by 1 bit.
            DL0_EN: u1,
            /// Set this bit to delay the stop bit by 1 bit.
            DL1_EN: u1,
            /// Set this bit to enable receiver could receive data when the transmitter is
            /// transmitting data in rs485 mode.
            RS485TX_RX_EN: u1,
            /// 1'h1: enable rs485 transmitter to send data when rs485 receiver line is busy.
            RS485RXBY_TX_EN: u1,
            /// This register is used to delay the receiver's internal data signal.
            RS485_RX_DLY_NUM: u1,
            /// This register is used to delay the transmitter's internal data signal.
            RS485_TX_DLY_NUM: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4c);

        /// address: 0x60010050
        /// Pre-sequence timing configuration
        pub const AT_CMD_PRECNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the idle duration time before the first
            /// at_cmd is received by receiver.
            PRE_IDLE_NUM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x50);

        /// address: 0x60010054
        /// Post-sequence timing configuration
        pub const AT_CMD_POSTCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the duration time between the last at_cmd and
            /// the next data.
            POST_IDLE_NUM: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x54);

        /// address: 0x60010058
        /// Timeout configuration
        pub const AT_CMD_GAPTOUT = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the duration time between the at_cmd chars.
            RX_GAP_TOUT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);

        /// address: 0x6001005c
        /// AT escape sequence detection configuration
        pub const AT_CMD_CHAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the content of at_cmd char.
            AT_CMD_CHAR: u8,
            /// This register is used to configure the num of continuous at_cmd chars received
            /// by receiver.
            CHAR_NUM: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x60010060
        /// UART threshold and allocation configuration
        pub const MEM_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// This register is used to configure the amount of mem allocated for receive-FIFO.
            /// The default number is 128 bytes.
            RX_SIZE: u3,
            /// This register is used to configure the amount of mem allocated for
            /// transmit-FIFO. The default number is 128 bytes.
            TX_SIZE: u3,
            /// This register is used to configure the maximum amount of data that can be
            /// received when hardware flow control works.
            RX_FLOW_THRHD: u9,
            /// This register is used to configure the threshold time that receiver takes to
            /// receive one byte. The rxfifo_tout_int interrupt will be trigger when the
            /// receiver takes more time to receive one byte with rx_tout_en set to 1.
            RX_TOUT_THRHD: u10,
            /// Set this bit to force power down UART memory.
            MEM_FORCE_PD: u1,
            /// Set this bit to force power up UART memory.
            MEM_FORCE_PU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x60);

        /// address: 0x60010064
        /// Tx-FIFO write and read offset address.
        pub const MEM_TX_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the offset address in Tx-FIFO when software writes Tx-FIFO
            /// via APB.
            APB_TX_WADDR: u10,
            reserved0: u1,
            /// This register stores the offset address in Tx-FIFO when Tx-FSM reads data via
            /// Tx-FIFO_Ctrl.
            TX_RADDR: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x64);

        /// address: 0x60010068
        /// Rx-FIFO write and read offset address.
        pub const MEM_RX_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the offset address in RX-FIFO when software reads data from
            /// Rx-FIFO via APB. UART0 is 10'h100. UART1 is 10'h180.
            APB_RX_RADDR: u10,
            reserved0: u1,
            /// This register stores the offset address in Rx-FIFO when Rx-FIFO_Ctrl writes
            /// Rx-FIFO. UART0 is 10'h100. UART1 is 10'h180.
            RX_WADDR: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x68);

        /// address: 0x6001006c
        /// UART transmit and receive status.
        pub const FSM_STATUS = @intToPtr(*volatile Mmio(32, packed struct {
            /// This is the status register of receiver.
            ST_URX_OUT: u4,
            /// This is the status register of transmitter.
            ST_UTX_OUT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x6c);

        /// address: 0x60010070
        /// Autobaud high pulse register
        pub const POSPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the minimal input clock count between two positive edges.
            /// It is used in boudrate-detect process.
            POSEDGE_MIN_CNT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x70);

        /// address: 0x60010074
        /// Autobaud low pulse register
        pub const NEGPULSE = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register stores the minimal input clock count between two negative edges.
            /// It is used in boudrate-detect process.
            NEGEDGE_MIN_CNT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x74);

        /// address: 0x60010078
        /// UART core clock configuration
        pub const CLK_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// The denominator of the frequency divider factor.
            SCLK_DIV_B: u6,
            /// The numerator of the frequency divider factor.
            SCLK_DIV_A: u6,
            /// The integral part of the frequency divider factor.
            SCLK_DIV_NUM: u8,
            /// UART clock source select. 1: 80Mhz, 2: 8Mhz, 3: XTAL.
            SCLK_SEL: u2,
            /// Set this bit to enable UART Tx/Rx clock.
            SCLK_EN: u1,
            /// Write 1 then write 0 to this bit, reset UART Tx/Rx.
            RST_CORE: u1,
            /// Set this bit to enable UART Tx clock.
            TX_SCLK_EN: u1,
            /// Set this bit to enable UART Rx clock.
            RX_SCLK_EN: u1,
            /// Write 1 then write 0 to this bit, reset UART Tx.
            TX_RST_CORE: u1,
            /// Write 1 then write 0 to this bit, reset UART Rx.
            RX_RST_CORE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x78);

        /// address: 0x6001007c
        /// UART Version register
        pub const DATE = @intToPtr(*volatile u32, base_address + 0x7c);

        /// address: 0x60010080
        /// UART ID register
        pub const ID = @intToPtr(*volatile Mmio(32, packed struct {
            /// This register is used to configure the uart_id.
            ID: u30,
            /// This bit used to select synchronize mode. 1: Registers are auto synchronized
            /// into UART Core clock and UART core should be keep the same with APB clock. 0:
            /// After configure registers, software needs to write 1 to UART_REG_UPDATE to
            /// synchronize registers.
            HIGH_SPEED: u1,
            /// Software write 1 would synchronize registers into UART Core clock domain and
            /// would be cleared by hardware after synchronization is done.
            REG_UPDATE: u1,
        }), base_address + 0x80);
    };

    /// Universal Host Controller Interface
    pub const UHCI0 = struct {
        pub const base_address = 0x60014000;

        /// address: 0x60014000
        /// a
        pub const CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write 1, then write 0 to this bit to reset decode state machine.
            TX_RST: u1,
            /// Write 1, then write 0 to this bit to reset encode state machine.
            RX_RST: u1,
            /// Set this bit to link up HCI and UART0.
            UART0_CE: u1,
            /// Set this bit to link up HCI and UART1.
            UART1_CE: u1,
            reserved0: u1,
            /// Set this bit to separate the data frame using a special char.
            SEPER_EN: u1,
            /// Set this bit to encode the data packet with a formatting header.
            HEAD_EN: u1,
            /// Set this bit to enable UHCI to receive the 16 bit CRC.
            CRC_REC_EN: u1,
            /// If this bit is set to 1, UHCI will end the payload receiving process when UART
            /// has been in idle state.
            UART_IDLE_EOF_EN: u1,
            /// If this bit is set to 1, UHCI decoder receiving payload data is end when the
            /// receiving byte count has reached the specified value. The value is payload
            /// length indicated by UHCI packet header when UHCI_HEAD_EN is 1 or the value is
            /// configuration value when UHCI_HEAD_EN is 0. If this bit is set to 0, UHCI
            /// decoder receiving payload data is end when 0xc0 is received.
            LEN_EOF_EN: u1,
            /// Set this bit to enable data integrity checking by appending a 16 bit CCITT-CRC
            /// to end of the payload.
            ENCODE_CRC_EN: u1,
            /// 1'b1: Force clock on for register. 1'b0: Support clock only when application
            /// writes registers.
            CLK_EN: u1,
            /// If this bit is set to 1, UHCI will end payload receive process when NULL frame
            /// is received by UART.
            UART_RX_BRK_EOF_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x60014004
        /// a
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_START_INT_RAW: u1,
            /// a
            TX_START_INT_RAW: u1,
            /// a
            RX_HUNG_INT_RAW: u1,
            /// a
            TX_HUNG_INT_RAW: u1,
            /// a
            SEND_S_REG_Q_INT_RAW: u1,
            /// a
            SEND_A_REG_Q_INT_RAW: u1,
            /// This is the interrupt raw bit. Triggered when there are some errors in EOF in
            /// the
            OUT_EOF_INT_RAW: u1,
            /// Soft control int raw bit.
            APP_CTRL0_INT_RAW: u1,
            /// Soft control int raw bit.
            APP_CTRL1_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x4);

        /// address: 0x60014008
        /// a
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_START_INT_ST: u1,
            /// a
            TX_START_INT_ST: u1,
            /// a
            RX_HUNG_INT_ST: u1,
            /// a
            TX_HUNG_INT_ST: u1,
            /// a
            SEND_S_REG_Q_INT_ST: u1,
            /// a
            SEND_A_REG_Q_INT_ST: u1,
            /// a
            OUTLINK_EOF_ERR_INT_ST: u1,
            /// a
            APP_CTRL0_INT_ST: u1,
            /// a
            APP_CTRL1_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x8);

        /// address: 0x6001400c
        /// a
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_START_INT_ENA: u1,
            /// a
            TX_START_INT_ENA: u1,
            /// a
            RX_HUNG_INT_ENA: u1,
            /// a
            TX_HUNG_INT_ENA: u1,
            /// a
            SEND_S_REG_Q_INT_ENA: u1,
            /// a
            SEND_A_REG_Q_INT_ENA: u1,
            /// a
            OUTLINK_EOF_ERR_INT_ENA: u1,
            /// a
            APP_CTRL0_INT_ENA: u1,
            /// a
            APP_CTRL1_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x60014010
        /// a
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_START_INT_CLR: u1,
            /// a
            TX_START_INT_CLR: u1,
            /// a
            RX_HUNG_INT_CLR: u1,
            /// a
            TX_HUNG_INT_CLR: u1,
            /// a
            SEND_S_REG_Q_INT_CLR: u1,
            /// a
            SEND_A_REG_Q_INT_CLR: u1,
            /// a
            OUTLINK_EOF_ERR_INT_CLR: u1,
            /// a
            APP_CTRL0_INT_CLR: u1,
            /// a
            APP_CTRL1_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x10);

        /// address: 0x60014014
        /// a
        pub const CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            CHECK_SUM_EN: u1,
            /// a
            CHECK_SEQ_EN: u1,
            /// a
            CRC_DISABLE: u1,
            /// a
            SAVE_HEAD: u1,
            /// a
            TX_CHECK_SUM_RE: u1,
            /// a
            TX_ACK_NUM_RE: u1,
            reserved0: u1,
            /// a
            WAIT_SW_START: u1,
            /// a
            SW_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x14);

        /// address: 0x60014018
        /// a
        pub const STATE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_ERR_CAUSE: u3,
            /// a
            DECODE_STATE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x18);

        /// address: 0x6001401c
        /// a
        pub const STATE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ENCODE_STATE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x1c);

        /// address: 0x60014020
        /// a
        pub const ESCAPE_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            TX_C0_ESC_EN: u1,
            /// a
            TX_DB_ESC_EN: u1,
            /// a
            TX_11_ESC_EN: u1,
            /// a
            TX_13_ESC_EN: u1,
            /// a
            RX_C0_ESC_EN: u1,
            /// a
            RX_DB_ESC_EN: u1,
            /// a
            RX_11_ESC_EN: u1,
            /// a
            RX_13_ESC_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x60014024
        /// a
        pub const HUNG_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            TXFIFO_TIMEOUT: u8,
            /// a
            TXFIFO_TIMEOUT_SHIFT: u3,
            /// a
            TXFIFO_TIMEOUT_ENA: u1,
            /// a
            RXFIFO_TIMEOUT: u8,
            /// a
            RXFIFO_TIMEOUT_SHIFT: u3,
            /// a
            RXFIFO_TIMEOUT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x60014028
        /// a
        pub const ACK_NUM = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ACK_NUM: u3,
            /// a
            LOAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x28);

        /// address: 0x6001402c
        /// a
        pub const RX_HEAD = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x60014030
        /// a
        pub const QUICK_SENT = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SINGLE_SEND_NUM: u3,
            /// a
            SINGLE_SEND_EN: u1,
            /// a
            ALWAYS_SEND_NUM: u3,
            /// a
            ALWAYS_SEND_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x60014034
        /// a
        pub const REG_Q0_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q0_WORD0: u32,
        }), base_address + 0x34);

        /// address: 0x60014038
        /// a
        pub const REG_Q0_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q0_WORD1: u32,
        }), base_address + 0x38);

        /// address: 0x6001403c
        /// a
        pub const REG_Q1_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q1_WORD0: u32,
        }), base_address + 0x3c);

        /// address: 0x60014040
        /// a
        pub const REG_Q1_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q1_WORD1: u32,
        }), base_address + 0x40);

        /// address: 0x60014044
        /// a
        pub const REG_Q2_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q2_WORD0: u32,
        }), base_address + 0x44);

        /// address: 0x60014048
        /// a
        pub const REG_Q2_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q2_WORD1: u32,
        }), base_address + 0x48);

        /// address: 0x6001404c
        /// a
        pub const REG_Q3_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q3_WORD0: u32,
        }), base_address + 0x4c);

        /// address: 0x60014050
        /// a
        pub const REG_Q3_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q3_WORD1: u32,
        }), base_address + 0x50);

        /// address: 0x60014054
        /// a
        pub const REG_Q4_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q4_WORD0: u32,
        }), base_address + 0x54);

        /// address: 0x60014058
        /// a
        pub const REG_Q4_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q4_WORD1: u32,
        }), base_address + 0x58);

        /// address: 0x6001405c
        /// a
        pub const REG_Q5_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q5_WORD0: u32,
        }), base_address + 0x5c);

        /// address: 0x60014060
        /// a
        pub const REG_Q5_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q5_WORD1: u32,
        }), base_address + 0x60);

        /// address: 0x60014064
        /// a
        pub const REG_Q6_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q6_WORD0: u32,
        }), base_address + 0x64);

        /// address: 0x60014068
        /// a
        pub const REG_Q6_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q6_WORD1: u32,
        }), base_address + 0x68);

        /// address: 0x6001406c
        /// a
        pub const ESC_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEPER_CHAR: u8,
            /// a
            SEPER_ESC_CHAR0: u8,
            /// a
            SEPER_ESC_CHAR1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x60014070
        /// a
        pub const ESC_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ESC_SEQ0: u8,
            /// a
            ESC_SEQ0_CHAR0: u8,
            /// a
            ESC_SEQ0_CHAR1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x60014074
        /// a
        pub const ESC_CONF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ESC_SEQ1: u8,
            /// a
            ESC_SEQ1_CHAR0: u8,
            /// a
            ESC_SEQ1_CHAR1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x74);

        /// address: 0x60014078
        /// a
        pub const ESC_CONF3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ESC_SEQ2: u8,
            /// a
            ESC_SEQ2_CHAR0: u8,
            /// a
            ESC_SEQ2_CHAR1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x78);

        /// address: 0x6001407c
        /// a
        pub const PKT_THRES = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            PKT_THRS: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x7c);

        /// address: 0x60014080
        /// a
        pub const DATE = @intToPtr(*volatile u32, base_address + 0x80);
    };

    /// Universal Host Controller Interface
    pub const UHCI1 = struct {
        pub const base_address = 0x6000c000;

        /// address: 0x6000c000
        /// a
        pub const CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write 1, then write 0 to this bit to reset decode state machine.
            TX_RST: u1,
            /// Write 1, then write 0 to this bit to reset encode state machine.
            RX_RST: u1,
            /// Set this bit to link up HCI and UART0.
            UART0_CE: u1,
            /// Set this bit to link up HCI and UART1.
            UART1_CE: u1,
            reserved0: u1,
            /// Set this bit to separate the data frame using a special char.
            SEPER_EN: u1,
            /// Set this bit to encode the data packet with a formatting header.
            HEAD_EN: u1,
            /// Set this bit to enable UHCI to receive the 16 bit CRC.
            CRC_REC_EN: u1,
            /// If this bit is set to 1, UHCI will end the payload receiving process when UART
            /// has been in idle state.
            UART_IDLE_EOF_EN: u1,
            /// If this bit is set to 1, UHCI decoder receiving payload data is end when the
            /// receiving byte count has reached the specified value. The value is payload
            /// length indicated by UHCI packet header when UHCI_HEAD_EN is 1 or the value is
            /// configuration value when UHCI_HEAD_EN is 0. If this bit is set to 0, UHCI
            /// decoder receiving payload data is end when 0xc0 is received.
            LEN_EOF_EN: u1,
            /// Set this bit to enable data integrity checking by appending a 16 bit CCITT-CRC
            /// to end of the payload.
            ENCODE_CRC_EN: u1,
            /// 1'b1: Force clock on for register. 1'b0: Support clock only when application
            /// writes registers.
            CLK_EN: u1,
            /// If this bit is set to 1, UHCI will end payload receive process when NULL frame
            /// is received by UART.
            UART_RX_BRK_EOF_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x6000c004
        /// a
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_START_INT_RAW: u1,
            /// a
            TX_START_INT_RAW: u1,
            /// a
            RX_HUNG_INT_RAW: u1,
            /// a
            TX_HUNG_INT_RAW: u1,
            /// a
            SEND_S_REG_Q_INT_RAW: u1,
            /// a
            SEND_A_REG_Q_INT_RAW: u1,
            /// This is the interrupt raw bit. Triggered when there are some errors in EOF in
            /// the
            OUT_EOF_INT_RAW: u1,
            /// Soft control int raw bit.
            APP_CTRL0_INT_RAW: u1,
            /// Soft control int raw bit.
            APP_CTRL1_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x4);

        /// address: 0x6000c008
        /// a
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_START_INT_ST: u1,
            /// a
            TX_START_INT_ST: u1,
            /// a
            RX_HUNG_INT_ST: u1,
            /// a
            TX_HUNG_INT_ST: u1,
            /// a
            SEND_S_REG_Q_INT_ST: u1,
            /// a
            SEND_A_REG_Q_INT_ST: u1,
            /// a
            OUTLINK_EOF_ERR_INT_ST: u1,
            /// a
            APP_CTRL0_INT_ST: u1,
            /// a
            APP_CTRL1_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x8);

        /// address: 0x6000c00c
        /// a
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_START_INT_ENA: u1,
            /// a
            TX_START_INT_ENA: u1,
            /// a
            RX_HUNG_INT_ENA: u1,
            /// a
            TX_HUNG_INT_ENA: u1,
            /// a
            SEND_S_REG_Q_INT_ENA: u1,
            /// a
            SEND_A_REG_Q_INT_ENA: u1,
            /// a
            OUTLINK_EOF_ERR_INT_ENA: u1,
            /// a
            APP_CTRL0_INT_ENA: u1,
            /// a
            APP_CTRL1_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x6000c010
        /// a
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_START_INT_CLR: u1,
            /// a
            TX_START_INT_CLR: u1,
            /// a
            RX_HUNG_INT_CLR: u1,
            /// a
            TX_HUNG_INT_CLR: u1,
            /// a
            SEND_S_REG_Q_INT_CLR: u1,
            /// a
            SEND_A_REG_Q_INT_CLR: u1,
            /// a
            OUTLINK_EOF_ERR_INT_CLR: u1,
            /// a
            APP_CTRL0_INT_CLR: u1,
            /// a
            APP_CTRL1_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x10);

        /// address: 0x6000c014
        /// a
        pub const CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            CHECK_SUM_EN: u1,
            /// a
            CHECK_SEQ_EN: u1,
            /// a
            CRC_DISABLE: u1,
            /// a
            SAVE_HEAD: u1,
            /// a
            TX_CHECK_SUM_RE: u1,
            /// a
            TX_ACK_NUM_RE: u1,
            reserved0: u1,
            /// a
            WAIT_SW_START: u1,
            /// a
            SW_START: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x14);

        /// address: 0x6000c018
        /// a
        pub const STATE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            RX_ERR_CAUSE: u3,
            /// a
            DECODE_STATE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x18);

        /// address: 0x6000c01c
        /// a
        pub const STATE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ENCODE_STATE: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x1c);

        /// address: 0x6000c020
        /// a
        pub const ESCAPE_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            TX_C0_ESC_EN: u1,
            /// a
            TX_DB_ESC_EN: u1,
            /// a
            TX_11_ESC_EN: u1,
            /// a
            TX_13_ESC_EN: u1,
            /// a
            RX_C0_ESC_EN: u1,
            /// a
            RX_DB_ESC_EN: u1,
            /// a
            RX_11_ESC_EN: u1,
            /// a
            RX_13_ESC_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x6000c024
        /// a
        pub const HUNG_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            TXFIFO_TIMEOUT: u8,
            /// a
            TXFIFO_TIMEOUT_SHIFT: u3,
            /// a
            TXFIFO_TIMEOUT_ENA: u1,
            /// a
            RXFIFO_TIMEOUT: u8,
            /// a
            RXFIFO_TIMEOUT_SHIFT: u3,
            /// a
            RXFIFO_TIMEOUT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x6000c028
        /// a
        pub const ACK_NUM = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ACK_NUM: u3,
            /// a
            LOAD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x28);

        /// address: 0x6000c02c
        /// a
        pub const RX_HEAD = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x6000c030
        /// a
        pub const QUICK_SENT = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SINGLE_SEND_NUM: u3,
            /// a
            SINGLE_SEND_EN: u1,
            /// a
            ALWAYS_SEND_NUM: u3,
            /// a
            ALWAYS_SEND_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x6000c034
        /// a
        pub const REG_Q0_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q0_WORD0: u32,
        }), base_address + 0x34);

        /// address: 0x6000c038
        /// a
        pub const REG_Q0_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q0_WORD1: u32,
        }), base_address + 0x38);

        /// address: 0x6000c03c
        /// a
        pub const REG_Q1_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q1_WORD0: u32,
        }), base_address + 0x3c);

        /// address: 0x6000c040
        /// a
        pub const REG_Q1_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q1_WORD1: u32,
        }), base_address + 0x40);

        /// address: 0x6000c044
        /// a
        pub const REG_Q2_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q2_WORD0: u32,
        }), base_address + 0x44);

        /// address: 0x6000c048
        /// a
        pub const REG_Q2_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q2_WORD1: u32,
        }), base_address + 0x48);

        /// address: 0x6000c04c
        /// a
        pub const REG_Q3_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q3_WORD0: u32,
        }), base_address + 0x4c);

        /// address: 0x6000c050
        /// a
        pub const REG_Q3_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q3_WORD1: u32,
        }), base_address + 0x50);

        /// address: 0x6000c054
        /// a
        pub const REG_Q4_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q4_WORD0: u32,
        }), base_address + 0x54);

        /// address: 0x6000c058
        /// a
        pub const REG_Q4_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q4_WORD1: u32,
        }), base_address + 0x58);

        /// address: 0x6000c05c
        /// a
        pub const REG_Q5_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q5_WORD0: u32,
        }), base_address + 0x5c);

        /// address: 0x6000c060
        /// a
        pub const REG_Q5_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q5_WORD1: u32,
        }), base_address + 0x60);

        /// address: 0x6000c064
        /// a
        pub const REG_Q6_WORD0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q6_WORD0: u32,
        }), base_address + 0x64);

        /// address: 0x6000c068
        /// a
        pub const REG_Q6_WORD1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEND_Q6_WORD1: u32,
        }), base_address + 0x68);

        /// address: 0x6000c06c
        /// a
        pub const ESC_CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            SEPER_CHAR: u8,
            /// a
            SEPER_ESC_CHAR0: u8,
            /// a
            SEPER_ESC_CHAR1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x6c);

        /// address: 0x6000c070
        /// a
        pub const ESC_CONF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ESC_SEQ0: u8,
            /// a
            ESC_SEQ0_CHAR0: u8,
            /// a
            ESC_SEQ0_CHAR1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x70);

        /// address: 0x6000c074
        /// a
        pub const ESC_CONF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ESC_SEQ1: u8,
            /// a
            ESC_SEQ1_CHAR0: u8,
            /// a
            ESC_SEQ1_CHAR1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x74);

        /// address: 0x6000c078
        /// a
        pub const ESC_CONF3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            ESC_SEQ2: u8,
            /// a
            ESC_SEQ2_CHAR0: u8,
            /// a
            ESC_SEQ2_CHAR1: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x78);

        /// address: 0x6000c07c
        /// a
        pub const PKT_THRES = @intToPtr(*volatile Mmio(32, packed struct {
            /// a
            PKT_THRS: u13,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x7c);

        /// address: 0x6000c080
        /// a
        pub const DATE = @intToPtr(*volatile u32, base_address + 0x80);
    };

    /// Full-speed USB Serial/JTAG Controller
    pub const USB_DEVICE = struct {
        pub const base_address = 0x60043000;

        /// address: 0x60043000
        /// USB_DEVICE_EP1_REG.
        pub const EP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write and read byte data to/from UART Tx/Rx FIFO through this field. When
            /// USB_DEVICE_SERIAL_IN_EMPTY_INT is set, then user can write data (up to 64 bytes)
            /// into UART Tx FIFO. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is set, user can
            /// check USB_DEVICE_OUT_EP1_WR_ADDR USB_DEVICE_OUT_EP0_RD_ADDR to know how many
            /// data is received, then read data from UART Rx FIFO.
            RDWR_BYTE: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x60043004
        /// USB_DEVICE_EP1_CONF_REG.
        pub const EP1_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to indicate writing byte data to UART Tx FIFO is done.
            WR_DONE: u1,
            /// 1'b1: Indicate UART Tx FIFO is not full and can write data into in. After
            /// writing USB_DEVICE_WR_DONE, this bit would be 0 until data in UART Tx FIFO is
            /// read by USB Host.
            SERIAL_IN_EP_DATA_FREE: u1,
            /// 1'b1: Indicate there is data in UART Rx FIFO.
            SERIAL_OUT_EP_DATA_AVAIL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0x60043008
        /// USB_DEVICE_INT_RAW_REG.
        pub const INT_RAW = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw interrupt bit turns to high level when flush cmd is received for IN
            /// endpoint 2 of JTAG.
            JTAG_IN_FLUSH_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when SOF frame is received.
            SOF_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when Serial Port OUT Endpoint received
            /// one packet.
            SERIAL_OUT_RECV_PKT_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when Serial Port IN Endpoint is empty.
            SERIAL_IN_EMPTY_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when pid error is detected.
            PID_ERR_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when CRC5 error is detected.
            CRC5_ERR_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when CRC16 error is detected.
            CRC16_ERR_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when stuff error is detected.
            STUFF_ERR_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when IN token for IN endpoint 1 is
            /// received.
            IN_TOKEN_REC_IN_EP1_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when usb bus reset is detected.
            USB_BUS_RESET_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when OUT endpoint 1 received packet
            /// with zero palyload.
            OUT_EP1_ZERO_PAYLOAD_INT_RAW: u1,
            /// The raw interrupt bit turns to high level when OUT endpoint 2 received packet
            /// with zero palyload.
            OUT_EP2_ZERO_PAYLOAD_INT_RAW: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x6004300c
        /// USB_DEVICE_INT_ST_REG.
        pub const INT_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// The raw interrupt status bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
            JTAG_IN_FLUSH_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_SOF_INT interrupt.
            SOF_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT
            /// interrupt.
            SERIAL_OUT_RECV_PKT_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
            SERIAL_IN_EMPTY_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_PID_ERR_INT interrupt.
            PID_ERR_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
            CRC5_ERR_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
            CRC16_ERR_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
            STUFF_ERR_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT
            /// interrupt.
            IN_TOKEN_REC_IN_EP1_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
            USB_BUS_RESET_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT
            /// interrupt.
            OUT_EP1_ZERO_PAYLOAD_INT_ST: u1,
            /// The raw interrupt status bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT
            /// interrupt.
            OUT_EP2_ZERO_PAYLOAD_INT_ST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0xc);

        /// address: 0x60043010
        /// USB_DEVICE_INT_ENA_REG.
        pub const INT_ENA = @intToPtr(*volatile Mmio(32, packed struct {
            /// The interrupt enable bit for the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
            JTAG_IN_FLUSH_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_SOF_INT interrupt.
            SOF_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
            SERIAL_OUT_RECV_PKT_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
            SERIAL_IN_EMPTY_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_PID_ERR_INT interrupt.
            PID_ERR_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_CRC5_ERR_INT interrupt.
            CRC5_ERR_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_CRC16_ERR_INT interrupt.
            CRC16_ERR_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_STUFF_ERR_INT interrupt.
            STUFF_ERR_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT interrupt.
            IN_TOKEN_REC_IN_EP1_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_USB_BUS_RESET_INT interrupt.
            USB_BUS_RESET_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
            OUT_EP1_ZERO_PAYLOAD_INT_ENA: u1,
            /// The interrupt enable bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
            OUT_EP2_ZERO_PAYLOAD_INT_ENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x10);

        /// address: 0x60043014
        /// USB_DEVICE_INT_CLR_REG.
        pub const INT_CLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Set this bit to clear the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.
            JTAG_IN_FLUSH_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_JTAG_SOF_INT interrupt.
            SOF_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT interrupt.
            SERIAL_OUT_RECV_PKT_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.
            SERIAL_IN_EMPTY_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_PID_ERR_INT interrupt.
            PID_ERR_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_CRC5_ERR_INT interrupt.
            CRC5_ERR_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_CRC16_ERR_INT interrupt.
            CRC16_ERR_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_STUFF_ERR_INT interrupt.
            STUFF_ERR_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_IN_TOKEN_IN_EP1_INT interrupt.
            IN_TOKEN_REC_IN_EP1_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_USB_BUS_RESET_INT interrupt.
            USB_BUS_RESET_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT interrupt.
            OUT_EP1_ZERO_PAYLOAD_INT_CLR: u1,
            /// Set this bit to clear the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT interrupt.
            OUT_EP2_ZERO_PAYLOAD_INT_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x60043018
        /// USB_DEVICE_CONF0_REG.
        pub const CONF0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Select internal/external PHY
            PHY_SEL: u1,
            /// Enable software control USB D+ D- exchange
            EXCHG_PINS_OVERRIDE: u1,
            /// USB D+ D- exchange
            EXCHG_PINS: u1,
            /// Control single-end input high threshold,1.76V to 2V, step 80mV
            VREFH: u2,
            /// Control single-end input low threshold,0.8V to 1.04V, step 80mV
            VREFL: u2,
            /// Enable software control input threshold
            VREF_OVERRIDE: u1,
            /// Enable software control USB D+ D- pullup pulldown
            PAD_PULL_OVERRIDE: u1,
            /// Control USB D+ pull up.
            DP_PULLUP: u1,
            /// Control USB D+ pull down.
            DP_PULLDOWN: u1,
            /// Control USB D- pull up.
            DM_PULLUP: u1,
            /// Control USB D- pull down.
            DM_PULLDOWN: u1,
            /// Control pull up value.
            PULLUP_VALUE: u1,
            /// Enable USB pad function.
            USB_PAD_ENABLE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x6004301c
        /// USB_DEVICE_TEST_REG.
        pub const TEST = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable test of the USB pad
            ENABLE: u1,
            /// USB pad oen in test
            USB_OE: u1,
            /// USB D+ tx value in test
            TX_DP: u1,
            /// USB D- tx value in test
            TX_DM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x1c);

        /// address: 0x60043020
        /// USB_DEVICE_JFIFO_ST_REG.
        pub const JFIFO_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// JTAT in fifo counter.
            IN_FIFO_CNT: u2,
            /// 1: JTAG in fifo is empty.
            IN_FIFO_EMPTY: u1,
            /// 1: JTAG in fifo is full.
            IN_FIFO_FULL: u1,
            /// JTAT out fifo counter.
            OUT_FIFO_CNT: u2,
            /// 1: JTAG out fifo is empty.
            OUT_FIFO_EMPTY: u1,
            /// 1: JTAG out fifo is full.
            OUT_FIFO_FULL: u1,
            /// Write 1 to reset JTAG in fifo.
            IN_FIFO_RESET: u1,
            /// Write 1 to reset JTAG out fifo.
            OUT_FIFO_RESET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);

        /// address: 0x60043024
        /// USB_DEVICE_FRAM_NUM_REG.
        pub const FRAM_NUM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame index of received SOF frame.
            SOF_FRAME_INDEX: u11,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x24);

        /// address: 0x60043028
        /// USB_DEVICE_IN_EP0_ST_REG.
        pub const IN_EP0_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// State of IN Endpoint 0.
            IN_EP0_STATE: u2,
            /// Write data address of IN endpoint 0.
            IN_EP0_WR_ADDR: u7,
            /// Read data address of IN endpoint 0.
            IN_EP0_RD_ADDR: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x6004302c
        /// USB_DEVICE_IN_EP1_ST_REG.
        pub const IN_EP1_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// State of IN Endpoint 1.
            IN_EP1_STATE: u2,
            /// Write data address of IN endpoint 1.
            IN_EP1_WR_ADDR: u7,
            /// Read data address of IN endpoint 1.
            IN_EP1_RD_ADDR: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x60043030
        /// USB_DEVICE_IN_EP2_ST_REG.
        pub const IN_EP2_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// State of IN Endpoint 2.
            IN_EP2_STATE: u2,
            /// Write data address of IN endpoint 2.
            IN_EP2_WR_ADDR: u7,
            /// Read data address of IN endpoint 2.
            IN_EP2_RD_ADDR: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);

        /// address: 0x60043034
        /// USB_DEVICE_IN_EP3_ST_REG.
        pub const IN_EP3_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// State of IN Endpoint 3.
            IN_EP3_STATE: u2,
            /// Write data address of IN endpoint 3.
            IN_EP3_WR_ADDR: u7,
            /// Read data address of IN endpoint 3.
            IN_EP3_RD_ADDR: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x60043038
        /// USB_DEVICE_OUT_EP0_ST_REG.
        pub const OUT_EP0_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// State of OUT Endpoint 0.
            OUT_EP0_STATE: u2,
            /// Write data address of OUT endpoint 0. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is
            /// detected, there are USB_DEVICE_OUT_EP0_WR_ADDR-2 bytes data in OUT EP0.
            OUT_EP0_WR_ADDR: u7,
            /// Read data address of OUT endpoint 0.
            OUT_EP0_RD_ADDR: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x6004303c
        /// USB_DEVICE_OUT_EP1_ST_REG.
        pub const OUT_EP1_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// State of OUT Endpoint 1.
            OUT_EP1_STATE: u2,
            /// Write data address of OUT endpoint 1. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is
            /// detected, there are USB_DEVICE_OUT_EP1_WR_ADDR-2 bytes data in OUT EP1.
            OUT_EP1_WR_ADDR: u7,
            /// Read data address of OUT endpoint 1.
            OUT_EP1_RD_ADDR: u7,
            /// Data count in OUT endpoint 1 when one packet is received.
            OUT_EP1_REC_DATA_CNT: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x3c);

        /// address: 0x60043040
        /// USB_DEVICE_OUT_EP2_ST_REG.
        pub const OUT_EP2_ST = @intToPtr(*volatile Mmio(32, packed struct {
            /// State of OUT Endpoint 2.
            OUT_EP2_STATE: u2,
            /// Write data address of OUT endpoint 2. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is
            /// detected, there are USB_DEVICE_OUT_EP2_WR_ADDR-2 bytes data in OUT EP2.
            OUT_EP2_WR_ADDR: u7,
            /// Read data address of OUT endpoint 2.
            OUT_EP2_RD_ADDR: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x60043044
        /// USB_DEVICE_MISC_CONF_REG.
        pub const MISC_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1'h1: Force clock on for register. 1'h0: Support clock only when application
            /// writes registers.
            CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x44);

        /// address: 0x60043048
        /// USB_DEVICE_MEM_CONF_REG.
        pub const MEM_CONF = @intToPtr(*volatile Mmio(32, packed struct {
            /// 1: power down usb memory.
            USB_MEM_PD: u1,
            /// 1: Force clock on for usb memory.
            USB_MEM_CLK_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x48);

        /// address: 0x60043080
        /// USB_DEVICE_DATE_REG.
        pub const DATE = @intToPtr(*volatile u32, base_address + 0x80);
    };

    /// XTS-AES-128 Flash Encryption
    pub const XTS_AES = struct {
        pub const base_address = 0x600cc000;

        /// address: 0x600cc000
        /// The memory that stores plaintext
        pub const PLAIN_MEM = @intToPtr(*volatile [16]u8, base_address + 0x0);

        /// address: 0x600cc040
        /// XTS-AES line-size register
        pub const LINESIZE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x40);

        /// address: 0x600cc044
        /// XTS-AES destination register
        pub const DESTINATION = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x44);

        /// address: 0x600cc048
        /// XTS-AES physical address register
        pub const PHYSICAL_ADDRESS = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x48);

        /// address: 0x600cc04c
        /// XTS-AES trigger register
        pub const TRIGGER = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x4c);

        /// address: 0x600cc050
        /// XTS-AES release register
        pub const RELEASE = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x50);

        /// address: 0x600cc054
        /// XTS-AES destroy register
        pub const DESTROY = @intToPtr(*volatile MmioInt(32, u1), base_address + 0x54);

        /// address: 0x600cc058
        /// XTS-AES status register
        pub const STATE = @intToPtr(*volatile MmioInt(32, u2), base_address + 0x58);

        /// address: 0x600cc05c
        /// XTS-AES version control register
        pub const DATE = @intToPtr(*volatile MmioInt(32, u30), base_address + 0x5c);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
